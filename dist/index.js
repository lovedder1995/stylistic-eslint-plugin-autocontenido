var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@typescript-eslint/types/dist/generated/ast-spec.js
var require_ast_spec = __commonJS({
  "node_modules/@typescript-eslint/types/dist/generated/ast-spec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST_TOKEN_TYPES = exports2.AST_NODE_TYPES = void 0;
    var AST_NODE_TYPES2;
    (function(AST_NODE_TYPES3) {
      AST_NODE_TYPES3["AccessorProperty"] = "AccessorProperty";
      AST_NODE_TYPES3["ArrayExpression"] = "ArrayExpression";
      AST_NODE_TYPES3["ArrayPattern"] = "ArrayPattern";
      AST_NODE_TYPES3["ArrowFunctionExpression"] = "ArrowFunctionExpression";
      AST_NODE_TYPES3["AssignmentExpression"] = "AssignmentExpression";
      AST_NODE_TYPES3["AssignmentPattern"] = "AssignmentPattern";
      AST_NODE_TYPES3["AwaitExpression"] = "AwaitExpression";
      AST_NODE_TYPES3["BinaryExpression"] = "BinaryExpression";
      AST_NODE_TYPES3["BlockStatement"] = "BlockStatement";
      AST_NODE_TYPES3["BreakStatement"] = "BreakStatement";
      AST_NODE_TYPES3["CallExpression"] = "CallExpression";
      AST_NODE_TYPES3["CatchClause"] = "CatchClause";
      AST_NODE_TYPES3["ChainExpression"] = "ChainExpression";
      AST_NODE_TYPES3["ClassBody"] = "ClassBody";
      AST_NODE_TYPES3["ClassDeclaration"] = "ClassDeclaration";
      AST_NODE_TYPES3["ClassExpression"] = "ClassExpression";
      AST_NODE_TYPES3["ConditionalExpression"] = "ConditionalExpression";
      AST_NODE_TYPES3["ContinueStatement"] = "ContinueStatement";
      AST_NODE_TYPES3["DebuggerStatement"] = "DebuggerStatement";
      AST_NODE_TYPES3["Decorator"] = "Decorator";
      AST_NODE_TYPES3["DoWhileStatement"] = "DoWhileStatement";
      AST_NODE_TYPES3["EmptyStatement"] = "EmptyStatement";
      AST_NODE_TYPES3["ExportAllDeclaration"] = "ExportAllDeclaration";
      AST_NODE_TYPES3["ExportDefaultDeclaration"] = "ExportDefaultDeclaration";
      AST_NODE_TYPES3["ExportNamedDeclaration"] = "ExportNamedDeclaration";
      AST_NODE_TYPES3["ExportSpecifier"] = "ExportSpecifier";
      AST_NODE_TYPES3["ExpressionStatement"] = "ExpressionStatement";
      AST_NODE_TYPES3["ForInStatement"] = "ForInStatement";
      AST_NODE_TYPES3["ForOfStatement"] = "ForOfStatement";
      AST_NODE_TYPES3["ForStatement"] = "ForStatement";
      AST_NODE_TYPES3["FunctionDeclaration"] = "FunctionDeclaration";
      AST_NODE_TYPES3["FunctionExpression"] = "FunctionExpression";
      AST_NODE_TYPES3["Identifier"] = "Identifier";
      AST_NODE_TYPES3["IfStatement"] = "IfStatement";
      AST_NODE_TYPES3["ImportAttribute"] = "ImportAttribute";
      AST_NODE_TYPES3["ImportDeclaration"] = "ImportDeclaration";
      AST_NODE_TYPES3["ImportDefaultSpecifier"] = "ImportDefaultSpecifier";
      AST_NODE_TYPES3["ImportExpression"] = "ImportExpression";
      AST_NODE_TYPES3["ImportNamespaceSpecifier"] = "ImportNamespaceSpecifier";
      AST_NODE_TYPES3["ImportSpecifier"] = "ImportSpecifier";
      AST_NODE_TYPES3["JSXAttribute"] = "JSXAttribute";
      AST_NODE_TYPES3["JSXClosingElement"] = "JSXClosingElement";
      AST_NODE_TYPES3["JSXClosingFragment"] = "JSXClosingFragment";
      AST_NODE_TYPES3["JSXElement"] = "JSXElement";
      AST_NODE_TYPES3["JSXEmptyExpression"] = "JSXEmptyExpression";
      AST_NODE_TYPES3["JSXExpressionContainer"] = "JSXExpressionContainer";
      AST_NODE_TYPES3["JSXFragment"] = "JSXFragment";
      AST_NODE_TYPES3["JSXIdentifier"] = "JSXIdentifier";
      AST_NODE_TYPES3["JSXMemberExpression"] = "JSXMemberExpression";
      AST_NODE_TYPES3["JSXNamespacedName"] = "JSXNamespacedName";
      AST_NODE_TYPES3["JSXOpeningElement"] = "JSXOpeningElement";
      AST_NODE_TYPES3["JSXOpeningFragment"] = "JSXOpeningFragment";
      AST_NODE_TYPES3["JSXSpreadAttribute"] = "JSXSpreadAttribute";
      AST_NODE_TYPES3["JSXSpreadChild"] = "JSXSpreadChild";
      AST_NODE_TYPES3["JSXText"] = "JSXText";
      AST_NODE_TYPES3["LabeledStatement"] = "LabeledStatement";
      AST_NODE_TYPES3["Literal"] = "Literal";
      AST_NODE_TYPES3["LogicalExpression"] = "LogicalExpression";
      AST_NODE_TYPES3["MemberExpression"] = "MemberExpression";
      AST_NODE_TYPES3["MetaProperty"] = "MetaProperty";
      AST_NODE_TYPES3["MethodDefinition"] = "MethodDefinition";
      AST_NODE_TYPES3["NewExpression"] = "NewExpression";
      AST_NODE_TYPES3["ObjectExpression"] = "ObjectExpression";
      AST_NODE_TYPES3["ObjectPattern"] = "ObjectPattern";
      AST_NODE_TYPES3["PrivateIdentifier"] = "PrivateIdentifier";
      AST_NODE_TYPES3["Program"] = "Program";
      AST_NODE_TYPES3["Property"] = "Property";
      AST_NODE_TYPES3["PropertyDefinition"] = "PropertyDefinition";
      AST_NODE_TYPES3["RestElement"] = "RestElement";
      AST_NODE_TYPES3["ReturnStatement"] = "ReturnStatement";
      AST_NODE_TYPES3["SequenceExpression"] = "SequenceExpression";
      AST_NODE_TYPES3["SpreadElement"] = "SpreadElement";
      AST_NODE_TYPES3["StaticBlock"] = "StaticBlock";
      AST_NODE_TYPES3["Super"] = "Super";
      AST_NODE_TYPES3["SwitchCase"] = "SwitchCase";
      AST_NODE_TYPES3["SwitchStatement"] = "SwitchStatement";
      AST_NODE_TYPES3["TaggedTemplateExpression"] = "TaggedTemplateExpression";
      AST_NODE_TYPES3["TemplateElement"] = "TemplateElement";
      AST_NODE_TYPES3["TemplateLiteral"] = "TemplateLiteral";
      AST_NODE_TYPES3["ThisExpression"] = "ThisExpression";
      AST_NODE_TYPES3["ThrowStatement"] = "ThrowStatement";
      AST_NODE_TYPES3["TryStatement"] = "TryStatement";
      AST_NODE_TYPES3["UnaryExpression"] = "UnaryExpression";
      AST_NODE_TYPES3["UpdateExpression"] = "UpdateExpression";
      AST_NODE_TYPES3["VariableDeclaration"] = "VariableDeclaration";
      AST_NODE_TYPES3["VariableDeclarator"] = "VariableDeclarator";
      AST_NODE_TYPES3["WhileStatement"] = "WhileStatement";
      AST_NODE_TYPES3["WithStatement"] = "WithStatement";
      AST_NODE_TYPES3["YieldExpression"] = "YieldExpression";
      AST_NODE_TYPES3["TSAbstractAccessorProperty"] = "TSAbstractAccessorProperty";
      AST_NODE_TYPES3["TSAbstractKeyword"] = "TSAbstractKeyword";
      AST_NODE_TYPES3["TSAbstractMethodDefinition"] = "TSAbstractMethodDefinition";
      AST_NODE_TYPES3["TSAbstractPropertyDefinition"] = "TSAbstractPropertyDefinition";
      AST_NODE_TYPES3["TSAnyKeyword"] = "TSAnyKeyword";
      AST_NODE_TYPES3["TSArrayType"] = "TSArrayType";
      AST_NODE_TYPES3["TSAsExpression"] = "TSAsExpression";
      AST_NODE_TYPES3["TSAsyncKeyword"] = "TSAsyncKeyword";
      AST_NODE_TYPES3["TSBigIntKeyword"] = "TSBigIntKeyword";
      AST_NODE_TYPES3["TSBooleanKeyword"] = "TSBooleanKeyword";
      AST_NODE_TYPES3["TSCallSignatureDeclaration"] = "TSCallSignatureDeclaration";
      AST_NODE_TYPES3["TSClassImplements"] = "TSClassImplements";
      AST_NODE_TYPES3["TSConditionalType"] = "TSConditionalType";
      AST_NODE_TYPES3["TSConstructorType"] = "TSConstructorType";
      AST_NODE_TYPES3["TSConstructSignatureDeclaration"] = "TSConstructSignatureDeclaration";
      AST_NODE_TYPES3["TSDeclareFunction"] = "TSDeclareFunction";
      AST_NODE_TYPES3["TSDeclareKeyword"] = "TSDeclareKeyword";
      AST_NODE_TYPES3["TSEmptyBodyFunctionExpression"] = "TSEmptyBodyFunctionExpression";
      AST_NODE_TYPES3["TSEnumBody"] = "TSEnumBody";
      AST_NODE_TYPES3["TSEnumDeclaration"] = "TSEnumDeclaration";
      AST_NODE_TYPES3["TSEnumMember"] = "TSEnumMember";
      AST_NODE_TYPES3["TSExportAssignment"] = "TSExportAssignment";
      AST_NODE_TYPES3["TSExportKeyword"] = "TSExportKeyword";
      AST_NODE_TYPES3["TSExternalModuleReference"] = "TSExternalModuleReference";
      AST_NODE_TYPES3["TSFunctionType"] = "TSFunctionType";
      AST_NODE_TYPES3["TSImportEqualsDeclaration"] = "TSImportEqualsDeclaration";
      AST_NODE_TYPES3["TSImportType"] = "TSImportType";
      AST_NODE_TYPES3["TSIndexedAccessType"] = "TSIndexedAccessType";
      AST_NODE_TYPES3["TSIndexSignature"] = "TSIndexSignature";
      AST_NODE_TYPES3["TSInferType"] = "TSInferType";
      AST_NODE_TYPES3["TSInstantiationExpression"] = "TSInstantiationExpression";
      AST_NODE_TYPES3["TSInterfaceBody"] = "TSInterfaceBody";
      AST_NODE_TYPES3["TSInterfaceDeclaration"] = "TSInterfaceDeclaration";
      AST_NODE_TYPES3["TSInterfaceHeritage"] = "TSInterfaceHeritage";
      AST_NODE_TYPES3["TSIntersectionType"] = "TSIntersectionType";
      AST_NODE_TYPES3["TSIntrinsicKeyword"] = "TSIntrinsicKeyword";
      AST_NODE_TYPES3["TSLiteralType"] = "TSLiteralType";
      AST_NODE_TYPES3["TSMappedType"] = "TSMappedType";
      AST_NODE_TYPES3["TSMethodSignature"] = "TSMethodSignature";
      AST_NODE_TYPES3["TSModuleBlock"] = "TSModuleBlock";
      AST_NODE_TYPES3["TSModuleDeclaration"] = "TSModuleDeclaration";
      AST_NODE_TYPES3["TSNamedTupleMember"] = "TSNamedTupleMember";
      AST_NODE_TYPES3["TSNamespaceExportDeclaration"] = "TSNamespaceExportDeclaration";
      AST_NODE_TYPES3["TSNeverKeyword"] = "TSNeverKeyword";
      AST_NODE_TYPES3["TSNonNullExpression"] = "TSNonNullExpression";
      AST_NODE_TYPES3["TSNullKeyword"] = "TSNullKeyword";
      AST_NODE_TYPES3["TSNumberKeyword"] = "TSNumberKeyword";
      AST_NODE_TYPES3["TSObjectKeyword"] = "TSObjectKeyword";
      AST_NODE_TYPES3["TSOptionalType"] = "TSOptionalType";
      AST_NODE_TYPES3["TSParameterProperty"] = "TSParameterProperty";
      AST_NODE_TYPES3["TSPrivateKeyword"] = "TSPrivateKeyword";
      AST_NODE_TYPES3["TSPropertySignature"] = "TSPropertySignature";
      AST_NODE_TYPES3["TSProtectedKeyword"] = "TSProtectedKeyword";
      AST_NODE_TYPES3["TSPublicKeyword"] = "TSPublicKeyword";
      AST_NODE_TYPES3["TSQualifiedName"] = "TSQualifiedName";
      AST_NODE_TYPES3["TSReadonlyKeyword"] = "TSReadonlyKeyword";
      AST_NODE_TYPES3["TSRestType"] = "TSRestType";
      AST_NODE_TYPES3["TSSatisfiesExpression"] = "TSSatisfiesExpression";
      AST_NODE_TYPES3["TSStaticKeyword"] = "TSStaticKeyword";
      AST_NODE_TYPES3["TSStringKeyword"] = "TSStringKeyword";
      AST_NODE_TYPES3["TSSymbolKeyword"] = "TSSymbolKeyword";
      AST_NODE_TYPES3["TSTemplateLiteralType"] = "TSTemplateLiteralType";
      AST_NODE_TYPES3["TSThisType"] = "TSThisType";
      AST_NODE_TYPES3["TSTupleType"] = "TSTupleType";
      AST_NODE_TYPES3["TSTypeAliasDeclaration"] = "TSTypeAliasDeclaration";
      AST_NODE_TYPES3["TSTypeAnnotation"] = "TSTypeAnnotation";
      AST_NODE_TYPES3["TSTypeAssertion"] = "TSTypeAssertion";
      AST_NODE_TYPES3["TSTypeLiteral"] = "TSTypeLiteral";
      AST_NODE_TYPES3["TSTypeOperator"] = "TSTypeOperator";
      AST_NODE_TYPES3["TSTypeParameter"] = "TSTypeParameter";
      AST_NODE_TYPES3["TSTypeParameterDeclaration"] = "TSTypeParameterDeclaration";
      AST_NODE_TYPES3["TSTypeParameterInstantiation"] = "TSTypeParameterInstantiation";
      AST_NODE_TYPES3["TSTypePredicate"] = "TSTypePredicate";
      AST_NODE_TYPES3["TSTypeQuery"] = "TSTypeQuery";
      AST_NODE_TYPES3["TSTypeReference"] = "TSTypeReference";
      AST_NODE_TYPES3["TSUndefinedKeyword"] = "TSUndefinedKeyword";
      AST_NODE_TYPES3["TSUnionType"] = "TSUnionType";
      AST_NODE_TYPES3["TSUnknownKeyword"] = "TSUnknownKeyword";
      AST_NODE_TYPES3["TSVoidKeyword"] = "TSVoidKeyword";
    })(AST_NODE_TYPES2 || (exports2.AST_NODE_TYPES = AST_NODE_TYPES2 = {}));
    var AST_TOKEN_TYPES2;
    (function(AST_TOKEN_TYPES3) {
      AST_TOKEN_TYPES3["Boolean"] = "Boolean";
      AST_TOKEN_TYPES3["Identifier"] = "Identifier";
      AST_TOKEN_TYPES3["JSXIdentifier"] = "JSXIdentifier";
      AST_TOKEN_TYPES3["PrivateIdentifier"] = "PrivateIdentifier";
      AST_TOKEN_TYPES3["JSXText"] = "JSXText";
      AST_TOKEN_TYPES3["Keyword"] = "Keyword";
      AST_TOKEN_TYPES3["Null"] = "Null";
      AST_TOKEN_TYPES3["Numeric"] = "Numeric";
      AST_TOKEN_TYPES3["Punctuator"] = "Punctuator";
      AST_TOKEN_TYPES3["RegularExpression"] = "RegularExpression";
      AST_TOKEN_TYPES3["String"] = "String";
      AST_TOKEN_TYPES3["Template"] = "Template";
      AST_TOKEN_TYPES3["Block"] = "Block";
      AST_TOKEN_TYPES3["Line"] = "Line";
    })(AST_TOKEN_TYPES2 || (exports2.AST_TOKEN_TYPES = AST_TOKEN_TYPES2 = {}));
  }
});

// node_modules/@typescript-eslint/types/dist/lib.js
var require_lib = __commonJS({
  "node_modules/@typescript-eslint/types/dist/lib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@typescript-eslint/types/dist/parser-options.js
var require_parser_options = __commonJS({
  "node_modules/@typescript-eslint/types/dist/parser-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@typescript-eslint/types/dist/ts-estree.js
var require_ts_estree2 = __commonJS({
  "node_modules/@typescript-eslint/types/dist/ts-estree.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSESTree = void 0;
    exports2.TSESTree = __importStar(require_ast_spec());
  }
});

// node_modules/@typescript-eslint/types/dist/index.js
var require_dist = __commonJS({
  "node_modules/@typescript-eslint/types/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST_TOKEN_TYPES = exports2.AST_NODE_TYPES = void 0;
    var ast_spec_1 = require_ast_spec();
    Object.defineProperty(exports2, "AST_NODE_TYPES", { enumerable: true, get: function() {
      return ast_spec_1.AST_NODE_TYPES;
    } });
    Object.defineProperty(exports2, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
      return ast_spec_1.AST_TOKEN_TYPES;
    } });
    __exportStar(require_lib(), exports2);
    __exportStar(require_parser_options(), exports2);
    __exportStar(require_ts_estree2(), exports2);
  }
});

// node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "node_modules/acorn-jsx/xhtml.js"(exports2, module2) {
    module2.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports2, module2) {
    (function(global, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.acorn = {}));
    })(exports2, (function(exports3) {
      "use strict";
      var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords2 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$12 = {
        5: ecma5AndLessKeywords2,
        "5module": ecma5AndLessKeywords2 + " export import",
        6: ecma5AndLessKeywords2 + " const class extends export import super"
      };
      var keywordRelationalOperator2 = /^in(stanceof)?$/;
      var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
      var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
      function isInAstralSet2(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart2(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code, astralIdentifierStartCodes2);
      }
      function isIdentifierChar2(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code, astralIdentifierStartCodes2) || isInAstralSet2(code, astralIdentifierCodes2);
      }
      var TokenType3 = function TokenType4(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop2(name, prec) {
        return new TokenType3(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
      var keywords2 = {};
      function kw2(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords2[name] = new TokenType3(name, options);
      }
      var types$12 = {
        num: new TokenType3("num", startsExpr2),
        regexp: new TokenType3("regexp", startsExpr2),
        string: new TokenType3("string", startsExpr2),
        name: new TokenType3("name", startsExpr2),
        privateId: new TokenType3("privateId", startsExpr2),
        eof: new TokenType3("eof"),
        // Punctuation token types.
        bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType3("]"),
        braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType3("}"),
        parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType3(")"),
        comma: new TokenType3(",", beforeExpr2),
        semi: new TokenType3(";", beforeExpr2),
        colon: new TokenType3(":", beforeExpr2),
        dot: new TokenType3("."),
        question: new TokenType3("?", beforeExpr2),
        questionDot: new TokenType3("?."),
        arrow: new TokenType3("=>", beforeExpr2),
        template: new TokenType3("template"),
        invalidTemplate: new TokenType3("invalidTemplate"),
        ellipsis: new TokenType3("...", beforeExpr2),
        backQuote: new TokenType3("`", startsExpr2),
        dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop2("||", 1),
        logicalAND: binop2("&&", 2),
        bitwiseOR: binop2("|", 3),
        bitwiseXOR: binop2("^", 4),
        bitwiseAND: binop2("&", 5),
        equality: binop2("==/!=/===/!==", 6),
        relational: binop2("</>/<=/>=", 7),
        bitShift: binop2("<</>>/>>>", 8),
        plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop2("%", 10),
        star: binop2("*", 10),
        slash: binop2("/", 10),
        starstar: new TokenType3("**", { beforeExpr: true }),
        coalesce: binop2("??", 1),
        // Keyword token types.
        _break: kw2("break"),
        _case: kw2("case", beforeExpr2),
        _catch: kw2("catch"),
        _continue: kw2("continue"),
        _debugger: kw2("debugger"),
        _default: kw2("default", beforeExpr2),
        _do: kw2("do", { isLoop: true, beforeExpr: true }),
        _else: kw2("else", beforeExpr2),
        _finally: kw2("finally"),
        _for: kw2("for", { isLoop: true }),
        _function: kw2("function", startsExpr2),
        _if: kw2("if"),
        _return: kw2("return", beforeExpr2),
        _switch: kw2("switch"),
        _throw: kw2("throw", beforeExpr2),
        _try: kw2("try"),
        _var: kw2("var"),
        _const: kw2("const"),
        _while: kw2("while", { isLoop: true }),
        _with: kw2("with"),
        _new: kw2("new", { beforeExpr: true, startsExpr: true }),
        _this: kw2("this", startsExpr2),
        _super: kw2("super", startsExpr2),
        _class: kw2("class", startsExpr2),
        _extends: kw2("extends", beforeExpr2),
        _export: kw2("export"),
        _import: kw2("import", startsExpr2),
        _null: kw2("null", startsExpr2),
        _true: kw2("true", startsExpr2),
        _false: kw2("false", startsExpr2),
        _in: kw2("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG2 = new RegExp(lineBreak2.source, "g");
      function isNewLine2(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak2(code, from, end) {
        if (end === void 0) end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine2(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref2 = Object.prototype;
      var hasOwnProperty2 = ref2.hasOwnProperty;
      var toString2 = ref2.toString;
      var hasOwn2 = Object.hasOwn || (function(obj, propName) {
        return hasOwnProperty2.call(obj, propName);
      });
      var isArray2 = Array.isArray || (function(obj) {
        return toString2.call(obj) === "[object Array]";
      });
      var regexpCache2 = /* @__PURE__ */ Object.create(null);
      function wordsRegexp2(words) {
        return regexpCache2[words] || (regexpCache2[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString2(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position3 = function Position4(line, col) {
        this.line = line;
        this.column = col;
      };
      Position3.prototype.offset = function offset2(n) {
        return new Position3(this.line, this.column + n);
      };
      var SourceLocation3 = function SourceLocation4(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo2(input, offset2) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak2(input, cur, offset2);
          if (nextBreak < 0) {
            return new Position3(line, offset2 - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions2 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion2 = false;
      function getOptions2(opts) {
        var options = {};
        for (var opt in defaultOptions2) {
          options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion2 = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray2(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray2(options.onComment)) {
          options.onComment = pushComment2(options, options.onComment);
        }
        return options;
      }
      function pushComment2(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation3(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_CLASS_FIELD_INIT2 = 512, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
      function functionFlags2(async, generator) {
        return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
      }
      var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
      var Parser3 = function Parser4(options, input, startPos) {
        this.options = options = getOptions2(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp2(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
        this.reservedWordsStrict = wordsRegexp2(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$12.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP2);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser3.prototype.parse = function parse4() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors2.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
      };
      prototypeAccessors2.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0;
      };
      prototypeAccessors2.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0;
      };
      prototypeAccessors2.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref3 = this.scopeStack[i2];
          var flags = ref3.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_CLASS_FIELD_INIT2)) {
            return false;
          }
          if (flags & SCOPE_FUNCTION2) {
            return (flags & SCOPE_ASYNC2) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors2.allowSuper.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        return (flags & SCOPE_SUPER2) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors2.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
      };
      prototypeAccessors2.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors2.allowNewDotTarget.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref3 = this.scopeStack[i2];
          var flags = ref3.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_CLASS_FIELD_INIT2) || flags & SCOPE_FUNCTION2 && !(flags & SCOPE_ARROW2)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors2.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
      };
      Parser3.extend = function extend2() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser3.parse = function parse4(input, options) {
        return new this(options, input).parse();
      };
      Parser3.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser3.tokenizer = function tokenizer3(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser3.prototype, prototypeAccessors2);
      var pp$92 = Parser3.prototype;
      var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$92.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace2.lastIndex = start;
          start += skipWhiteSpace2.exec(this.input)[0].length;
          var match = literal2.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace2.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace2.lastIndex = start;
          start += skipWhiteSpace2.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$92.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$92.isContextual = function(name) {
        return this.type === types$12.name && this.value === name && !this.containsEsc;
      };
      pp$92.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$92.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$92.canInsertSemicolon = function() {
        return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$92.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$92.semicolon = function() {
        if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$92.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$92.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$92.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors3 = function DestructuringErrors4() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$92.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$92.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$82 = Parser3.prototype;
      pp$82.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$12.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
      pp$82.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart2(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator2.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$82.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$82.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak2.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var awaitEndPos = next + 5, after;
          if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar2(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
            return false;
          }
          skipWhiteSpace2.lastIndex = awaitEndPos;
          var skipAfterUsing = skipWhiteSpace2.exec(this.input);
          if (skipAfterUsing && lineBreak2.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
            return false;
          }
        }
        if (isFor) {
          var ofEndPos = next + 2, after$1;
          if (this.input.slice(next, ofEndPos) === "of") {
            if (ofEndPos === this.input.length || !isIdentifierChar2(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
              return false;
            }
          }
        }
        var ch = this.input.charCodeAt(next);
        return isIdentifierStart2(ch, true) || ch === 92;
      };
      pp$82.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$82.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$82.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$12._var;
          kind = "let";
        }
        switch (starttype) {
          case types$12._break:
          case types$12._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$12._debugger:
            return this.parseDebuggerStatement(node);
          case types$12._do:
            return this.parseDoStatement(node);
          case types$12._for:
            return this.parseForStatement(node);
          case types$12._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$12._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$12._if:
            return this.parseIfStatement(node);
          case types$12._return:
            return this.parseReturnStatement(node);
          case types$12._switch:
            return this.parseSwitchStatement(node);
          case types$12._throw:
            return this.parseThrowStatement(node);
          case types$12._try:
            return this.parseTryStatement(node);
          case types$12._const:
          case types$12._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$12._while:
            return this.parseWhileStatement(node);
          case types$12._with:
            return this.parseWithStatement(node);
          case types$12.braceL:
            return this.parseBlock(true, node);
          case types$12.semi:
            return this.parseEmptyStatement(node);
          case types$12._export:
          case types$12._import:
            if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
              skipWhiteSpace2.lastIndex = this.pos;
              var skip = skipWhiteSpace2.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$12._import ? this.parseImport(node) : this.parseExport(node, exports4);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (topLevel && this.options.sourceType === "script") {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node, false, usingKind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$82.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$12.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$82.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$82.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel2);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$12._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$12.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$82.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel2);
        this.enterScope(0);
        this.expect(types$12.parenL);
        if (this.type === types$12.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$12._var || this.type === types$12._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors3();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$12._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$82.parseForAfterInit = function(node, init, awaitAt) {
        if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$12._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$82.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
      };
      pp$82.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$82.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$82.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$12.braceL);
        this.labels.push(switchLabel2);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$12.braceR; ) {
          if (this.type === types$12._case || this.type === types$12._default) {
            var isCase = this.type === types$12._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$12.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$82.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$12 = [];
      pp$82.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
        this.expect(types$12.parenR);
        return param;
      };
      pp$82.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$12._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$12.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$82.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$82.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel2);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$82.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$82.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$82.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$82.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$82.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$12.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$82.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$12.semi);
        node.test = this.type === types$12.semi ? null : this.parseExpression();
        this.expect(types$12.semi);
        node.update = this.type === types$12.parenR ? null : this.parseExpression();
        this.expect(types$12.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$82.parseForIn = function(node, init) {
        var isForIn = this.type === types$12._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$12.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$82.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$12.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$12._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$12.comma)) {
            break;
          }
        }
        return node;
      };
      pp$82.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
      };
      var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
      pp$82.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node.generator = this.eat(types$12.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT2)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node.id = this.type === types$12.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$82.parseFunctionParams = function(node) {
        this.expect(types$12.parenL);
        node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$82.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$12.braceL);
        while (this.type !== types$12.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$82.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$12.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$12.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName2(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$82.isClassElementNameStart = function() {
        return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
      };
      pp$82.parseClassElementName = function(element) {
        if (this.type === types$12.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName2(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$82.parseClassField = function(field) {
        if (checkKeyName2(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName2(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$12.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT2 | SCOPE_SUPER2);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$82.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$82.parseClassId = function(node, isStatement) {
        if (this.type === types$12.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL2, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$82.parseClassSuper = function(node) {
        node.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$82.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$82.exitClassBody = function() {
        var ref3 = this.privateNameStack.pop();
        var declared = ref3.declared;
        var used = ref3.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn2(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted2(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName2(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$82.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$82.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$12.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$12._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$12.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
              node.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$82.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$82.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
        } else if (this.type === types$12._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$82.checkExport = function(exports4, name, pos) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn2(exports4, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$82.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        }
      };
      pp$82.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$82.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$82.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports4,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$82.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$82.parseImport = function(node) {
        this.next();
        if (this.type === types$12.string) {
          node.specifiers = empty$12;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$82.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL2);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$82.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL2);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$82.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL2);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$82.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$12.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$12.comma)) {
            return nodes;
          }
        }
        if (this.type === types$12.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$82.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$12._with)) {
          return nodes;
        }
        this.expect(types$12.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn2(attributeKeys, keyName)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$82.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$12.colon);
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$82.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate2.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$82.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$82.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$72 = Parser3.prototype;
      pp$72.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$72.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$72.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$72.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$72.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$12.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$12.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$12.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$72.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$12.comma);
          }
          if (allowEmpty && this.type === types$12.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$12.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$72.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$72.parseBindingListItem = function(param) {
        return param;
      };
      pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        var isBind = bindingType !== BIND_NONE2;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn2(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE2) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types2 = {
        b_stat: new TokContext3("{", false),
        b_expr: new TokContext3("{", true),
        b_tmpl: new TokContext3("${", false),
        p_stat: new TokContext3("(", false),
        p_expr: new TokContext3("(", true),
        q_tmpl: new TokContext3("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext3("function", false),
        f_expr: new TokContext3("function", true),
        f_expr_gen: new TokContext3("function", true, false, null, true),
        f_gen: new TokContext3("function", false, false, null, true)
      };
      var pp$62 = Parser3.prototype;
      pp$62.initialContext = function() {
        return [types2.b_stat];
      };
      pp$62.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$62.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types2.f_expr || parent === types2.f_stat) {
          return true;
        }
        if (prevType === types$12.colon && (parent === types2.b_stat || parent === types2.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
          return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
          return true;
        }
        if (prevType === types$12.braceL) {
          return parent === types2.b_stat;
        }
        if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$62.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$62.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$12.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$62.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types2.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$12.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr);
        this.exprAllowed = true;
      };
      types$12.dollarBraceL.updateContext = function() {
        this.context.push(types2.b_tmpl);
        this.exprAllowed = true;
      };
      types$12.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
        this.context.push(statementParens ? types2.p_stat : types2.p_expr);
        this.exprAllowed = true;
      };
      types$12.incDec.updateContext = function() {
      };
      types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types2.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types2.b_stat)) {
          this.context.push(types2.f_expr);
        } else {
          this.context.push(types2.f_stat);
        }
        this.exprAllowed = false;
      };
      types$12.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$12.backQuote.updateContext = function() {
        if (this.curContext() === types2.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types2.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$12.star.updateContext = function(prevType) {
        if (prevType === types$12._function) {
          var index2 = this.context.length - 1;
          if (this.context[index2] === types2.f_expr) {
            this.context[index2] = types2.f_expr_gen;
          } else {
            this.context[index2] = types2.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$12.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$52 = Parser3.prototype;
      pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$52.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$12.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$12.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$12.parenL || this.type === types$12.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$12.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$12.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$12.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$12.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$12._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
            var coalesce = this.type === types$12.coalesce;
            if (coalesce) {
              prec = types$12.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$12.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess2(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess2(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$12.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$12._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$12.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess2(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess2(node.expression);
      }
      function isPrivateFieldAccess2(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess2(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess2(node.expression);
      }
      pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$52.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$52.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$12.arrow);
      };
      pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$52.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$12.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$12.bracketL);
        if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$12.bracketR);
          } else if (this.type === types$12.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$12.parenL)) {
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$12.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$12.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$12._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$12.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$12._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$12.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
              this.overrideContext(types2.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$12.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$12.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;
          case types$12.num:
          case types$12.string:
            return this.parseLiteral(this.value);
          case types$12._null:
          case types$12._true:
          case types$12._false:
            node = this.startNode();
            node.value = this.type === types$12._null ? null : this.type === types$12._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$12.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$12.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$12.braceL:
            this.overrideContext(types2.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$12._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$12._class:
            return this.parseClass(this.startNode(), false);
          case types$12._new:
            return this.parseNew();
          case types$12.backQuote:
            return this.parseTemplate();
          case types$12._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$52.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$52.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$12.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$12.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$52.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$12.parenR)) {
            this.expect(types$12.comma);
            if (!this.afterTrailingComma(types$12.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$12.parenR)) {
                this.expect(types$12.comma);
                if (!this.afterTrailingComma(types$12.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$12.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$52.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$52.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$52.parseParenExpression = function() {
        this.expect(types$12.parenL);
        var val = this.parseExpression();
        this.expect(types$12.parenR);
        return val;
      };
      pp$52.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$12.parenR) {
            first ? first = false : this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$12.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$12.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$12.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$52.parseParenItem = function(item) {
        return item;
      };
      pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty2 = [];
      pp$52.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$12.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$12.parenL)) {
          node.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty2;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$52.parseTemplateElement = function(ref3) {
        var isTagged = ref3.isTagged;
        var elem = this.startNode();
        if (this.type === types$12.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$12.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$52.parseTemplate = function(ref3) {
        if (ref3 === void 0) ref3 = {};
        var isTagged = ref3.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$12.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$12.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$12.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$52.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$52.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$12.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$52.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$12.colon) {
          this.unexpected();
        }
        if (this.eat(types$12.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$12.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$52.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$12.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$12.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$52.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(isAsync, node.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
        this.expect(types$12.parenL);
        node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$52.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$52.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression2 = isArrowFunction && this.type !== types$12.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression2) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE2);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$52.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$52.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
        }
      };
      pp$52.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$12.comma) {
            elt = null;
          } else if (this.type === types$12.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$52.checkUnreserved = function(ref3) {
        var start = ref3.start;
        var end = ref3.end;
        var name = ref3.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR2) && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$52.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$52.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$12.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$12.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$52.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$12.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$52.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$12.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$52.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$42 = Parser3.prototype;
      pp$42.raise = function(pos, message) {
        var loc = getLineInfo2(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$42.raiseRecoverable = pp$42.raise;
      pp$42.curPosition = function() {
        if (this.options.locations) {
          return new Position3(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$32 = Parser3.prototype;
      var Scope3 = function Scope4(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$32.enterScope = function(flags) {
        this.scopeStack.push(new Scope3(flags));
      };
      pp$32.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$32.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
      };
      pp$32.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL2) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH2) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION2) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP2) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR2) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$32.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$32.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$32.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR2 | SCOPE_CLASS_FIELD_INIT2 | SCOPE_CLASS_STATIC_BLOCK2)) {
            return scope;
          }
        }
      };
      pp$32.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR2 | SCOPE_CLASS_FIELD_INIT2 | SCOPE_CLASS_STATIC_BLOCK2) && !(scope.flags & SCOPE_ARROW2)) {
            return scope;
          }
        }
      };
      var Node3 = function Node4(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation3(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$22 = Parser3.prototype;
      pp$22.startNode = function() {
        return new Node3(this, this.start, this.startLoc);
      };
      pp$22.startNodeAt = function(pos, loc) {
        return new Node3(this, pos, loc);
      };
      function finishNodeAt2(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$22.finishNode = function(node, type) {
        return finishNodeAt2.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$22.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt2.call(this, node, type, pos, loc);
      };
      pp$22.copyNode = function(node) {
        var newNode = new Node3(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode2 = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
      var ecma11BinaryProperties2 = ecma10BinaryProperties2;
      var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties2 = ecma12BinaryProperties2;
      var ecma14BinaryProperties2 = ecma13BinaryProperties2;
      var unicodeBinaryProperties2 = {
        9: ecma9BinaryProperties2,
        10: ecma10BinaryProperties2,
        11: ecma11BinaryProperties2,
        12: ecma12BinaryProperties2,
        13: ecma13BinaryProperties2,
        14: ecma14BinaryProperties2
      };
      var ecma14BinaryPropertiesOfStrings2 = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings2 = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings2
      };
      var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues2 = ecma13ScriptValues2 + " " + scriptValuesAddedInUnicode2;
      var unicodeScriptValues2 = {
        9: ecma9ScriptValues2,
        10: ecma10ScriptValues2,
        11: ecma11ScriptValues2,
        12: ecma12ScriptValues2,
        13: ecma13ScriptValues2,
        14: ecma14ScriptValues2
      };
      var data2 = {};
      function buildUnicodeData2(ecmaVersion2) {
        var d = data2[ecmaVersion2] = {
          binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
          binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
            Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData2(ecmaVersion);
      }
      var pp$12 = Parser3.prototype;
      var BranchID3 = function BranchID4(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID3.prototype.separatedFrom = function separatedFrom2(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID3.prototype.sibling = function sibling2() {
        return new BranchID3(this.parent, this.base);
      };
      var RegExpValidationState3 = function RegExpValidationState4(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState3.prototype.reset = function reset2(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState3.prototype.raise = function raise2(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState3.prototype.at = function at2(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState3.prototype.nextIndex = function nextIndex2(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState3.prototype.current = function current2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState3.prototype.advance = function advance2(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState3.prototype.eatChars = function eatChars2(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current2 = this.at(pos, forceU);
          if (current2 === -1 || current2 !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$12.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp2(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$12.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp2(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$12.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (!state.groupNames[name]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$12.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID3(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$12.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$12.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$12.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$12.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$12.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$12.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier2(ch)) {
          modifiers += codePointToString2(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier2(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$12.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$12.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter2(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter2(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$12.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$12.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString2(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString2(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart2(ch) {
        return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
      }
      pp$12.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart2(ch) {
        return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$12.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$12.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$12.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$12.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter2(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter2(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode2(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode2(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$12.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone2 = 0;
      var CharSetOk2 = 1;
      var CharSetString2 = 2;
      pp$12.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape2(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk2;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString2) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone2;
      };
      function isCharacterClassEscape2(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return CharSetOk2;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone2;
      };
      pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn2(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk2;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString2;
        }
        state.raise("Invalid property name");
      };
      pp$12.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter2(ch) {
        return isControlLetter2(ch) || ch === 95;
      }
      pp$12.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter2(ch) {
        return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
      }
      pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$12.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString2) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk2;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk2;
      };
      pp$12.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$12.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit2(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$12.regexp_classSetExpression = function(state) {
        var result = CharSetOk2, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString2) {
                result = CharSetOk2;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString2) {
            result = CharSetString2;
          }
        }
      };
      pp$12.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk2;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$12.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString2) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$12.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$12.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString2) {
            result = CharSetString2;
          }
        }
        return result;
      };
      pp$12.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk2 : CharSetString2;
      };
      pp$12.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter2(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter2(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter2(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter2(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator2(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator2(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$12.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit2(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$12.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit2(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit2(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$12.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit2(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit2(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt2(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit2(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit2(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$12.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit2(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return true;
      };
      var Token4 = function Token5(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp2 = Parser3.prototype;
      pp2.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token4(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp2.getToken = function() {
        this.next();
        return new Token4(this);
      };
      if (typeof Symbol !== "undefined") {
        pp2[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$12.eof,
                value: token
              };
            }
          };
        };
      }
      pp2.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$12.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp2.readToken = function(code) {
        if (isIdentifierStart2(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp2.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp2.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp2.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp2.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$12.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$12.dot);
        }
      };
      pp2.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.slash, 1);
      };
      pp2.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$12.star : types$12.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$12.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp2.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(code === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
      };
      pp2.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.bitwiseXOR, 1);
      };
      pp2.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$12.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.plusMin, 1);
      };
      pp2.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$12.assign, size + 1);
          }
          return this.finishOp(types$12.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$12.relational, size);
      };
      pp2.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$12.arrow);
        }
        return this.finishOp(code === 61 ? types$12.eq : types$12.prefix, 1);
      };
      pp2.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$12.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$12.assign, 3);
              }
            }
            return this.finishOp(types$12.coalesce, 2);
          }
        }
        return this.finishOp(types$12.question, 1);
      };
      pp2.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart2(code, true) || code === 92) {
            return this.finishToken(types$12.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
      };
      pp2.getTokenFromCode = function(code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            ++this.pos;
            return this.finishToken(types$12.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$12.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$12.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$12.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$12.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$12.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$12.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$12.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$12.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$12.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$12.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
      };
      pp2.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp2.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak2.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$12.regexp, { pattern, flags, value });
      };
      pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber2(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt2(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp2.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt2(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val);
      };
      pp2.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt2(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$12.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber2(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$12.num, val);
      };
      pp2.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp2.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine2(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$12.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
      pp2.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp2.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR2;
        } else {
          this.raise(position, message);
        }
      };
      pp2.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$12.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$12.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$12.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine2(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp2.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            // fall through
            case "`":
              return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            // fall through
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp2.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString2(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          // '\r\n'
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine2(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp2.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp2.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar2(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString2(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp2.readWord = function() {
        var word = this.readWord1();
        var type = types$12.name;
        if (this.keywords.test(word)) {
          type = keywords2[word];
        }
        return this.finishToken(type, word);
      };
      var version2 = "8.15.0";
      Parser3.acorn = {
        Parser: Parser3,
        version: version2,
        defaultOptions: defaultOptions2,
        Position: Position3,
        SourceLocation: SourceLocation3,
        getLineInfo: getLineInfo2,
        Node: Node3,
        TokenType: TokenType3,
        tokTypes: types$12,
        keywordTypes: keywords2,
        TokContext: TokContext3,
        tokContexts: types2,
        isIdentifierChar: isIdentifierChar2,
        isIdentifierStart: isIdentifierStart2,
        Token: Token4,
        isNewLine: isNewLine2,
        lineBreak: lineBreak2,
        lineBreakG: lineBreakG2,
        nonASCIIwhitespace: nonASCIIwhitespace2
      };
      function parse3(input, options) {
        return Parser3.parse(input, options);
      }
      function parseExpressionAt2(input, pos, options) {
        return Parser3.parseExpressionAt(input, pos, options);
      }
      function tokenizer2(input, options) {
        return Parser3.tokenizer(input, options);
      }
      exports3.Node = Node3;
      exports3.Parser = Parser3;
      exports3.Position = Position3;
      exports3.SourceLocation = SourceLocation3;
      exports3.TokContext = TokContext3;
      exports3.Token = Token4;
      exports3.TokenType = TokenType3;
      exports3.defaultOptions = defaultOptions2;
      exports3.getLineInfo = getLineInfo2;
      exports3.isIdentifierChar = isIdentifierChar2;
      exports3.isIdentifierStart = isIdentifierStart2;
      exports3.isNewLine = isNewLine2;
      exports3.keywordTypes = keywords2;
      exports3.lineBreak = lineBreak2;
      exports3.lineBreakG = lineBreakG2;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace2;
      exports3.parse = parse3;
      exports3.parseExpressionAt = parseExpressionAt2;
      exports3.tokContexts = types2;
      exports3.tokTypes = types$12;
      exports3.tokenizer = tokenizer2;
      exports3.version = version2;
    }));
  }
});

// node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "node_modules/acorn-jsx/index.js"(exports2, module2) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx = acornJsxMap.get(acorn);
      if (!acornJsx) {
        const tt = acorn.tokTypes;
        const TokContext3 = acorn.TokContext;
        const TokenType3 = acorn.TokenType;
        const tc_oTag = new TokContext3("<tag", false);
        const tc_cTag = new TokContext3("</tag", false);
        const tc_expr = new TokContext3("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType3("jsxName"),
          jsxText: new TokenType3("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType3("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx);
      }
      return acornJsx;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module2.exports = function(options) {
      options = options || {};
      return function(Parser3) {
        return plugin({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser3);
      };
    };
    Object.defineProperty(module2.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin(options, Parser3) {
      const acorn = Parser3.acorn || require_acorn();
      const acornJsx = getJsxTokens(acorn);
      const tt = acorn.tokTypes;
      const tok = acornJsx.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx.tokContexts.tc_oTag;
      const tc_cTag = acornJsx.tokContexts.tc_cTag;
      const tc_expr = acornJsx.tokContexts.tc_expr;
      const isNewLine2 = acorn.isNewLine;
      const isIdentifierStart2 = acorn.isIdentifierStart;
      const isIdentifierChar2 = acorn.isIdentifierChar;
      return class extends Parser3 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              // '<'
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              // '>'
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine2(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str = "", count = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar2(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node = this.startNode();
          if (this.type === tok.jsxName)
            node.name = this.value;
          else if (this.type.keyword)
            node.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsx_parseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsx_parseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node = this.jsx_parseExpressionContainer();
              if (node.expression.type === "JSXEmptyExpression")
                this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
              return node;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node = this.startNode();
          this.next();
          node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsx_parseNamespacedName();
          node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          node.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node.name = nodeName;
          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
            node.attributes.push(this.jsx_parseAttribute());
          node.selfClosing = this.eat(tt.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node["opening" + fragmentOrElement] = openingElement;
          node["closing" + fragmentOrElement] = closingElement;
          node.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node = this.parseLiteral(this.value);
          node.type = "JSXText";
          return node;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart2(code)) return this.jsx_readWord();
            if (code == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context == tc_oTag)
              return this.jsx_readString(code);
          }
          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
            else super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "node_modules/estraverse/estraverse.js"(exports2) {
    (function clone(exports3) {
      "use strict";
      var Syntax2, VisitorOption, VisitorKeys2, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current2;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current2 = i + diff;
          if (func(array[current2])) {
            len = diff;
          } else {
            i = current2 + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax2 = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys2 = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref2) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref2;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current2() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys2;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax2.ObjectExpression || nodeType === Syntax2.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse3(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current2, current22, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current2 = candidates.length;
            while ((current2 -= 1) >= 0) {
              key = candidates[current2];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current22 = candidate.length;
                while ((current22 -= 1) >= 0) {
                  if (!candidate[current22]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current22])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current2])) {
                    element = new Element(candidate[current22], [key, current22], "Property", null);
                  } else if (isNode(candidate[current22])) {
                    element = new Element(candidate[current22], [key, current22], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current2, current22, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current2 = candidates.length;
          while ((current2 -= 1) >= 0) {
            key = candidates[current2];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current22 = candidate.length;
              while ((current22 -= 1) >= 0) {
                if (!candidate[current22]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current2])) {
                  element = new Element(candidate[current22], [key, current22], "Property", new Reference(candidate, current22));
                } else if (isNode(candidate[current22])) {
                  element = new Element(candidate[current22], [key, current22], null, new Reference(candidate, current22));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse2(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse2(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse2(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports3.Syntax = Syntax2;
      exports3.traverse = traverse2;
      exports3.replace = replace;
      exports3.attachComments = attachComments;
      exports3.VisitorKeys = VisitorKeys2;
      exports3.VisitorOption = VisitorOption;
      exports3.Controller = Controller;
      exports3.cloneEnvironment = function() {
        return clone({});
      };
      return exports3;
    })(exports2);
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        __proto__: null,
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports2.basename = (path, { windows } = {}) => {
      const segs = path.split(windows ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek = () => str.charCodeAt(index2 + 1);
      const advance2 = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance2();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance2();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance2()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index2);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance2())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance2();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance2())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance2())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance2();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance2 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance2();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance2(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index2) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance2();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance2();
          } else {
            value += advance2();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance2();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance2());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse3 = require_parse();
    var utils = require_utils();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = opts.windows;
      const regex = isState ? picomatch2.compileRe(glob, options) : picomatch2.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch2.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch2.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch2.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch2.matchBase = (input, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch2.makeRe(glob, options);
      return regex.test(utils.basename(input));
    };
    picomatch2.isMatch = (str, patterns, options) => picomatch2(patterns, options)(str);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch2.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan(input, options);
    picomatch2.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants;
    module2.exports = picomatch2;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    var pico = require_picomatch();
    var utils = require_utils();
    function picomatch2(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch2, pico);
    module2.exports = picomatch2;
  }
});

// puente.js
var puente_exports = {};
__export(puente_exports, {
  default: () => index,
  "module.exports": () => index
});
module.exports = __toCommonJS(puente_exports);

// node_modules/@stylistic/eslint-plugin/dist/rolldown-runtime.js
var import_node_module = require("node:module");
var import_meta = {};
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __exportAll = (all2, symbols) => {
  let target = {};
  for (var name in all2) __defProp2(target, name, {
    get: all2[name],
    enumerable: true
  });
  if (symbols) __defProp2(target, Symbol.toStringTag, { value: "Module" });
  return target;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i = 0, n = keys.length, key; i < n; i++) {
    key = keys[i];
    if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
      get: ((k) => from[k]).bind(null, key),
      enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
    });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
  value: mod,
  enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ (0, import_node_module.createRequire)(__filename);

// node_modules/@stylistic/eslint-plugin/dist/vendor.js
var require_astUtilities = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isParenthesized = exports2.hasSideEffect = exports2.getStringIfConstant = exports2.getStaticValue = exports2.getPropertyName = exports2.getFunctionNameWithKind = exports2.getFunctionHeadLocation = void 0;
  const eslintUtils$4 = __importStar(__require("@eslint-community/eslint-utils"));
  exports2.getFunctionHeadLocation = eslintUtils$4.getFunctionHeadLocation;
  exports2.getFunctionNameWithKind = eslintUtils$4.getFunctionNameWithKind;
  exports2.getPropertyName = eslintUtils$4.getPropertyName;
  exports2.getStaticValue = eslintUtils$4.getStaticValue;
  exports2.getStringIfConstant = eslintUtils$4.getStringIfConstant;
  exports2.hasSideEffect = eslintUtils$4.hasSideEffect;
  exports2.isParenthesized = eslintUtils$4.isParenthesized;
}));
var require_PatternMatcher = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PatternMatcher = void 0;
  exports2.PatternMatcher = __importStar(__require("@eslint-community/eslint-utils")).PatternMatcher;
}));
var require_predicates$1 = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isNotSemicolonToken = exports2.isSemicolonToken = exports2.isNotOpeningParenToken = exports2.isOpeningParenToken = exports2.isNotOpeningBracketToken = exports2.isOpeningBracketToken = exports2.isNotOpeningBraceToken = exports2.isOpeningBraceToken = exports2.isNotCommentToken = exports2.isCommentToken = exports2.isNotCommaToken = exports2.isCommaToken = exports2.isNotColonToken = exports2.isColonToken = exports2.isNotClosingParenToken = exports2.isClosingParenToken = exports2.isNotClosingBracketToken = exports2.isClosingBracketToken = exports2.isNotClosingBraceToken = exports2.isClosingBraceToken = exports2.isNotArrowToken = exports2.isArrowToken = void 0;
  const eslintUtils$2 = __importStar(__require("@eslint-community/eslint-utils"));
  exports2.isArrowToken = eslintUtils$2.isArrowToken;
  exports2.isNotArrowToken = eslintUtils$2.isNotArrowToken;
  exports2.isClosingBraceToken = eslintUtils$2.isClosingBraceToken;
  exports2.isNotClosingBraceToken = eslintUtils$2.isNotClosingBraceToken;
  exports2.isClosingBracketToken = eslintUtils$2.isClosingBracketToken;
  exports2.isNotClosingBracketToken = eslintUtils$2.isNotClosingBracketToken;
  exports2.isClosingParenToken = eslintUtils$2.isClosingParenToken;
  exports2.isNotClosingParenToken = eslintUtils$2.isNotClosingParenToken;
  exports2.isColonToken = eslintUtils$2.isColonToken;
  exports2.isNotColonToken = eslintUtils$2.isNotColonToken;
  exports2.isCommaToken = eslintUtils$2.isCommaToken;
  exports2.isNotCommaToken = eslintUtils$2.isNotCommaToken;
  exports2.isCommentToken = eslintUtils$2.isCommentToken;
  exports2.isNotCommentToken = eslintUtils$2.isNotCommentToken;
  exports2.isOpeningBraceToken = eslintUtils$2.isOpeningBraceToken;
  exports2.isNotOpeningBraceToken = eslintUtils$2.isNotOpeningBraceToken;
  exports2.isOpeningBracketToken = eslintUtils$2.isOpeningBracketToken;
  exports2.isNotOpeningBracketToken = eslintUtils$2.isNotOpeningBracketToken;
  exports2.isOpeningParenToken = eslintUtils$2.isOpeningParenToken;
  exports2.isNotOpeningParenToken = eslintUtils$2.isNotOpeningParenToken;
  exports2.isSemicolonToken = eslintUtils$2.isSemicolonToken;
  exports2.isNotSemicolonToken = eslintUtils$2.isNotSemicolonToken;
}));
var require_ReferenceTracker = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ReferenceTracker = void 0;
  const eslintUtils$1 = __importStar(__require("@eslint-community/eslint-utils"));
  eslintUtils$1.ReferenceTracker.READ;
  eslintUtils$1.ReferenceTracker.CALL;
  eslintUtils$1.ReferenceTracker.CONSTRUCT;
  eslintUtils$1.ReferenceTracker.ESM;
  exports2.ReferenceTracker = eslintUtils$1.ReferenceTracker;
}));
var require_scopeAnalysis = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getInnermostScope = exports2.findVariable = void 0;
  const eslintUtils = __importStar(__require("@eslint-community/eslint-utils"));
  exports2.findVariable = eslintUtils.findVariable;
  exports2.getInnermostScope = eslintUtils.getInnermostScope;
}));
var require_eslint_utils = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports$2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$2, p)) __createBinding(exports$2, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_astUtilities(), exports2);
  __exportStar(require_PatternMatcher(), exports2);
  __exportStar(require_predicates$1(), exports2);
  __exportStar(require_ReferenceTracker(), exports2);
  __exportStar(require_scopeAnalysis(), exports2);
}));
var require_helpers = /* @__PURE__ */ __commonJSMin(((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isNotTokenOfTypeWithConditions = exports2.isTokenOfTypeWithConditions = exports2.isNodeOfTypeWithConditions = exports2.isNodeOfTypes = exports2.isNodeOfType = void 0;
  const isNodeOfType = (nodeType) => (node) => node?.type === nodeType;
  exports2.isNodeOfType = isNodeOfType;
  const isNodeOfTypes = (nodeTypes) => (node) => !!node && nodeTypes.includes(node.type);
  exports2.isNodeOfTypes = isNodeOfTypes;
  const isNodeOfTypeWithConditions = (nodeType, conditions) => {
    const entries = Object.entries(conditions);
    return (node) => node?.type === nodeType && entries.every(([key, value]) => node[key] === value);
  };
  exports2.isNodeOfTypeWithConditions = isNodeOfTypeWithConditions;
  const isTokenOfTypeWithConditions = (tokenType, conditions) => {
    const entries = Object.entries(conditions);
    return (token) => token?.type === tokenType && entries.every(([key, value]) => token[key] === value);
  };
  exports2.isTokenOfTypeWithConditions = isTokenOfTypeWithConditions;
  const isNotTokenOfTypeWithConditions = (tokenType, conditions) => (token) => !(0, exports2.isTokenOfTypeWithConditions)(tokenType, conditions)(token);
  exports2.isNotTokenOfTypeWithConditions = isNotTokenOfTypeWithConditions;
}));
var require_misc = /* @__PURE__ */ __commonJSMin(((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.LINEBREAK_MATCHER = void 0;
  exports2.isTokenOnSameLine = isTokenOnSameLine;
  exports2.LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/;
  function isTokenOnSameLine(left, right) {
    return left.loc.end.line === right.loc.start.line;
  }
}));
var require_ts_estree = /* @__PURE__ */ __commonJSMin(((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TSESTree = exports2.AST_TOKEN_TYPES = exports2.AST_NODE_TYPES = void 0;
  var types_1 = __require("@typescript-eslint/types");
  Object.defineProperty(exports2, "AST_NODE_TYPES", {
    enumerable: true,
    get: function() {
      return types_1.AST_NODE_TYPES;
    }
  });
  Object.defineProperty(exports2, "AST_TOKEN_TYPES", {
    enumerable: true,
    get: function() {
      return types_1.AST_TOKEN_TYPES;
    }
  });
  Object.defineProperty(exports2, "TSESTree", {
    enumerable: true,
    get: function() {
      return types_1.TSESTree;
    }
  });
}));
var require_predicates = /* @__PURE__ */ __commonJSMin(((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isLoop = exports2.isImportKeyword = exports2.isTypeKeyword = exports2.isAwaitKeyword = exports2.isAwaitExpression = exports2.isIdentifier = exports2.isConstructor = exports2.isClassOrTypeElement = exports2.isTSConstructorType = exports2.isTSFunctionType = exports2.isFunctionOrFunctionType = exports2.isFunctionType = exports2.isFunction = exports2.isVariableDeclarator = exports2.isTypeAssertion = exports2.isLogicalOrOperator = exports2.isOptionalCallExpression = exports2.isNotNonNullAssertionPunctuator = exports2.isNonNullAssertionPunctuator = exports2.isNotOptionalChainPunctuator = exports2.isOptionalChainPunctuator = void 0;
  exports2.isSetter = isSetter;
  const ts_estree_1 = require_ts_estree();
  const helpers_1 = require_helpers();
  exports2.isOptionalChainPunctuator = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "?." });
  exports2.isNotOptionalChainPunctuator = (0, helpers_1.isNotTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "?." });
  exports2.isNonNullAssertionPunctuator = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "!" });
  exports2.isNotNonNullAssertionPunctuator = (0, helpers_1.isNotTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "!" });
  exports2.isOptionalCallExpression = (0, helpers_1.isNodeOfTypeWithConditions)(ts_estree_1.AST_NODE_TYPES.CallExpression, { optional: true });
  exports2.isLogicalOrOperator = (0, helpers_1.isNodeOfTypeWithConditions)(ts_estree_1.AST_NODE_TYPES.LogicalExpression, { operator: "||" });
  exports2.isTypeAssertion = (0, helpers_1.isNodeOfTypes)([ts_estree_1.AST_NODE_TYPES.TSAsExpression, ts_estree_1.AST_NODE_TYPES.TSTypeAssertion]);
  exports2.isVariableDeclarator = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.VariableDeclarator);
  const functionTypes = [
    ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,
    ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,
    ts_estree_1.AST_NODE_TYPES.FunctionExpression
  ];
  exports2.isFunction = (0, helpers_1.isNodeOfTypes)(functionTypes);
  const functionTypeTypes = [
    ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
    ts_estree_1.AST_NODE_TYPES.TSConstructorType,
    ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
    ts_estree_1.AST_NODE_TYPES.TSDeclareFunction,
    ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
    ts_estree_1.AST_NODE_TYPES.TSFunctionType,
    ts_estree_1.AST_NODE_TYPES.TSMethodSignature
  ];
  exports2.isFunctionType = (0, helpers_1.isNodeOfTypes)(functionTypeTypes);
  exports2.isFunctionOrFunctionType = (0, helpers_1.isNodeOfTypes)([...functionTypes, ...functionTypeTypes]);
  exports2.isTSFunctionType = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.TSFunctionType);
  exports2.isTSConstructorType = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.TSConstructorType);
  exports2.isClassOrTypeElement = (0, helpers_1.isNodeOfTypes)([
    ts_estree_1.AST_NODE_TYPES.PropertyDefinition,
    ts_estree_1.AST_NODE_TYPES.FunctionExpression,
    ts_estree_1.AST_NODE_TYPES.MethodDefinition,
    ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition,
    ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition,
    ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
    ts_estree_1.AST_NODE_TYPES.TSIndexSignature,
    ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
    ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
    ts_estree_1.AST_NODE_TYPES.TSMethodSignature,
    ts_estree_1.AST_NODE_TYPES.TSPropertySignature
  ]);
  exports2.isConstructor = (0, helpers_1.isNodeOfTypeWithConditions)(ts_estree_1.AST_NODE_TYPES.MethodDefinition, { kind: "constructor" });
  function isSetter(node) {
    return !!node && (node.type === ts_estree_1.AST_NODE_TYPES.MethodDefinition || node.type === ts_estree_1.AST_NODE_TYPES.Property) && node.kind === "set";
  }
  exports2.isIdentifier = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.Identifier);
  exports2.isAwaitExpression = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.AwaitExpression);
  exports2.isAwaitKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Identifier, { value: "await" });
  exports2.isTypeKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Identifier, { value: "type" });
  exports2.isImportKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Keyword, { value: "import" });
  exports2.isLoop = (0, helpers_1.isNodeOfTypes)([
    ts_estree_1.AST_NODE_TYPES.DoWhileStatement,
    ts_estree_1.AST_NODE_TYPES.ForStatement,
    ts_estree_1.AST_NODE_TYPES.ForInStatement,
    ts_estree_1.AST_NODE_TYPES.ForOfStatement,
    ts_estree_1.AST_NODE_TYPES.WhileStatement
  ]);
}));
var require_ast_utils = /* @__PURE__ */ __commonJSMin(((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_eslint_utils(), exports2);
  __exportStar(require_helpers(), exports2);
  __exportStar(require_misc(), exports2);
  __exportStar(require_predicates(), exports2);
}));
function escapeStringRegexp(string) {
  if (typeof string !== "string") throw new TypeError("Expected a string");
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/@stylistic/eslint-plugin/dist/utils.js
var import_node_process = require("node:process");
var import_types = __toESM(require_dist(), 1);

// node_modules/eslint-visitor-keys/lib/visitor-keys.js
var KEYS = {
  ArrayExpression: [
    "elements"
  ],
  ArrayPattern: [
    "elements"
  ],
  ArrowFunctionExpression: [
    "params",
    "body"
  ],
  AssignmentExpression: [
    "left",
    "right"
  ],
  AssignmentPattern: [
    "left",
    "right"
  ],
  AwaitExpression: [
    "argument"
  ],
  BinaryExpression: [
    "left",
    "right"
  ],
  BlockStatement: [
    "body"
  ],
  BreakStatement: [
    "label"
  ],
  CallExpression: [
    "callee",
    "arguments"
  ],
  CatchClause: [
    "param",
    "body"
  ],
  ChainExpression: [
    "expression"
  ],
  ClassBody: [
    "body"
  ],
  ClassDeclaration: [
    "id",
    "superClass",
    "body"
  ],
  ClassExpression: [
    "id",
    "superClass",
    "body"
  ],
  ConditionalExpression: [
    "test",
    "consequent",
    "alternate"
  ],
  ContinueStatement: [
    "label"
  ],
  DebuggerStatement: [],
  DoWhileStatement: [
    "body",
    "test"
  ],
  EmptyStatement: [],
  ExperimentalRestProperty: [
    "argument"
  ],
  ExperimentalSpreadProperty: [
    "argument"
  ],
  ExportAllDeclaration: [
    "exported",
    "source",
    "attributes"
  ],
  ExportDefaultDeclaration: [
    "declaration"
  ],
  ExportNamedDeclaration: [
    "declaration",
    "specifiers",
    "source",
    "attributes"
  ],
  ExportSpecifier: [
    "local",
    "exported"
  ],
  ExpressionStatement: [
    "expression"
  ],
  ForInStatement: [
    "left",
    "right",
    "body"
  ],
  ForOfStatement: [
    "left",
    "right",
    "body"
  ],
  ForStatement: [
    "init",
    "test",
    "update",
    "body"
  ],
  FunctionDeclaration: [
    "id",
    "params",
    "body"
  ],
  FunctionExpression: [
    "id",
    "params",
    "body"
  ],
  Identifier: [],
  IfStatement: [
    "test",
    "consequent",
    "alternate"
  ],
  ImportAttribute: [
    "key",
    "value"
  ],
  ImportDeclaration: [
    "specifiers",
    "source",
    "attributes"
  ],
  ImportDefaultSpecifier: [
    "local"
  ],
  ImportExpression: [
    "source",
    "options"
  ],
  ImportNamespaceSpecifier: [
    "local"
  ],
  ImportSpecifier: [
    "imported",
    "local"
  ],
  JSXAttribute: [
    "name",
    "value"
  ],
  JSXClosingElement: [
    "name"
  ],
  JSXClosingFragment: [],
  JSXElement: [
    "openingElement",
    "children",
    "closingElement"
  ],
  JSXEmptyExpression: [],
  JSXExpressionContainer: [
    "expression"
  ],
  JSXFragment: [
    "openingFragment",
    "children",
    "closingFragment"
  ],
  JSXIdentifier: [],
  JSXMemberExpression: [
    "object",
    "property"
  ],
  JSXNamespacedName: [
    "namespace",
    "name"
  ],
  JSXOpeningElement: [
    "name",
    "attributes"
  ],
  JSXOpeningFragment: [],
  JSXSpreadAttribute: [
    "argument"
  ],
  JSXSpreadChild: [
    "expression"
  ],
  JSXText: [],
  LabeledStatement: [
    "label",
    "body"
  ],
  Literal: [],
  LogicalExpression: [
    "left",
    "right"
  ],
  MemberExpression: [
    "object",
    "property"
  ],
  MetaProperty: [
    "meta",
    "property"
  ],
  MethodDefinition: [
    "key",
    "value"
  ],
  NewExpression: [
    "callee",
    "arguments"
  ],
  ObjectExpression: [
    "properties"
  ],
  ObjectPattern: [
    "properties"
  ],
  PrivateIdentifier: [],
  Program: [
    "body"
  ],
  Property: [
    "key",
    "value"
  ],
  PropertyDefinition: [
    "key",
    "value"
  ],
  RestElement: [
    "argument"
  ],
  ReturnStatement: [
    "argument"
  ],
  SequenceExpression: [
    "expressions"
  ],
  SpreadElement: [
    "argument"
  ],
  StaticBlock: [
    "body"
  ],
  Super: [],
  SwitchCase: [
    "test",
    "consequent"
  ],
  SwitchStatement: [
    "discriminant",
    "cases"
  ],
  TaggedTemplateExpression: [
    "tag",
    "quasi"
  ],
  TemplateElement: [],
  TemplateLiteral: [
    "quasis",
    "expressions"
  ],
  ThisExpression: [],
  ThrowStatement: [
    "argument"
  ],
  TryStatement: [
    "block",
    "handler",
    "finalizer"
  ],
  UnaryExpression: [
    "argument"
  ],
  UpdateExpression: [
    "argument"
  ],
  VariableDeclaration: [
    "declarations"
  ],
  VariableDeclarator: [
    "id",
    "init"
  ],
  WhileStatement: [
    "test",
    "body"
  ],
  WithStatement: [
    "object",
    "body"
  ],
  YieldExpression: [
    "argument"
  ]
};
var NODE_TYPES = Object.keys(KEYS);
for (const type of NODE_TYPES) {
  Object.freeze(KEYS[type]);
}
Object.freeze(KEYS);
var visitor_keys_default = KEYS;

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0) end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
  return toString.call(obj) === "[object Array]";
});
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports2 = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports2);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next + 5, after;
    if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next + 2, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports2) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports2);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports2) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports2, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports2) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports2);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports2, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports2, node.declaration.declarations);
    } else {
      this.checkExport(exports2, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports2);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports2, name, pos) {
  if (!exports2) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports2, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports2[name] = true;
};
pp$8.checkPatternExport = function(exports2, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports2, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports2, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports2, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports2, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports2, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports2, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports2, decls) {
  if (!exports2) {
    return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports2, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports2) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports2,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports2) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports2));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression2 = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression2) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _ in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list = known; i < list.length; i += 1) {
          var altID = list[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true;
    }
    if (n <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(code);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      // fall through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      // fall through
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.15.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};

// node_modules/espree/espree.js
var import_acorn_jsx = __toESM(require_acorn_jsx(), 1);

// node_modules/espree/lib/token-translator.js
var Token3 = {
  Boolean: "Boolean",
  EOF: "<end>",
  Identifier: "Identifier",
  PrivateIdentifier: "PrivateIdentifier",
  Keyword: "Keyword",
  Null: "Null",
  Numeric: "Numeric",
  Punctuator: "Punctuator",
  String: "String",
  RegularExpression: "RegularExpression",
  Template: "Template",
  JSXIdentifier: "JSXIdentifier",
  JSXText: "JSXText"
};
function convertTemplatePart(tokens, code) {
  const firstToken = tokens[0], lastTemplateToken = tokens.at(-1);
  const token = {
    type: Token3.Template,
    value: code.slice(firstToken.start, lastTemplateToken.end)
  };
  if (firstToken.loc) {
    token.loc = {
      start: firstToken.loc.start,
      end: lastTemplateToken.loc.end
    };
  }
  if (firstToken.range) {
    token.start = firstToken.range[0];
    token.end = lastTemplateToken.range[1];
    token.range = [token.start, token.end];
  }
  return token;
}
function TokenTranslator(acornTokTypes, code) {
  this._acornTokTypes = acornTokTypes;
  this._tokens = [];
  this._curlyBrace = null;
  this._code = code;
}
TokenTranslator.prototype = {
  constructor: TokenTranslator,
  /**
   * Translates a single Esprima token to a single Acorn token. This may be
   * inaccurate due to how templates are handled differently in Esprima and
   * Acorn, but should be accurate for all other tokens.
   * @param {AcornToken} token The Acorn token to translate.
   * @param {Object} extra Espree extra object.
   * @returns {EsprimaToken} The Esprima version of the token.
   */
  translate(token, extra) {
    const type = token.type, tt = this._acornTokTypes;
    if (type === tt.name) {
      token.type = Token3.Identifier;
      if (token.value === "static") {
        token.type = Token3.Keyword;
      }
      if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
        token.type = Token3.Keyword;
      }
    } else if (type === tt.privateId) {
      token.type = Token3.PrivateIdentifier;
    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type === tt.questionDot || type.binop && !type.keyword || type.isAssign) {
      token.type = Token3.Punctuator;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.jsxName) {
      token.type = Token3.JSXIdentifier;
    } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
      token.type = Token3.JSXText;
    } else if (type.keyword) {
      if (type.keyword === "true" || type.keyword === "false") {
        token.type = Token3.Boolean;
      } else if (type.keyword === "null") {
        token.type = Token3.Null;
      } else {
        token.type = Token3.Keyword;
      }
    } else if (type === tt.num) {
      token.type = Token3.Numeric;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.string) {
      if (extra.jsxAttrValueToken) {
        extra.jsxAttrValueToken = false;
        token.type = Token3.JSXText;
      } else {
        token.type = Token3.String;
      }
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.regexp) {
      token.type = Token3.RegularExpression;
      const value = token.value;
      token.regex = {
        flags: value.flags,
        pattern: value.pattern
      };
      token.value = `/${value.pattern}/${value.flags}`;
    }
    return token;
  },
  /**
   * Function to call during Acorn's onToken handler.
   * @param {AcornToken} token The Acorn token.
   * @param {Object} extra The Espree extra object.
   * @returns {void}
   */
  onToken(token, extra) {
    const tt = this._acornTokTypes, tokens = extra.tokens, templateTokens = this._tokens;
    const translateTemplateTokens = () => {
      tokens.push(convertTemplatePart(this._tokens, this._code));
      this._tokens = [];
    };
    if (token.type === tt.eof) {
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      }
      return;
    }
    if (token.type === tt.backQuote) {
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
        this._curlyBrace = null;
      }
      templateTokens.push(token);
      if (templateTokens.length > 1) {
        translateTemplateTokens();
      }
      return;
    }
    if (token.type === tt.dollarBraceL) {
      templateTokens.push(token);
      translateTemplateTokens();
      return;
    }
    if (token.type === tt.braceR) {
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      }
      this._curlyBrace = token;
      return;
    }
    if (token.type === tt.template || token.type === tt.invalidTemplate) {
      if (this._curlyBrace) {
        templateTokens.push(this._curlyBrace);
        this._curlyBrace = null;
      }
      templateTokens.push(token);
      return;
    }
    if (this._curlyBrace) {
      tokens.push(this.translate(this._curlyBrace, extra));
      this._curlyBrace = null;
    }
    tokens.push(this.translate(token, extra));
  }
};
var token_translator_default = TokenTranslator;

// node_modules/espree/lib/options.js
var SUPPORTED_VERSIONS = [
  3,
  5,
  6,
  // 2015
  7,
  // 2016
  8,
  // 2017
  9,
  // 2018
  10,
  // 2019
  11,
  // 2020
  12,
  // 2021
  13,
  // 2022
  14,
  // 2023
  15,
  // 2024
  16,
  // 2025
  17
  // 2026
];
function getLatestEcmaVersion() {
  return SUPPORTED_VERSIONS.at(-1);
}
function getSupportedEcmaVersions() {
  return [...SUPPORTED_VERSIONS];
}
function normalizeEcmaVersion(ecmaVersion = 5) {
  let version2 = ecmaVersion === "latest" ? getLatestEcmaVersion() : ecmaVersion;
  if (typeof version2 !== "number") {
    throw new Error(`ecmaVersion must be a number or "latest". Received value of type ${typeof ecmaVersion} instead.`);
  }
  if (version2 >= 2015) {
    version2 -= 2009;
  }
  if (!SUPPORTED_VERSIONS.includes(version2)) {
    throw new Error("Invalid ecmaVersion.");
  }
  return version2;
}
function normalizeSourceType(sourceType = "script") {
  if (sourceType === "script" || sourceType === "module") {
    return sourceType;
  }
  if (sourceType === "commonjs") {
    return "script";
  }
  throw new Error("Invalid sourceType.");
}
function normalizeOptions(options) {
  const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
  const sourceType = normalizeSourceType(options.sourceType);
  const ranges = options.range === true;
  const locations = options.loc === true;
  if (ecmaVersion !== 3 && options.allowReserved) {
    throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
  }
  if (typeof options.allowReserved !== "undefined" && typeof options.allowReserved !== "boolean") {
    throw new Error("`allowReserved`, when present, must be `true` or `false`");
  }
  const allowReserved = ecmaVersion === 3 ? options.allowReserved || "never" : false;
  const ecmaFeatures = options.ecmaFeatures || {};
  const allowReturnOutsideFunction = options.sourceType === "commonjs" || Boolean(ecmaFeatures.globalReturn);
  if (sourceType === "module" && ecmaVersion < 6) {
    throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
  }
  return Object.assign({}, options, {
    ecmaVersion,
    sourceType,
    ranges,
    locations,
    allowReserved,
    allowReturnOutsideFunction
  });
}

// node_modules/espree/lib/espree.js
var STATE = /* @__PURE__ */ Symbol("espree's internal state");
var ESPRIMA_FINISH_NODE = /* @__PURE__ */ Symbol("espree's esprimaFinishNode");
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {
  let type;
  if (block) {
    type = "Block";
  } else if (code.slice(start, start + 2) === "#!") {
    type = "Hashbang";
  } else {
    type = "Line";
  }
  const comment = {
    type,
    value: text
  };
  if (typeof start === "number") {
    comment.start = start;
    comment.end = end;
    comment.range = [start, end];
  }
  if (typeof startLoc === "object") {
    comment.loc = {
      start: startLoc,
      end: endLoc
    };
  }
  return comment;
}
var espree_default = () => (Parser3) => {
  const tokTypes = Object.assign({}, Parser3.acorn.tokTypes);
  if (Parser3.acornJsx) {
    Object.assign(tokTypes, Parser3.acornJsx.tokTypes);
  }
  return class Espree extends Parser3 {
    constructor(opts, code) {
      if (typeof opts !== "object" || opts === null) {
        opts = {};
      }
      if (typeof code !== "string" && !(code instanceof String)) {
        code = String(code);
      }
      const originalSourceType = opts.sourceType;
      const options = normalizeOptions(opts);
      const ecmaFeatures = options.ecmaFeatures || {};
      const tokenTranslator = options.tokens === true ? new token_translator_default(tokTypes, code) : null;
      const state = {
        originalSourceType: originalSourceType || options.sourceType,
        tokens: tokenTranslator ? [] : null,
        comments: options.comment === true ? [] : null,
        impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,
        ecmaVersion: options.ecmaVersion,
        jsxAttrValueToken: false,
        lastToken: null,
        templateElements: []
      };
      super({
        // do not use spread, because we don't want to pass any unknown options to acorn
        ecmaVersion: options.ecmaVersion,
        sourceType: options.sourceType,
        ranges: options.ranges,
        locations: options.locations,
        allowReserved: options.allowReserved,
        // Truthy value is true for backward compatibility.
        allowReturnOutsideFunction: options.allowReturnOutsideFunction,
        // Collect tokens
        onToken(token) {
          if (tokenTranslator) {
            tokenTranslator.onToken(token, state);
          }
          if (token.type !== tokTypes.eof) {
            state.lastToken = token;
          }
        },
        // Collect comments
        onComment(block, text, start, end, startLoc, endLoc) {
          if (state.comments) {
            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);
            state.comments.push(comment);
          }
        }
      }, code);
      this[STATE] = state;
    }
    tokenize() {
      do {
        this.next();
      } while (this.type !== tokTypes.eof);
      this.next();
      const extra = this[STATE];
      const tokens = extra.tokens;
      if (extra.comments) {
        tokens.comments = extra.comments;
      }
      return tokens;
    }
    finishNode(...args) {
      const result = super.finishNode(...args);
      return this[ESPRIMA_FINISH_NODE](result);
    }
    finishNodeAt(...args) {
      const result = super.finishNodeAt(...args);
      return this[ESPRIMA_FINISH_NODE](result);
    }
    parse() {
      const extra = this[STATE];
      const program = super.parse();
      program.sourceType = extra.originalSourceType;
      if (extra.comments) {
        program.comments = extra.comments;
      }
      if (extra.tokens) {
        program.tokens = extra.tokens;
      }
      if (program.body.length) {
        const [firstNode] = program.body;
        if (program.range) {
          program.range[0] = firstNode.range[0];
        }
        if (program.loc) {
          program.loc.start = firstNode.loc.start;
        }
        program.start = firstNode.start;
      }
      if (extra.lastToken) {
        if (program.range) {
          program.range[1] = extra.lastToken.range[1];
        }
        if (program.loc) {
          program.loc.end = extra.lastToken.loc.end;
        }
        program.end = extra.lastToken.end;
      }
      this[STATE].templateElements.forEach((templateElement) => {
        const startOffset = -1;
        const endOffset = templateElement.tail ? 1 : 2;
        templateElement.start += startOffset;
        templateElement.end += endOffset;
        if (templateElement.range) {
          templateElement.range[0] += startOffset;
          templateElement.range[1] += endOffset;
        }
        if (templateElement.loc) {
          templateElement.loc.start.column += startOffset;
          templateElement.loc.end.column += endOffset;
        }
      });
      return program;
    }
    parseTopLevel(node) {
      if (this[STATE].impliedStrict) {
        this.strict = true;
      }
      return super.parseTopLevel(node);
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    raise(pos, message) {
      const loc = Parser3.acorn.getLineInfo(this.input, pos);
      const err = new SyntaxError(message);
      err.index = pos;
      err.lineNumber = loc.line;
      err.column = loc.column + 1;
      throw err;
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    raiseRecoverable(pos, message) {
      this.raise(pos, message);
    }
    /**
     * Overwrites the default unexpected method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    unexpected(pos) {
      let message = "Unexpected token";
      if (pos !== null && pos !== void 0) {
        this.pos = pos;
        if (this.options.locations) {
          while (this.pos < this.lineStart) {
            this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
            --this.curLine;
          }
        }
        this.nextToken();
      }
      if (this.end > this.start) {
        message += ` ${this.input.slice(this.start, this.end)}`;
      }
      this.raise(this.start, message);
    }
    /*
    * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
    * uses regular tt.string without any distinction between this and regular JS
    * strings. As such, we intercept an attempt to read a JSX string and set a flag
    * on extra so that when tokens are converted, the next token will be switched
    * to JSXText via onToken.
    */
    jsx_readString(quote) {
      const result = super.jsx_readString(quote);
      if (this.type === tokTypes.string) {
        this[STATE].jsxAttrValueToken = true;
      }
      return result;
    }
    /**
     * Performs last-minute Esprima-specific compatibility checks and fixes.
     * @param {ASTNode} result The node to check.
     * @returns {ASTNode} The finished node.
     */
    [ESPRIMA_FINISH_NODE](result) {
      if (result.type === "TemplateElement") {
        this[STATE].templateElements.push(result);
      }
      if (result.type.includes("Function") && !result.generator) {
        result.generator = false;
      }
      return result;
    }
  };
};

// node_modules/espree/espree.js
var parsers = {
  _regular: null,
  _jsx: null,
  get regular() {
    if (this._regular === null) {
      this._regular = Parser.extend(espree_default());
    }
    return this._regular;
  },
  get jsx() {
    if (this._jsx === null) {
      this._jsx = Parser.extend((0, import_acorn_jsx.default)(), espree_default());
    }
    return this._jsx;
  },
  get(options) {
    const useJsx = Boolean(
      options && options.ecmaFeatures && options.ecmaFeatures.jsx
    );
    return useJsx ? this.jsx : this.regular;
  }
};
function tokenize(code, options) {
  const Parser3 = parsers.get(options);
  if (!options || options.tokens !== true) {
    options = Object.assign({}, options, { tokens: true });
  }
  return new Parser3(options, code).tokenize();
}
var VisitorKeys = /* @__PURE__ */ (function() {
  return visitor_keys_default;
})();
var Syntax = (function() {
  let key, types2 = {};
  if (typeof Object.create === "function") {
    types2 = /* @__PURE__ */ Object.create(null);
  }
  for (key in VisitorKeys) {
    if (Object.hasOwn(VisitorKeys, key)) {
      types2[key] = key;
    }
  }
  if (typeof Object.freeze === "function") {
    Object.freeze(types2);
  }
  return types2;
})();
var latestEcmaVersion = getLatestEcmaVersion();
var supportedEcmaVersions = getSupportedEcmaVersions();

// node_modules/@stylistic/eslint-plugin/dist/utils.js
var import_estraverse = __toESM(require_estraverse(), 1);
function createAllConfigs(plugin, name, filter) {
  const rules = Object.fromEntries(Object.entries(plugin.rules).filter(([key, rule]) => rule.meta.fixable && !rule.meta.deprecated && !rule.meta.experimental && key === rule.meta.docs.url.split("/").pop() && (!filter || filter(key, rule))).map(([key]) => [`${name}/${key}`, 2]));
  return {
    plugins: { [name]: plugin },
    rules
  };
}
var warned = /* @__PURE__ */ new Set();
function warnOnce(text) {
  if (import_node_process.env.TEST || warned.has(text)) return;
  warned.add(text);
  console.warn(`[@stylistic/eslint-plugin]: ${text}`);
}
function warnDeprecation(value, instead, rule = "") {
  let message = `You are using deprecated ${value}${rule ? ` in "${rule}"` : ""}`;
  if (instead) message += `, please use ${instead} instead.`;
  return warnOnce(message);
}
function warnDeprecatedOptions(options, keys, instead, rule = "") {
  if (!Array.isArray(keys)) keys = [keys];
  keys.forEach((key) => {
    if (options && Object.hasOwn(options, key)) warnDeprecation(`option("${key.toString()}")`, instead ? `"${instead.toString()}"` : void 0, rule);
  });
}
var import_ast_utils = require_ast_utils();
var COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
var LINEBREAKS = /* @__PURE__ */ new Set([
  "\r\n",
  "\r",
  "\n",
  "\u2028",
  "\u2029"
]);
var STATEMENT_LIST_PARENTS = /* @__PURE__ */ new Set([
  "Program",
  "BlockStatement",
  "StaticBlock",
  "SwitchCase"
]);
var DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;
var OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\]|\\.)*\\(?:[1-9]|0\d)/su;
var ASSIGNMENT_OPERATOR = [
  "=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "<<=",
  ">>=",
  ">>>=",
  "|=",
  "^=",
  "&=",
  "**=",
  "||=",
  "&&=",
  "??="
];
var ES3_KEYWORDS = [
  "abstract",
  "boolean",
  "break",
  "byte",
  "case",
  "catch",
  "char",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "double",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "final",
  "finally",
  "float",
  "for",
  "function",
  "goto",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "int",
  "interface",
  "long",
  "native",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "short",
  "static",
  "super",
  "switch",
  "synchronized",
  "this",
  "throw",
  "throws",
  "transient",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "volatile",
  "while",
  "with"
];
var KEYWORDS = [
  ...ES3_KEYWORDS,
  "arguments",
  "as",
  "async",
  "await",
  "eval",
  "from",
  "get",
  "let",
  "of",
  "set",
  "type",
  "using",
  "yield"
].concat(["accessor", "satisfies"]);
function createGlobalLinebreakMatcher() {
  return new RegExp(import_ast_utils.LINEBREAK_MATCHER.source, "gu");
}
var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
function getUpperFunction(node) {
  for (let currentNode = node; currentNode; currentNode = currentNode.parent) if (anyFunctionPattern.test(currentNode.type)) return currentNode;
  return null;
}
function isNullLiteral(node) {
  return node.type === "Literal" && node.value === null && !("regex" in node) && !("bigint" in node);
}
function getStaticStringValue(node) {
  switch (node.type) {
    case "Literal":
      if (node.value === null) {
        if (isNullLiteral(node)) return String(node.value);
        if (isRegExpLiteral(node)) return `/${node.regex.pattern}/${node.regex.flags}`;
        if ("bigint" in node && node.bigint) return node.bigint;
      } else return String(node.value);
      break;
    case "TemplateLiteral":
      if (node.expressions.length === 0 && node.quasis.length === 1) return node.quasis[0].value.cooked;
      break;
  }
  return null;
}
function getStaticPropertyName(node) {
  let prop;
  if (node) switch (node.type) {
    case "ChainExpression":
      return getStaticPropertyName(node.expression);
    case "Property":
    case "PropertyDefinition":
    case "MethodDefinition":
    case "ImportAttribute":
      prop = node.key;
      break;
    case "MemberExpression":
      prop = node.property;
      break;
  }
  if (prop) {
    if (prop.type === "Identifier" && !("computed" in node && node.computed)) return prop.name;
    return getStaticStringValue(prop);
  }
  return null;
}
function skipChainExpression(node) {
  return node && node.type === "ChainExpression" ? node.expression : node;
}
function isParenthesised(sourceCode, node) {
  const previousToken = sourceCode.getTokenBefore(node);
  const nextToken = sourceCode.getTokenAfter(node);
  return !!previousToken && !!nextToken && (0, import_ast_utils.isOpeningParenToken)(previousToken) && previousToken.range[1] <= node.range[0] && (0, import_ast_utils.isClosingParenToken)(nextToken) && nextToken.range[0] >= node.range[1];
}
function isEqToken(token) {
  return token.value === "=" && token.type === "Punctuator";
}
function isQuestionToken(token) {
  return token.value === "?" && token.type === "Punctuator";
}
function isKeywordToken(token) {
  return token?.type === "Keyword";
}
function isHashbangComment(comment) {
  return comment.type === "Shebang" || comment.type === "Hashbang";
}
function isLogicalExpression(node) {
  return node.type === "LogicalExpression" && (node.operator === "&&" || node.operator === "||");
}
function isCoalesceExpression(node) {
  return node.type === "LogicalExpression" && node.operator === "??";
}
function isMixedLogicalAndCoalesceExpressions(left, right) {
  return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);
}
function getSwitchCaseColonToken(node, sourceCode) {
  if (node.test) return sourceCode.getTokenAfter(node.test, (token) => (0, import_ast_utils.isColonToken)(token));
  return sourceCode.getFirstToken(node, 1);
}
function isTopLevelExpressionStatement(node) {
  if (node.type !== "ExpressionStatement") return false;
  const parent = node.parent;
  return parent.type === "Program" || parent.type === "BlockStatement" && (0, import_ast_utils.isFunction)(parent.parent);
}
function isStringLiteral(node) {
  return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
}
function isRegExpLiteral(node) {
  return node.type === "Literal" && "regex" in node;
}
function isSurroundedBy(val, character) {
  return val[0] === character && val[val.length - 1] === character;
}
function getPrecedence(node) {
  switch (node.type) {
    case "SequenceExpression":
      return 0;
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "YieldExpression":
      return 1;
    case "ConditionalExpression":
    case "TSConditionalType":
      return 3;
    case "LogicalExpression":
      switch (node.operator) {
        case "||":
        case "??":
          return 4;
        case "&&":
          return 5;
      }
    case "BinaryExpression":
      switch (node.operator) {
        case "|":
          return 6;
        case "^":
          return 7;
        case "&":
          return 8;
        case "==":
        case "!=":
        case "===":
        case "!==":
          return 9;
        case "<":
        case "<=":
        case ">":
        case ">=":
        case "in":
        case "instanceof":
          return 10;
        case "<<":
        case ">>":
        case ">>>":
          return 11;
        case "+":
        case "-":
          return 12;
        case "*":
        case "/":
        case "%":
          return 13;
        case "**":
          return 15;
      }
    case "TSUnionType":
      return 6;
    case "TSIntersectionType":
      return 8;
    case "UnaryExpression":
    case "AwaitExpression":
      return 16;
    case "UpdateExpression":
      return 17;
    case "CallExpression":
    case "ChainExpression":
    case "ImportExpression":
      return 18;
    case "NewExpression":
      return 19;
    case "TSImportType":
    case "TSArrayType":
      return 20;
    default:
      if (node.type in visitor_keys_default) return 20;
      return -1;
  }
}
function isDecimalInteger(node) {
  return node.type === "Literal" && typeof node.value === "number" && DECIMAL_INTEGER_PATTERN.test(node.raw);
}
function isDecimalIntegerNumericToken(token) {
  return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
}
function getNextLocation(sourceCode, { column, line }) {
  if (column < sourceCode.lines[line - 1].length) return {
    column: column + 1,
    line
  };
  if (line < sourceCode.lines.length) return {
    column: 0,
    line: line + 1
  };
  return null;
}
function isNumericLiteral(node) {
  return node.type === "Literal" && (typeof node.value === "number" || Boolean("bigint" in node && node.bigint));
}
function canTokensBeAdjacent(leftValue, rightValue) {
  const espreeOptions = {
    comment: true,
    ecmaVersion: latestEcmaVersion,
    range: true
  };
  let leftToken;
  if (typeof leftValue === "string") {
    let tokens;
    try {
      tokens = tokenize(leftValue, espreeOptions);
    } catch {
      return false;
    }
    const comments = tokens.comments;
    leftToken = tokens[tokens.length - 1];
    if (comments.length) {
      const lastComment = comments[comments.length - 1];
      if (!leftToken || lastComment.range[0] > leftToken.range[0]) leftToken = lastComment;
    }
  } else leftToken = leftValue;
  if (isHashbangComment(leftToken)) return false;
  let rightToken;
  if (typeof rightValue === "string") {
    let tokens;
    try {
      tokens = tokenize(rightValue, espreeOptions);
    } catch {
      return false;
    }
    const comments = tokens.comments;
    rightToken = tokens[0];
    if (comments.length) {
      const firstComment = comments[0];
      if (!rightToken || firstComment.range[0] < rightToken.range[0]) rightToken = firstComment;
    }
  } else rightToken = rightValue;
  if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
    if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
      const PLUS_TOKENS = /* @__PURE__ */ new Set(["+", "++"]);
      const MINUS_TOKENS = /* @__PURE__ */ new Set(["-", "--"]);
      return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
    }
    if (leftToken.type === "Punctuator" && leftToken.value === "/") return ![
      "Block",
      "Line",
      "RegularExpression"
    ].includes(rightToken.type);
    return true;
  }
  if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") return true;
  if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) return true;
  if (leftToken.type === "Block" || rightToken.type === "Block" || rightToken.type === "Line") return true;
  if (rightToken.type === "PrivateIdentifier") return true;
  return false;
}
function hasOctalOrNonOctalDecimalEscapeSequence(rawString) {
  return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);
}
var WHITE_SPACES_PATTERN = /^\s*$/u;
function isWhiteSpaces(value) {
  return typeof value === "string" ? WHITE_SPACES_PATTERN.test(value) : false;
}
function getFirstNodeInLine(context, node) {
  const sourceCode = context.sourceCode;
  let token = node;
  let lines = null;
  do {
    token = sourceCode.getTokenBefore(token);
    lines = token.type === "JSXText" ? token.value.split("\n") : null;
  } while (token.type === "JSXText" && lines && isWhiteSpaces(lines.at(-1)));
  return token;
}
function isNodeFirstInLine(context, node) {
  const token = getFirstNodeInLine(context, node);
  if (!token) return false;
  return !(0, import_ast_utils.isTokenOnSameLine)(token, node);
}
function getTokenBeforeClosingBracket(node) {
  const attributes = "attributes" in node && node.attributes;
  if (!attributes || attributes.length === 0) return node.name;
  return attributes[attributes.length - 1];
}
function isSingleLine(node) {
  return node.loc.start.line === node.loc.end.line;
}
function getCommentsBetween(sourceCode, left, right) {
  return sourceCode.getTokensBetween(left, right, {
    includeComments: true,
    filter: import_ast_utils.isCommentToken
  });
}
var ast_exports = /* @__PURE__ */ __exportAll({
  ASSIGNMENT_OPERATOR: () => ASSIGNMENT_OPERATOR,
  AST_NODE_TYPES: () => import_types.AST_NODE_TYPES,
  AST_TOKEN_TYPES: () => import_types.AST_TOKEN_TYPES,
  COMMENTS_IGNORE_PATTERN: () => COMMENTS_IGNORE_PATTERN,
  DECIMAL_INTEGER_PATTERN: () => DECIMAL_INTEGER_PATTERN,
  ES3_KEYWORDS: () => ES3_KEYWORDS,
  KEYWORDS: () => KEYWORDS,
  LINEBREAKS: () => LINEBREAKS,
  OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN: () => OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN,
  STATEMENT_LIST_PARENTS: () => STATEMENT_LIST_PARENTS,
  WHITE_SPACES_PATTERN: () => WHITE_SPACES_PATTERN,
  canTokensBeAdjacent: () => canTokensBeAdjacent,
  createGlobalLinebreakMatcher: () => createGlobalLinebreakMatcher,
  getCommentsBetween: () => getCommentsBetween,
  getFirstNodeInLine: () => getFirstNodeInLine,
  getNextLocation: () => getNextLocation,
  getPrecedence: () => getPrecedence,
  getStaticPropertyName: () => getStaticPropertyName,
  getStaticStringValue: () => getStaticStringValue,
  getSwitchCaseColonToken: () => getSwitchCaseColonToken,
  getTokenBeforeClosingBracket: () => getTokenBeforeClosingBracket,
  getUpperFunction: () => getUpperFunction,
  hasOctalOrNonOctalDecimalEscapeSequence: () => hasOctalOrNonOctalDecimalEscapeSequence,
  isCoalesceExpression: () => isCoalesceExpression,
  isDecimalInteger: () => isDecimalInteger,
  isDecimalIntegerNumericToken: () => isDecimalIntegerNumericToken,
  isEqToken: () => isEqToken,
  isHashbangComment: () => isHashbangComment,
  isKeywordToken: () => isKeywordToken,
  isLogicalExpression: () => isLogicalExpression,
  isMixedLogicalAndCoalesceExpressions: () => isMixedLogicalAndCoalesceExpressions,
  isNodeFirstInLine: () => isNodeFirstInLine,
  isNullLiteral: () => isNullLiteral,
  isNumericLiteral: () => isNumericLiteral,
  isParenthesised: () => isParenthesised,
  isQuestionToken: () => isQuestionToken,
  isRegExpLiteral: () => isRegExpLiteral,
  isSingleLine: () => isSingleLine,
  isStringLiteral: () => isStringLiteral,
  isSurroundedBy: () => isSurroundedBy,
  isTopLevelExpressionStatement: () => isTopLevelExpressionStatement,
  isWhiteSpaces: () => isWhiteSpaces,
  skipChainExpression: () => skipChainExpression
});
__reExport(ast_exports, /* @__PURE__ */ __toESM2(require_ast_utils(), 1));
function isObjectNotArray(obj) {
  return typeof obj === "object" && obj != null && !Array.isArray(obj);
}
function deepMerge(first = {}, second = {}) {
  const keys = new Set(Object.keys(first).concat(Object.keys(second)));
  return Array.from(keys).reduce((acc, key) => {
    const firstHasKey = key in first;
    const secondHasKey = key in second;
    const firstValue = first[key];
    const secondValue = second[key];
    if (firstHasKey && secondHasKey) if (isObjectNotArray(firstValue) && isObjectNotArray(secondValue)) acc[key] = deepMerge(firstValue, secondValue);
    else acc[key] = secondValue;
    else if (firstHasKey) acc[key] = firstValue;
    else acc[key] = secondValue;
    return acc;
  }, {});
}
function createRule({ name, create, meta }) {
  return {
    create: ((context) => {
      if (meta.deprecated) {
        let insted;
        if (typeof meta.deprecated !== "boolean") {
          const { replacedBy } = meta.deprecated;
          if (replacedBy) insted = replacedBy.map(({ rule, plugin }) => `"${rule?.name}"${plugin?.name ? ` in "${plugin.name}"` : ""}`).join(", ");
        }
        warnDeprecation(`rule("${name}")`, insted);
      }
      const { defaultOptions: defaultOptions2 = [] } = meta;
      const optionsCount = Math.max(context.options.length, defaultOptions2.length);
      return create(context, Array.from({ length: optionsCount }, (_, i) => {
        if (isObjectNotArray(context.options[i]) && isObjectNotArray(defaultOptions2[i])) return deepMerge(defaultOptions2[i], context.options[i]);
        return context.options[i] ?? defaultOptions2[i];
      }));
    }),
    meta: {
      ...meta,
      docs: {
        ...meta.docs,
        url: `https://eslint.style/rules/${name}`
      }
    }
  };
}
function safeReplaceTextBetween(sourceCode, left, right, replacement) {
  if (sourceCode.commentsExistBetween(left, right)) return null;
  const range = [left.range[1], right.range[0]];
  return (fixer) => fixer.replaceTextRange(range, typeof replacement === "function" ? replacement() : replacement);
}
function isTextSourceCode(sourceCode) {
  return typeof sourceCode.text === "string";
}
function hasLinesAndGetLocFromIndex(sourceCode) {
  return typeof sourceCode.getLocFromIndex === "function" && Array.isArray(sourceCode.lines);
}
function traverse$1(ASTnode, visitor) {
  const opts = Object.assign({}, { fallback(node) {
    return Object.keys(node).filter((key) => key === "children" || key === "argument");
  } }, visitor);
  opts.keys = Object.assign({}, visitor.keys, {
    JSXElement: ["children"],
    JSXFragment: ["children"]
  });
  (0, import_estraverse.traverse)(ASTnode, opts);
}
function traverseReturns(ASTNode, onReturn) {
  const nodeType = ASTNode.type;
  if (nodeType === "ReturnStatement") {
    onReturn(ASTNode.argument, () => {
    });
    return;
  }
  if (nodeType === "ArrowFunctionExpression" && ASTNode.expression) {
    onReturn(ASTNode.body, () => {
    });
    return;
  }
  if (nodeType !== "FunctionExpression" && nodeType !== "FunctionDeclaration" && nodeType !== "ArrowFunctionExpression" && nodeType !== "MethodDefinition") return;
  traverse$1(ASTNode.body, { enter(node) {
    const breakTraverse = () => {
      this.break();
    };
    switch (node.type) {
      case "ReturnStatement":
        this.skip();
        onReturn(node.argument, breakTraverse);
        return;
      case "BlockStatement":
      case "IfStatement":
      case "ForStatement":
      case "WhileStatement":
      case "SwitchStatement":
      case "SwitchCase":
        return;
      default:
        this.skip();
    }
  } });
}
function getVariable(variables, name) {
  return variables.find((variable) => variable.name === name);
}
function variablesInScope(context) {
  let scope = context.getScope();
  let variables = scope.variables;
  while (scope.type !== "global") {
    scope = scope.upper;
    variables = scope.variables.concat(variables);
  }
  if (scope.childScopes.length) {
    variables = scope.childScopes[0].variables.concat(variables);
    if (scope.childScopes[0].childScopes.length) variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
  }
  variables.reverse();
  return variables;
}
function findVariableByName(context, name) {
  const variable = getVariable(variablesInScope(context), name);
  if (!variable || !variable.defs[0] || !variable.defs[0].node) return null;
  if (variable.defs[0].node.type === "TypeAlias") return variable.defs[0].node.right;
  if (variable.defs[0].type === "ImportBinding") return variable.defs[0].node;
  return variable.defs[0].node.init;
}
var COMPAT_TAG_REGEX = /^[a-z]/;
function isDOMComponent(node) {
  const name = getElementType(node);
  return COMPAT_TAG_REGEX.test(name);
}
function isJSX(node) {
  return node && ["JSXElement", "JSXFragment"].includes(node.type);
}
function isReturningJSX(ASTnode, context, strict = false, ignoreNull = false) {
  const isJSXValue = (node) => {
    if (!node) return false;
    switch (node.type) {
      case "ConditionalExpression":
        if (strict) return isJSXValue(node.consequent) && isJSXValue(node.alternate);
        return isJSXValue(node.consequent) || isJSXValue(node.alternate);
      case "LogicalExpression":
        if (strict) return isJSXValue(node.left) && isJSXValue(node.right);
        return isJSXValue(node.left) || isJSXValue(node.right);
      case "SequenceExpression":
        return isJSXValue(node.expressions[node.expressions.length - 1]);
      case "JSXElement":
      case "JSXFragment":
        return true;
      case "Literal":
        return !ignoreNull && node.value === null;
      case "Identifier":
        return isJSX(findVariableByName(context, node.name));
      default:
        return false;
    }
  };
  let found = false;
  traverseReturns(ASTnode, (node, breakTraverse) => {
    if (isJSXValue(node)) {
      found = true;
      breakTraverse();
    }
  });
  return found;
}
function getPropName(prop) {
  if (!prop.type || prop.type !== "JSXAttribute") throw new Error("The prop must be a JSXAttribute collected by the AST parser.");
  if (prop.name.type === "JSXNamespacedName") return `${prop.name.namespace.name}:${prop.name.name.name}`;
  return prop.name.name;
}
function resolveMemberExpressions(object, property) {
  if (object.type === "JSXMemberExpression") return `${resolveMemberExpressions(object.object, object.property)}.${property.name}`;
  return `${object.name}.${property.name}`;
}
function getElementType(node) {
  if (node.type === "JSXOpeningFragment") return "<>";
  const { name } = node;
  if (!name) throw new Error("The argument provided is not a JSXElement node.");
  if (name.type === "JSXMemberExpression") {
    const { object, property } = name;
    return resolveMemberExpressions(object, property);
  }
  if (name.type === "JSXNamespacedName") return `${name.namespace.name}:${name.name.name}`;
  return node.name.name;
}
var segmenter;
function isASCII(value) {
  return /^[\u0020-\u007F]*$/u.test(value);
}
function getStringLength(value) {
  if (isASCII(value)) return value.length;
  segmenter ??= new Intl.Segmenter();
  return [...segmenter.segment(value)].length;
}
var FixTracker = class {
  retainedRange;
  constructor(fixer, sourceCode) {
    this.fixer = fixer;
    this.sourceCode = sourceCode;
    this.retainedRange = null;
  }
  retainRange(range) {
    this.retainedRange = range;
    return this;
  }
  retainEnclosingFunction(node) {
    const functionNode = getUpperFunction(node);
    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
  }
  retainSurroundingTokens(nodeOrToken) {
    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
  }
  replaceTextRange(range, text) {
    let actualRange;
    if (this.retainedRange) actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];
    else actualRange = range;
    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
  }
  remove(nodeOrToken) {
    return this.replaceTextRange(nodeOrToken.range, "");
  }
};

// node_modules/@stylistic/eslint-plugin/dist/rules/array-bracket-newline.js
var array_bracket_newline_default = createRule({
  name: "array-bracket-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce linebreaks after opening and before closing array brackets" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: [
        "always",
        "never",
        "consistent"
      ]
    }, {
      type: "object",
      properties: {
        multiline: { type: "boolean" },
        minItems: {
          type: ["integer", "null"],
          minimum: 0
        }
      },
      additionalProperties: false
    }] }],
    defaultOptions: [],
    messages: {
      unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
      unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
      missingOpeningLinebreak: "A linebreak is required after '['.",
      missingClosingLinebreak: "A linebreak is required before ']'."
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function normalizeOptionValue2(option) {
      let consistent = false;
      let multiline = false;
      let minItems = 0;
      if (option) if (option === "consistent") {
        consistent = true;
        minItems = Number.POSITIVE_INFINITY;
      } else if (option === "always" || typeof option !== "string" && option.minItems === 0) minItems = 0;
      else if (option === "never") minItems = Number.POSITIVE_INFINITY;
      else {
        multiline = Boolean(option.multiline);
        minItems = option.minItems || Number.POSITIVE_INFINITY;
      }
      else {
        consistent = false;
        multiline = true;
        minItems = Number.POSITIVE_INFINITY;
      }
      return {
        consistent,
        multiline,
        minItems
      };
    }
    function normalizeOptions3(options) {
      const value = normalizeOptionValue2(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }
    function reportNoBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedOpeningLinebreak",
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
          if (!nextToken || (0, ast_exports.isCommentToken)(nextToken)) return null;
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }
    function reportNoEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedClosingLinebreak",
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });
          if (!previousToken || (0, ast_exports.isCommentToken)(previousToken)) return null;
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }
    function reportRequiredBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingOpeningLinebreak",
        fix(fixer) {
          return fixer.insertTextAfter(token, "\n");
        }
      });
    }
    function reportRequiredEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingClosingLinebreak",
        fix(fixer) {
          return fixer.insertTextBefore(token, "\n");
        }
      });
    }
    function check(node) {
      const elements = node.elements;
      const options = normalizeOptions3(context.options[0])[node.type];
      const openBracket = sourceCode.getFirstToken(node);
      const closeBracket = sourceCode.getLastToken(node);
      const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
      const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
      const first = sourceCode.getTokenAfter(openBracket);
      const last = sourceCode.getTokenBefore(closeBracket);
      if (elements.length >= options.minItems || options.multiline && elements.length > 0 && !(0, ast_exports.isTokenOnSameLine)(lastIncComment, firstIncComment) || elements.length === 0 && firstIncComment.type === "Block" && !(0, ast_exports.isTokenOnSameLine)(lastIncComment, firstIncComment) && firstIncComment === lastIncComment || options.consistent && !(0, ast_exports.isTokenOnSameLine)(openBracket, first)) {
        if ((0, ast_exports.isTokenOnSameLine)(openBracket, first)) reportRequiredBeginningLinebreak(node, openBracket);
        if ((0, ast_exports.isTokenOnSameLine)(last, closeBracket)) reportRequiredEndingLinebreak(node, closeBracket);
      } else {
        if (!(0, ast_exports.isTokenOnSameLine)(openBracket, first)) reportNoBeginningLinebreak(node, openBracket);
        if (!(0, ast_exports.isTokenOnSameLine)(last, closeBracket)) reportNoEndingLinebreak(node, closeBracket);
      }
    }
    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/array-bracket-spacing.js
var array_bracket_spacing_default = createRule({
  name: "array-bracket-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing inside array brackets" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        singleValue: { type: "boolean" },
        objectsInArrays: { type: "boolean" },
        arraysInArrays: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: ["never"],
    messages: {
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'."
    }
  },
  create(context, [style]) {
    const spaced = style === "always";
    const sourceCode = context.sourceCode;
    function isOptionSet(option) {
      return context.options[1] ? context.options[1][option] === !spaced : false;
    }
    const options = {
      spaced,
      singleElementException: isOptionSet("singleValue"),
      objectsInArraysException: isOptionSet("objectsInArrays"),
      arraysInArraysException: isOptionSet("arraysInArrays")
    };
    function reportNoBeginningSpace(node, token) {
      const nextToken = sourceCode.getTokenAfter(token);
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }
    function reportNoEndingSpace(node, token) {
      const previousToken = sourceCode.getTokenBefore(token);
      context.report({
        node,
        loc: {
          start: previousToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceAfter",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceBefore",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }
    function isObjectType(node) {
      return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
    }
    function isArrayType(node) {
      return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
    }
    function validateArraySpacing(node) {
      if (options.spaced && node.elements.length === 0) return;
      const first = sourceCode.getFirstToken(node);
      const second = sourceCode.getFirstToken(node, 1);
      const last = node.type === "ArrayPattern" && node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node);
      const penultimate = sourceCode.getTokenBefore(last);
      const firstElement = node.elements[0];
      const lastElement = node.elements[node.elements.length - 1];
      const openingBracketMustBeSpaced = firstElement && options.objectsInArraysException && isObjectType(firstElement) || firstElement && options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
      const closingBracketMustBeSpaced = lastElement && options.objectsInArraysException && isObjectType(lastElement) || lastElement && options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
      if ((0, ast_exports.isTokenOnSameLine)(first, second)) {
        if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetween(first, second)) reportRequiredBeginningSpace(node, first);
        if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetween(first, second)) reportNoBeginningSpace(node, first);
      }
      if (first !== penultimate && (0, ast_exports.isTokenOnSameLine)(penultimate, last)) {
        if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetween(penultimate, last)) reportRequiredEndingSpace(node, last);
        if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetween(penultimate, last)) reportNoEndingSpace(node, last);
      }
    }
    return {
      ArrayPattern: validateArraySpacing,
      ArrayExpression: validateArraySpacing
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/array-element-newline.js
var array_element_newline_default = createRule({
  name: "array-element-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce line breaks after each array element" },
    fixable: "whitespace",
    schema: {
      definitions: { basicConfig: { oneOf: [{
        type: "string",
        enum: [
          "always",
          "never",
          "consistent"
        ]
      }, {
        type: "object",
        properties: {
          consistent: { type: "boolean" },
          multiline: { type: "boolean" },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: false
      }] } },
      type: "array",
      items: [{ oneOf: [{ $ref: "#/definitions/basicConfig" }, {
        type: "object",
        properties: {
          ArrayExpression: { $ref: "#/definitions/basicConfig" },
          ArrayPattern: { $ref: "#/definitions/basicConfig" }
        },
        additionalProperties: false,
        minProperties: 1
      }] }]
    },
    defaultOptions: [],
    messages: {
      unexpectedLineBreak: "There should be no linebreak here.",
      missingLineBreak: "There should be a linebreak after this element."
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function normalizeOptionValue2(providedOption) {
      let consistent = false;
      let multiline = false;
      let minItems;
      const option = providedOption || "always";
      if (!option || option === "always" || typeof option === "object" && option.minItems === 0) minItems = 0;
      else if (option === "never") minItems = Number.POSITIVE_INFINITY;
      else if (option === "consistent") {
        consistent = true;
        minItems = Number.POSITIVE_INFINITY;
      } else {
        consistent = Boolean(option.consistent);
        multiline = Boolean(option.multiline);
        minItems = option.minItems || Number.POSITIVE_INFINITY;
      }
      return {
        consistent,
        multiline,
        minItems
      };
    }
    function normalizeOptions3(options) {
      if (options && (options.ArrayExpression || options.ArrayPattern)) {
        let expressionOptions, patternOptions;
        if (options.ArrayExpression) expressionOptions = normalizeOptionValue2(options.ArrayExpression);
        if (options.ArrayPattern) patternOptions = normalizeOptionValue2(options.ArrayPattern);
        return {
          ArrayExpression: expressionOptions,
          ArrayPattern: patternOptions
        };
      }
      const value = normalizeOptionValue2(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }
    function reportNoLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedLineBreak",
        fix(fixer) {
          if ((0, ast_exports.isCommentToken)(tokenBefore)) return null;
          if (!(0, ast_exports.isTokenOnSameLine)(tokenBefore, token)) return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });
          if ((0, ast_exports.isCommentToken)(twoTokensBefore)) return null;
          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
        }
      });
    }
    function reportRequiredLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "missingLineBreak",
        fix(fixer) {
          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
        }
      });
    }
    function check(node) {
      const elements = node.elements;
      const options = normalizeOptions3(context.options[0])[node.type];
      if (!options) return;
      let elementBreak = false;
      if (options.multiline) elementBreak = elements.some((element) => element !== null && !isSingleLine(element));
      let linebreaksCount = 0;
      for (let i = 0; i < node.elements.length; i++) {
        const element = node.elements[i];
        const previousElement = elements[i - 1];
        if (i === 0 || element === null || previousElement === null) continue;
        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, ast_exports.isCommaToken);
        if (!(0, ast_exports.isTokenOnSameLine)(sourceCode.getTokenBefore(commaToken), sourceCode.getTokenAfter(commaToken))) linebreaksCount++;
      }
      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
      elements.forEach((element, i) => {
        const previousElement = elements[i - 1];
        if (i === 0 || element === null || previousElement === null) return;
        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, ast_exports.isCommaToken);
        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
        if (needsLinebreaks) {
          if ((0, ast_exports.isTokenOnSameLine)(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) reportRequiredLineBreak(firstTokenOfCurrentElement);
        } else if (!(0, ast_exports.isTokenOnSameLine)(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) reportNoLineBreak(firstTokenOfCurrentElement);
      });
    }
    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/arrow-parens.js
function hasBlockBody(node) {
  return node.body.type === "BlockStatement";
}
var arrow_parens_default = createRule({
  name: "arrow-parens",
  meta: {
    type: "layout",
    docs: { description: "Require parentheses around arrow function arguments" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: ["always", "as-needed"]
    }, {
      type: "object",
      properties: { requireForBlockBody: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["always"],
    messages: {
      unexpectedParens: "Unexpected parentheses around single function argument.",
      expectedParens: "Expected parentheses around arrow function argument.",
      unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
      expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
    }
  },
  create(context, [style, options]) {
    const asNeeded = style === "as-needed";
    const requireForBlockBody = asNeeded && options?.requireForBlockBody === true;
    const sourceCode = context.sourceCode;
    function findOpeningParenOfParams(node) {
      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);
      if (tokenBeforeParams && (0, ast_exports.isOpeningParenToken)(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) return tokenBeforeParams;
      return null;
    }
    function getClosingParenOfParams(node) {
      return sourceCode.getTokenAfter(node.params[0], ast_exports.isClosingParenToken);
    }
    function hasCommentsInParensOfParams(node, openingParen) {
      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));
    }
    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {
      const expectedCount = node.async ? 1 : 0;
      return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;
    }
    return { "ArrowFunctionExpression[params.length=1]": function(node) {
      const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);
      const openingParen = findOpeningParenOfParams(node);
      const hasParens = openingParen !== null;
      const [param] = node.params;
      if (shouldHaveParens && !hasParens) context.report({
        node,
        messageId: requireForBlockBody ? "expectedParensBlock" : "expectedParens",
        loc: param.loc,
        *fix(fixer) {
          yield fixer.insertTextBefore(param, "(");
          yield fixer.insertTextAfter(param, ")");
        }
      });
      if (!shouldHaveParens && hasParens && param.type === "Identifier" && !param.optional && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) context.report({
        node,
        messageId: requireForBlockBody ? "unexpectedParensInline" : "unexpectedParens",
        loc: param.loc,
        *fix(fixer) {
          const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);
          const closingParen = getClosingParenOfParams(node);
          if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) yield fixer.insertTextBefore(openingParen, " ");
          yield fixer.removeRange([openingParen.range[0], param.range[0]]);
          yield fixer.removeRange([param.range[1], closingParen.range[1]]);
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/arrow-spacing.js
var arrow_spacing_default = createRule({
  name: "arrow-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before and after the arrow in arrow functions" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      before: true,
      after: true
    }],
    messages: {
      expectedBefore: "Missing space before =>.",
      unexpectedBefore: "Unexpected space before =>.",
      expectedAfter: "Missing space after =>.",
      unexpectedAfter: "Unexpected space after =>."
    }
  },
  create(context, [option]) {
    const sourceCode = context.sourceCode;
    function getArrow(node) {
      if (node.type === "ArrowFunctionExpression") return sourceCode.getTokenBefore(node.body, ast_exports.isArrowToken);
      else return sourceCode.getFirstToken(node.returnType, ast_exports.isArrowToken);
    }
    function spaces(node) {
      const arrowToken = getArrow(node);
      const beforeToken = sourceCode.getTokenBefore(arrowToken, { includeComments: true });
      const isSpacedBefore = sourceCode.isSpaceBetween(beforeToken, arrowToken);
      if (option.before) {
        if (!isSpacedBefore) context.report({
          node: beforeToken,
          messageId: "expectedBefore",
          fix(fixer) {
            return fixer.insertTextBefore(arrowToken, " ");
          }
        });
      } else if (isSpacedBefore) context.report({
        node: beforeToken,
        messageId: "unexpectedBefore",
        fix(fixer) {
          return fixer.removeRange([beforeToken.range[1], arrowToken.range[0]]);
        }
      });
      const afterToken = sourceCode.getTokenAfter(arrowToken, { includeComments: true });
      const isSpacedAfter = sourceCode.isSpaceBetween(arrowToken, afterToken);
      if (option.after) {
        if (!isSpacedAfter) context.report({
          node: afterToken,
          messageId: "expectedAfter",
          fix(fixer) {
            return fixer.insertTextAfter(arrowToken, " ");
          }
        });
      } else if (isSpacedAfter) context.report({
        node: afterToken,
        messageId: "unexpectedAfter",
        fix(fixer) {
          return fixer.removeRange([arrowToken.range[1], afterToken.range[0]]);
        }
      });
    }
    return {
      ArrowFunctionExpression: spaces,
      TSFunctionType: spaces,
      TSConstructorType: spaces
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/block-spacing.js
var block_spacing_default = createRule({
  name: "block-spacing",
  meta: {
    type: "layout",
    docs: { description: "Disallow or enforce spaces inside of blocks after opening block and before closing block" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["always"],
    messages: {
      missing: "Requires a space {{location}} '{{token}}'.",
      extra: "Unexpected space(s) {{location}} '{{token}}'."
    }
  },
  create(context, [whenToApplyOption]) {
    const sourceCode = context.sourceCode;
    const always = whenToApplyOption !== "never";
    const messageId = always ? "missing" : "extra";
    function getOpenBrace(node) {
      return sourceCode.getFirstToken(node, { filter: (token) => (0, ast_exports.isOpeningBraceToken)(token) });
    }
    function isValid(left, right) {
      return !(0, ast_exports.isTokenOnSameLine)(left, right) || sourceCode.isSpaceBetween(left, right) === always;
    }
    function checkSpacingInsideBraces(node) {
      const openBrace = getOpenBrace(node);
      const closeBrace = sourceCode.getLastToken(node);
      const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });
      const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
      if (!(0, ast_exports.isOpeningBraceToken)(openBrace) || !(0, ast_exports.isClosingBraceToken)(closeBrace) || firstToken === closeBrace) return;
      if (!always && firstToken.type === import_types.AST_TOKEN_TYPES.Line) return;
      if (!isValid(openBrace, firstToken)) {
        let loc = openBrace.loc;
        if (messageId === "extra") loc = {
          start: openBrace.loc.end,
          end: firstToken.loc.start
        };
        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "after",
            token: openBrace.value
          },
          fix(fixer) {
            if (always) return fixer.insertTextBefore(firstToken, " ");
            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
          }
        });
      }
      if (!isValid(lastToken, closeBrace)) {
        let loc = closeBrace.loc;
        if (messageId === "extra") loc = {
          start: lastToken.loc.end,
          end: closeBrace.loc.start
        };
        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "before",
            token: closeBrace.value
          },
          fix(fixer) {
            if (always) return fixer.insertTextAfter(lastToken, " ");
            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
          }
        });
      }
    }
    return {
      BlockStatement: checkSpacingInsideBraces,
      StaticBlock: checkSpacingInsideBraces,
      SwitchStatement: checkSpacingInsideBraces
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/brace-style.js
var brace_style_default = createRule({
  name: "brace-style",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent brace style for blocks" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: [
        "1tbs",
        "stroustrup",
        "allman"
      ]
    }, {
      type: "object",
      properties: { allowSingleLine: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["1tbs", { allowSingleLine: false }],
    messages: {
      nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
      sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
      blockSameLine: "Statement inside of curly braces should be on next line.",
      nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
      singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
      sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
    }
  },
  create(context, [style, options]) {
    const sourceCode = context.sourceCode;
    const { allowSingleLine } = options;
    const isAllmanStyle = style === "allman";
    function validateCurlyPair(openingCurlyToken, closingCurlyToken) {
      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurlyToken);
      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurlyToken);
      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurlyToken);
      const singleLineException = allowSingleLine && (0, ast_exports.isTokenOnSameLine)(openingCurlyToken, closingCurlyToken);
      if (!isAllmanStyle && !(0, ast_exports.isTokenOnSameLine)(tokenBeforeOpeningCurly, openingCurlyToken)) context.report({
        node: openingCurlyToken,
        messageId: "nextLineOpen",
        fix: safeReplaceTextBetween(sourceCode, tokenBeforeOpeningCurly, openingCurlyToken, " ")
      });
      if (isAllmanStyle && (0, ast_exports.isTokenOnSameLine)(tokenBeforeOpeningCurly, openingCurlyToken) && !singleLineException) context.report({
        node: openingCurlyToken,
        messageId: "sameLineOpen",
        fix: (fixer) => fixer.insertTextBefore(openingCurlyToken, "\n")
      });
      if ((0, ast_exports.isTokenOnSameLine)(openingCurlyToken, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurlyToken && !singleLineException) context.report({
        node: openingCurlyToken,
        messageId: "blockSameLine",
        fix: (fixer) => fixer.insertTextAfter(openingCurlyToken, "\n")
      });
      if ((0, ast_exports.isTokenOnSameLine)(tokenBeforeClosingCurly, closingCurlyToken) && tokenBeforeClosingCurly !== openingCurlyToken && !singleLineException) context.report({
        node: closingCurlyToken,
        messageId: "singleLineClose",
        fix: (fixer) => fixer.insertTextBefore(closingCurlyToken, "\n")
      });
    }
    function validateCurlyBeforeKeyword(curlyToken) {
      const keywordToken = sourceCode.getTokenAfter(curlyToken);
      if (style === "1tbs" && !(0, ast_exports.isTokenOnSameLine)(curlyToken, keywordToken)) context.report({
        node: curlyToken,
        messageId: "nextLineClose",
        fix: safeReplaceTextBetween(sourceCode, curlyToken, keywordToken, " ")
      });
      if (style !== "1tbs" && (0, ast_exports.isTokenOnSameLine)(curlyToken, keywordToken)) context.report({
        node: curlyToken,
        messageId: "sameLineClose",
        fix: (fixer) => fixer.insertTextAfter(curlyToken, "\n")
      });
    }
    return {
      BlockStatement(node) {
        if (!STATEMENT_LIST_PARENTS.has(node.parent.type)) validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      },
      StaticBlock(node) {
        validateCurlyPair(sourceCode.getFirstToken(node, { skip: 1 }), sourceCode.getLastToken(node));
      },
      ClassBody(node) {
        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      },
      SwitchStatement(node) {
        const closingCurly = sourceCode.getLastToken(node);
        validateCurlyPair(sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly), closingCurly);
      },
      IfStatement(node) {
        if (node.consequent.type === "BlockStatement" && node.alternate) validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
      },
      TryStatement(node) {
        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));
        if (node.handler && node.finalizer) validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
      },
      TSModuleBlock(node) {
        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/comma-dangle.js
var OPTION_VALUE_SCHEME = [
  "always-multiline",
  "always",
  "never",
  "only-multiline"
];
var comma_dangle_default = createRule({
  name: "comma-dangle",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow trailing commas" },
    fixable: "code",
    schema: {
      $defs: {
        value: {
          type: "string",
          enum: OPTION_VALUE_SCHEME
        },
        valueWithIgnore: {
          type: "string",
          enum: [...OPTION_VALUE_SCHEME, "ignore"]
        }
      },
      type: "array",
      items: [{ oneOf: [{ $ref: "#/$defs/value" }, {
        type: "object",
        properties: {
          arrays: { $ref: "#/$defs/valueWithIgnore" },
          objects: { $ref: "#/$defs/valueWithIgnore" },
          imports: { $ref: "#/$defs/valueWithIgnore" },
          exports: { $ref: "#/$defs/valueWithIgnore" },
          functions: { $ref: "#/$defs/valueWithIgnore" },
          importAttributes: { $ref: "#/$defs/valueWithIgnore" },
          dynamicImports: { $ref: "#/$defs/valueWithIgnore" },
          enums: { $ref: "#/$defs/valueWithIgnore" },
          generics: { $ref: "#/$defs/valueWithIgnore" },
          tuples: { $ref: "#/$defs/valueWithIgnore" }
        },
        additionalProperties: false
      }] }],
      additionalItems: false
    },
    defaultOptions: ["never"],
    messages: {
      unexpected: "Unexpected trailing comma.",
      missing: "Missing trailing comma."
    }
  },
  create(context, [options]) {
    function normalizeOptions3(options2 = {}, ecmaVersion) {
      const DEFAULT_OPTION_VALUE = "never";
      if (typeof options2 === "string") return {
        arrays: options2,
        objects: options2,
        imports: options2,
        exports: options2,
        functions: !ecmaVersion || ecmaVersion === "latest" ? options2 : ecmaVersion < 2017 ? "ignore" : options2,
        importAttributes: options2,
        dynamicImports: !ecmaVersion || ecmaVersion === "latest" ? options2 : ecmaVersion < 2025 ? "ignore" : options2,
        enums: options2,
        generics: options2,
        tuples: options2
      };
      return {
        arrays: options2.arrays ?? DEFAULT_OPTION_VALUE,
        objects: options2.objects ?? DEFAULT_OPTION_VALUE,
        imports: options2.imports ?? DEFAULT_OPTION_VALUE,
        exports: options2.exports ?? DEFAULT_OPTION_VALUE,
        functions: options2.functions ?? DEFAULT_OPTION_VALUE,
        importAttributes: options2.importAttributes ?? DEFAULT_OPTION_VALUE,
        dynamicImports: options2.dynamicImports ?? DEFAULT_OPTION_VALUE,
        enums: options2.enums ?? DEFAULT_OPTION_VALUE,
        generics: options2.generics ?? DEFAULT_OPTION_VALUE,
        tuples: options2.tuples ?? DEFAULT_OPTION_VALUE
      };
    }
    const normalizedOptions = normalizeOptions3(options, context?.languageOptions?.ecmaVersion ?? context.parserOptions.ecmaVersion);
    const isTSX = context.parserOptions?.ecmaFeatures?.jsx && context.filename?.endsWith(".tsx");
    const sourceCode = context.sourceCode;
    const closeBraces = [
      "}",
      "]",
      ")",
      ">"
    ];
    const predicate = {
      "always": forceTrailingComma,
      "always-multiline": forceTrailingCommaIfMultiline,
      "only-multiline": allowTrailingCommaIfMultiline,
      "never": forbidTrailingComma,
      "ignore": () => {
      }
    };
    function last(nodes) {
      if (!nodes) return null;
      return nodes[nodes.length - 1] ?? null;
    }
    function getTrailingToken(info) {
      switch (info.node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "CallExpression":
        case "NewExpression":
        case "ImportExpression":
          return sourceCode.getLastToken(info.node, 1);
        default: {
          const lastItem = info.lastItem;
          if (!lastItem) return null;
          const nextToken = sourceCode.getTokenAfter(lastItem);
          if ((0, ast_exports.isCommaToken)(nextToken)) return nextToken;
          return sourceCode.getLastToken(lastItem);
        }
      }
    }
    function isMultiline(info) {
      if (!info.lastItem) return false;
      const penultimateToken = getTrailingToken(info);
      if (!penultimateToken) return false;
      const lastToken = sourceCode.getTokenAfter(penultimateToken);
      if (!lastToken) return false;
      return lastToken.loc.end.line !== penultimateToken.loc.end.line;
    }
    function isTrailingCommaAllowed(lastItem) {
      return lastItem.type !== "RestElement";
    }
    function forbidTrailingComma(info) {
      if (isTSX && info.node.type === import_types.AST_NODE_TYPES.TSTypeParameterDeclaration && info.node.params.length === 1) return;
      const lastItem = info.lastItem;
      if (!lastItem) return;
      const trailingToken = getTrailingToken(info);
      if (trailingToken && (0, ast_exports.isCommaToken)(trailingToken)) context.report({
        node: lastItem,
        loc: trailingToken.loc,
        messageId: "unexpected",
        *fix(fixer) {
          yield fixer.remove(trailingToken);
          yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), "");
          yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), "");
        }
      });
    }
    function forceTrailingComma(info) {
      const lastItem = info.lastItem;
      if (!lastItem) return;
      if (!isTrailingCommaAllowed(lastItem)) {
        forbidTrailingComma(info);
        return;
      }
      const trailingToken = getTrailingToken(info);
      if (!trailingToken || trailingToken.value === ",") return;
      const nextToken = sourceCode.getTokenAfter(trailingToken);
      if (!nextToken || !closeBraces.includes(nextToken.value)) return;
      context.report({
        node: lastItem,
        loc: {
          start: trailingToken.loc.end,
          end: getNextLocation(sourceCode, trailingToken.loc.end)
        },
        messageId: "missing",
        *fix(fixer) {
          yield fixer.insertTextAfter(trailingToken, ",");
          yield fixer.insertTextBefore(trailingToken, "");
          yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), "");
        }
      });
    }
    function allowTrailingCommaIfMultiline(info) {
      if (!isMultiline(info)) forbidTrailingComma(info);
    }
    function forceTrailingCommaIfMultiline(info) {
      if (isMultiline(info)) forceTrailingComma(info);
      else forbidTrailingComma(info);
    }
    return {
      ObjectExpression: (node) => {
        predicate[normalizedOptions.objects]({
          node,
          lastItem: last(node.properties)
        });
      },
      ObjectPattern: (node) => {
        predicate[normalizedOptions.objects]({
          node,
          lastItem: last(node.properties)
        });
      },
      ArrayExpression: (node) => {
        predicate[normalizedOptions.arrays]({
          node,
          lastItem: last(node.elements)
        });
      },
      ArrayPattern: (node) => {
        predicate[normalizedOptions.arrays]({
          node,
          lastItem: last(node.elements)
        });
      },
      ImportDeclaration: (node) => {
        const lastSpecifier = last(node.specifiers);
        if (lastSpecifier?.type === "ImportSpecifier") predicate[normalizedOptions.imports]({
          node,
          lastItem: lastSpecifier
        });
        predicate[normalizedOptions.importAttributes]({
          node,
          lastItem: last(node.attributes)
        });
      },
      ExportNamedDeclaration: (node) => {
        predicate[normalizedOptions.exports]({
          node,
          lastItem: last(node.specifiers)
        });
        predicate[normalizedOptions.importAttributes]({
          node,
          lastItem: last(node.attributes)
        });
      },
      ExportAllDeclaration: (node) => {
        predicate[normalizedOptions.importAttributes]({
          node,
          lastItem: last(node.attributes)
        });
      },
      FunctionDeclaration: (node) => {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.params)
        });
      },
      FunctionExpression: (node) => {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.params)
        });
      },
      ArrowFunctionExpression: (node) => {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.params)
        });
      },
      CallExpression: (node) => {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.arguments)
        });
      },
      NewExpression: (node) => {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.arguments)
        });
      },
      ImportExpression: (node) => {
        predicate[normalizedOptions.dynamicImports]({
          node,
          lastItem: node.options ?? node.source
        });
      },
      TSEnumDeclaration(node) {
        predicate[normalizedOptions.enums]({
          node,
          lastItem: last(node.body?.members ?? node.members)
        });
      },
      TSTypeParameterDeclaration(node) {
        predicate[normalizedOptions.generics]({
          node,
          lastItem: last(node.params)
        });
      },
      TSTypeParameterInstantiation(node) {
        predicate.never({
          node,
          lastItem: last(node.params)
        });
      },
      TSTupleType(node) {
        predicate[normalizedOptions.tuples]({
          node,
          lastItem: last(node.elementTypes)
        });
      },
      TSDeclareFunction(node) {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.params)
        });
      },
      TSFunctionType(node) {
        predicate[normalizedOptions.functions]({
          node,
          lastItem: last(node.params)
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/comma-spacing.js
var comma_spacing_default = createRule({
  name: "comma-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before and after commas" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      before: false,
      after: true
    }],
    messages: {
      unexpected: `There should be no space {{loc}} ','.`,
      missing: `A space is required {{loc}} ','.`
    }
  },
  create(context, [options]) {
    const { before: spaceBefore, after: spaceAfter } = options;
    const sourceCode = context.sourceCode;
    const tokensAndComments = sourceCode.tokensAndComments;
    const ignoredTokens = /* @__PURE__ */ new Set();
    function addNullElementsToIgnoreList(node) {
      let previousToken = sourceCode.getFirstToken(node);
      for (const element of node.elements) {
        let token;
        if (element == null) {
          token = sourceCode.getTokenAfter(previousToken);
          if (token && (0, ast_exports.isCommaToken)(token)) ignoredTokens.add(token);
        } else token = sourceCode.getTokenAfter(element);
        previousToken = token;
      }
    }
    function addTypeParametersTrailingCommaToIgnoreList(node) {
      const paramLength = node.params.length;
      if (paramLength) {
        const param = node.params[paramLength - 1];
        const afterToken = sourceCode.getTokenAfter(param);
        if (afterToken && (0, ast_exports.isCommaToken)(afterToken)) ignoredTokens.add(afterToken);
      }
    }
    function validateCommaSpacing(commaToken, prevToken, nextToken) {
      if (prevToken && (0, ast_exports.isTokenOnSameLine)(prevToken, commaToken) && spaceBefore !== sourceCode.isSpaceBetween(prevToken, commaToken)) context.report({
        node: commaToken,
        data: { loc: "before" },
        messageId: spaceBefore ? "missing" : "unexpected",
        fix: (fixer) => spaceBefore ? fixer.insertTextBefore(commaToken, " ") : fixer.replaceTextRange([prevToken.range[1], commaToken.range[0]], "")
      });
      if (nextToken && (0, ast_exports.isTokenOnSameLine)(commaToken, nextToken) && !(0, ast_exports.isClosingParenToken)(nextToken) && !(0, ast_exports.isClosingBracketToken)(nextToken) && !(0, ast_exports.isClosingBraceToken)(nextToken) && !(!spaceAfter && nextToken.type === import_types.AST_TOKEN_TYPES.Line) && spaceAfter !== sourceCode.isSpaceBetween(commaToken, nextToken)) context.report({
        node: commaToken,
        data: { loc: "after" },
        messageId: spaceAfter ? "missing" : "unexpected",
        fix: (fixer) => spaceAfter ? fixer.insertTextAfter(commaToken, " ") : fixer.replaceTextRange([commaToken.range[1], nextToken.range[0]], "")
      });
    }
    return {
      "ArrayExpression": addNullElementsToIgnoreList,
      "ArrayPattern": addNullElementsToIgnoreList,
      "TSTypeParameterDeclaration": addTypeParametersTrailingCommaToIgnoreList,
      "Program:exit": function() {
        tokensAndComments.forEach((token, i) => {
          if (!(0, ast_exports.isCommaToken)(token)) return;
          const prevToken = tokensAndComments[i - 1];
          const nextToken = tokensAndComments[i + 1];
          validateCommaSpacing(token, (0, ast_exports.isCommaToken)(prevToken) || ignoredTokens.has(token) ? null : prevToken, nextToken && (0, ast_exports.isCommaToken)(nextToken) || ignoredTokens.has(token) ? null : nextToken);
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/comma-style.js
var comma_style_default = createRule({
  name: "comma-style",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent comma style" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: ["first", "last"]
    }, {
      type: "object",
      properties: { exceptions: {
        type: "object",
        additionalProperties: { type: "boolean" }
      } },
      additionalProperties: false
    }],
    defaultOptions: ["last"],
    messages: {
      unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
      expectedCommaFirst: "',' should be placed first.",
      expectedCommaLast: "',' should be placed last."
    }
  },
  create(context, [style, options]) {
    const sourceCode = context.sourceCode;
    const exceptions = options?.exceptions ?? {};
    function getReplacedText(styleType, text) {
      switch (styleType) {
        case "between":
          return `,${text.replace(ast_exports.LINEBREAK_MATCHER, "")}`;
        case "first":
          return `${text},`;
        case "last":
          return `,${text}`;
        default:
          return "";
      }
    }
    function getFixerFunction(styleType, tokenBeforeComma, commaToken, tokenAfterComma) {
      const text = sourceCode.text.slice(tokenBeforeComma.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], tokenAfterComma.range[0]);
      const range = [tokenBeforeComma.range[1], tokenAfterComma.range[0]];
      return function(fixer) {
        return fixer.replaceTextRange(range, getReplacedText(styleType, text));
      };
    }
    function validateCommaItemSpacing(tokenBeforeComma, commaToken, tokenAfterComma) {
      if ((0, ast_exports.isTokenOnSameLine)(commaToken, tokenAfterComma) && (0, ast_exports.isTokenOnSameLine)(tokenBeforeComma, commaToken)) {
      } else if (!(0, ast_exports.isTokenOnSameLine)(commaToken, tokenAfterComma) && !(0, ast_exports.isTokenOnSameLine)(tokenBeforeComma, commaToken)) {
        const comment = sourceCode.getCommentsAfter(commaToken)[0];
        const styleType = comment && comment.type === "Block" && (0, ast_exports.isTokenOnSameLine)(commaToken, comment) ? style : "between";
        context.report({
          node: commaToken,
          messageId: "unexpectedLineBeforeAndAfterComma",
          fix: getFixerFunction(styleType, tokenBeforeComma, commaToken, tokenAfterComma)
        });
      } else if (style === "first" && !(0, ast_exports.isTokenOnSameLine)(commaToken, tokenAfterComma)) context.report({
        node: commaToken,
        messageId: "expectedCommaFirst",
        fix: getFixerFunction(style, tokenBeforeComma, commaToken, tokenAfterComma)
      });
      else if (style === "last" && (0, ast_exports.isTokenOnSameLine)(commaToken, tokenAfterComma)) context.report({
        node: commaToken,
        messageId: "expectedCommaLast",
        fix: getFixerFunction(style, tokenBeforeComma, commaToken, tokenAfterComma)
      });
    }
    function extractCommaTokens(node, items) {
      if (items.length === 0) return [];
      const definedItems = items.filter((item) => Boolean(item));
      if (definedItems.length === 0) return sourceCode.getTokens(node).filter(ast_exports.isCommaToken);
      const commaTokens = [];
      const firstItem = definedItems[0];
      let prevToken = sourceCode.getTokenBefore(firstItem);
      while (prevToken && node.range[0] <= prevToken.range[0]) {
        if ((0, ast_exports.isCommaToken)(prevToken)) commaTokens.unshift(prevToken);
        else if ((0, ast_exports.isNotOpeningParenToken)(prevToken)) break;
        prevToken = sourceCode.getTokenBefore(prevToken);
      }
      let prevItem = null;
      for (const item of definedItems) {
        if (prevItem) commaTokens.push(...sourceCode.getTokensBetween(prevItem, item).filter(ast_exports.isCommaToken));
        const tokenLastItem = sourceCode.getLastToken(item);
        if (tokenLastItem && (0, ast_exports.isCommaToken)(tokenLastItem)) commaTokens.push(tokenLastItem);
        prevItem = item;
      }
      let nextToken = sourceCode.getTokenAfter(prevItem);
      while (nextToken && nextToken.range[1] <= node.range[1]) {
        if ((0, ast_exports.isCommaToken)(nextToken)) commaTokens.push(nextToken);
        else if ((0, ast_exports.isNotClosingParenToken)(nextToken)) break;
        nextToken = sourceCode.getTokenAfter(nextToken);
      }
      return commaTokens;
    }
    function validateComma(node, items) {
      extractCommaTokens(node, items).forEach((commaToken) => {
        const tokenBeforeComma = sourceCode.getTokenBefore(commaToken);
        const tokenAfterComma = sourceCode.getTokenAfter(commaToken);
        if ((0, ast_exports.isOpeningBracketToken)(tokenBeforeComma)) return;
        if ((0, ast_exports.isCommaToken)(tokenBeforeComma) && (0, ast_exports.isOpeningBracketToken)(sourceCode.getTokenBefore(tokenBeforeComma, ast_exports.isNotCommaToken))) return;
        if ((0, ast_exports.isCommaToken)(tokenAfterComma) && !(0, ast_exports.isTokenOnSameLine)(commaToken, tokenAfterComma)) return;
        validateCommaItemSpacing(tokenBeforeComma, commaToken, tokenAfterComma);
      });
    }
    const nodes = {};
    if (!exceptions.VariableDeclaration) nodes.VariableDeclaration = (node) => validateComma(node, node.declarations);
    if (!exceptions.ObjectExpression) nodes.ObjectExpression = validateObjectProperties;
    if (!exceptions.ObjectPattern) nodes.ObjectPattern = validateObjectProperties;
    if (!exceptions.ArrayExpression) nodes.ArrayExpression = validateArrayElements;
    if (!exceptions.ArrayPattern) nodes.ArrayPattern = validateArrayElements;
    if (!exceptions.FunctionDeclaration) nodes.FunctionDeclaration = validateFunctionParams;
    if (!exceptions.FunctionExpression) nodes.FunctionExpression = validateFunctionParams;
    if (!exceptions.ArrowFunctionExpression) nodes.ArrowFunctionExpression = validateFunctionParams;
    if (!exceptions.CallExpression) nodes.CallExpression = validateCallArguments;
    if (!exceptions.ImportDeclaration) nodes.ImportDeclaration = (node) => {
      validateComma(node, node.specifiers);
      visitImportAttributes(node);
    };
    if (!exceptions.NewExpression) nodes.NewExpression = validateCallArguments;
    if (!exceptions.ExportAllDeclaration) nodes.ExportAllDeclaration = visitImportAttributes;
    if (!exceptions.ExportNamedDeclaration) nodes.ExportNamedDeclaration = (node) => {
      validateComma(node, node.specifiers);
      visitImportAttributes(node);
    };
    if (!exceptions.ImportExpression) nodes.ImportExpression = (node) => {
      validateComma(node, [node.source, node.options ?? null]);
    };
    if (!exceptions.SequenceExpression) nodes.SequenceExpression = (node) => validateComma(node, node.expressions);
    if (!exceptions.ClassDeclaration) nodes.ClassDeclaration = visitClassImplements;
    if (!exceptions.ClassExpression) nodes.ClassExpression = visitClassImplements;
    if (!exceptions.TSDeclareFunction) nodes.TSDeclareFunction = validateFunctionParams;
    if (!exceptions.TSFunctionType) nodes.TSFunctionType = validateFunctionParams;
    if (!exceptions.TSConstructorType) nodes.TSConstructorType = validateFunctionParams;
    if (!exceptions.TSEmptyBodyFunctionExpression) nodes.TSEmptyBodyFunctionExpression = validateFunctionParams;
    if (!exceptions.TSMethodSignature) nodes.TSMethodSignature = validateFunctionParams;
    if (!exceptions.TSCallSignatureDeclaration) nodes.TSCallSignatureDeclaration = validateFunctionParams;
    if (!exceptions.TSConstructSignatureDeclaration) nodes.TSConstructSignatureDeclaration = validateFunctionParams;
    if (!exceptions.TSTypeParameterDeclaration) nodes.TSTypeParameterDeclaration = validateTypeParams;
    if (!exceptions.TSTypeParameterInstantiation) nodes.TSTypeParameterInstantiation = validateTypeParams;
    if (!exceptions.TSEnumBody) nodes.TSEnumBody = visitMembers;
    if (!exceptions.TSTypeLiteral) nodes.TSTypeLiteral = visitMembers;
    if (!exceptions.TSIndexSignature) nodes.TSIndexSignature = (node) => validateComma(node, node.parameters);
    if (!exceptions.TSInterfaceDeclaration) nodes.TSInterfaceDeclaration = (node) => validateComma(node, node.extends);
    if (!exceptions.TSInterfaceBody) nodes.TSInterfaceBody = (node) => validateComma(node, node.body);
    if (!exceptions.TSTupleType) nodes.TSTupleType = (node) => validateComma(node, node.elementTypes);
    return nodes;
    function validateObjectProperties(node) {
      validateComma(node, node.properties);
    }
    function validateArrayElements(node) {
      validateComma(node, node.elements);
    }
    function validateFunctionParams(node) {
      validateComma(node, node.params);
    }
    function validateCallArguments(node) {
      validateComma(node, node.arguments);
    }
    function visitImportAttributes(node) {
      if (!node.attributes) return;
      validateComma(node, node.attributes);
    }
    function visitClassImplements(node) {
      if (!node.implements) return;
      validateComma(node, node.implements);
    }
    function visitMembers(node) {
      validateComma(node, node.members);
    }
    function validateTypeParams(node) {
      validateComma(node, node.params);
    }
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/computed-property-spacing.js
var computed_property_spacing_default = createRule({
  name: "computed-property-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing inside computed property brackets" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: { enforceForClassMembers: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["never", { enforceForClassMembers: true }],
    messages: {
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'."
    }
  },
  create(context, [style, options]) {
    const sourceCode = context.sourceCode;
    const propertyNameMustBeSpaced = style === "always";
    const { enforceForClassMembers } = options;
    function reportNoBeginningSpace(node, token, tokenAfter) {
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: tokenAfter.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
        }
      });
    }
    function reportNoEndingSpace(node, token, tokenBefore) {
      context.report({
        node,
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
        }
      });
    }
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceAfter",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingSpaceBefore",
        data: { tokenValue: token.value },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }
    function checkSpacing(propertyName) {
      return function(node) {
        if (node.type !== "TSIndexedAccessType" && !node.computed) return;
        const property = node[propertyName];
        const before = sourceCode.getTokenBefore(property, ast_exports.isOpeningBracketToken);
        const first = sourceCode.getTokenAfter(before, { includeComments: true });
        const after = sourceCode.getTokenAfter(property, ast_exports.isClosingBracketToken);
        const last = sourceCode.getTokenBefore(after, { includeComments: true });
        if ((0, ast_exports.isTokenOnSameLine)(before, first)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetween(before, first) && (0, ast_exports.isTokenOnSameLine)(before, first)) reportRequiredBeginningSpace(node, before);
          } else if (sourceCode.isSpaceBetween(before, first)) reportNoBeginningSpace(node, before, first);
        }
        if ((0, ast_exports.isTokenOnSameLine)(last, after)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetween(last, after) && (0, ast_exports.isTokenOnSameLine)(last, after)) reportRequiredEndingSpace(node, after);
          } else if (sourceCode.isSpaceBetween(last, after)) reportNoEndingSpace(node, after, last);
        }
      };
    }
    const listeners = {
      Property: checkSpacing("key"),
      MemberExpression: checkSpacing("property"),
      TSIndexedAccessType: checkSpacing("indexType")
    };
    if (enforceForClassMembers) {
      listeners.MethodDefinition = checkSpacing("key");
      listeners.PropertyDefinition = checkSpacing("key");
      listeners.AccessorProperty = checkSpacing("key");
    }
    return listeners;
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/curly-newline.js
var commonProperties = {
  multiline: { type: "boolean" },
  minElements: {
    type: "integer",
    minimum: 0
  },
  consistent: { type: "boolean" }
};
var optionValueSchema = { oneOf: [{
  type: "string",
  enum: ["always", "never"]
}, {
  type: "object",
  properties: commonProperties,
  additionalProperties: false
}] };
var Specialization = /* @__PURE__ */ (function(Specialization2) {
  Specialization2["IfStatementConsequent"] = "IfStatementConsequent";
  Specialization2["IfStatementAlternative"] = "IfStatementAlternative";
  Specialization2["DoWhileStatement"] = "DoWhileStatement";
  Specialization2["ForInStatement"] = "ForInStatement";
  Specialization2["ForOfStatement"] = "ForOfStatement";
  Specialization2["ForStatement"] = "ForStatement";
  Specialization2["WhileStatement"] = "WhileStatement";
  Specialization2["SwitchStatement"] = "SwitchStatement";
  Specialization2["SwitchCase"] = "SwitchCase";
  Specialization2["TryStatementBlock"] = "TryStatementBlock";
  Specialization2["TryStatementHandler"] = "TryStatementHandler";
  Specialization2["TryStatementFinalizer"] = "TryStatementFinalizer";
  Specialization2["BlockStatement"] = "BlockStatement";
  Specialization2["ArrowFunctionExpression"] = "ArrowFunctionExpression";
  Specialization2["FunctionDeclaration"] = "FunctionDeclaration";
  Specialization2["FunctionExpression"] = "FunctionExpression";
  Specialization2["Property"] = "Property";
  Specialization2["ClassBody"] = "ClassBody";
  Specialization2["StaticBlock"] = "StaticBlock";
  Specialization2["WithStatement"] = "WithStatement";
  Specialization2["TSModuleBlock"] = "TSModuleBlock";
  return Specialization2;
})(Specialization || {});
var presets = {
  default: {
    multiline: false,
    minElements: Number.POSITIVE_INFINITY,
    consistent: true
  },
  always: {
    multiline: false,
    minElements: 0,
    consistent: false
  },
  never: {
    multiline: false,
    minElements: Number.POSITIVE_INFINITY,
    consistent: false
  }
};
function normalizeOptionValue(value) {
  if (value === "always") return presets.always;
  if (value === "never") return presets.never;
  if (value) return {
    consistent: !!value.consistent,
    minElements: value.minElements ?? Number.POSITIVE_INFINITY,
    multiline: !!value.multiline
  };
  return presets.default;
}
function normalizeOptions2(options) {
  const value = normalizeOptionValue(options);
  return Object.fromEntries(Object.entries(Specialization).map(([k]) => [k, typeof options === "object" && options != null && k in options ? normalizeOptionValue(options[k]) : value]));
}
var curly_newline_default = createRule({
  name: "curly-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent line breaks after opening and before closing braces" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        ...Object.fromEntries(Object.entries(Specialization).map(([k]) => [k, optionValueSchema])),
        ...commonProperties
      },
      additionalProperties: false
    }] }],
    defaultOptions: [],
    messages: {
      unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
      unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
      expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
      expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const normalizedOptions = normalizeOptions2(options);
    function check(node, specialization) {
      const options2 = normalizedOptions[specialization];
      let openBrace;
      let closeBrace;
      let elementCount;
      switch (node.type) {
        case "SwitchStatement":
          closeBrace = sourceCode.getLastToken(node);
          openBrace = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closeBrace);
          elementCount = node.cases.length;
          break;
        case "StaticBlock":
          openBrace = sourceCode.getFirstToken(node, (token) => token.value === "{");
          closeBrace = sourceCode.getLastToken(node);
          elementCount = node.body.length;
          break;
        default:
          openBrace = sourceCode.getFirstToken(node);
          closeBrace = sourceCode.getLastToken(node);
          elementCount = node.body.length;
      }
      let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
      let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
      const needsLineBreaks = elementCount >= options2.minElements || options2.multiline && elementCount > 0 && !(0, ast_exports.isTokenOnSameLine)(last, first);
      const hasCommentsFirstToken = (0, ast_exports.isCommentToken)(first);
      const hasCommentsLastToken = (0, ast_exports.isCommentToken)(last);
      first = sourceCode.getTokenAfter(openBrace);
      last = sourceCode.getTokenBefore(closeBrace);
      if (needsLineBreaks) {
        if ((0, ast_exports.isTokenOnSameLine)(openBrace, first)) context.report({
          messageId: "expectedLinebreakAfterOpeningBrace",
          node,
          loc: openBrace.loc,
          fix(fixer) {
            if (hasCommentsFirstToken) return null;
            return fixer.insertTextAfter(openBrace, "\n");
          }
        });
        if ((0, ast_exports.isTokenOnSameLine)(last, closeBrace)) context.report({
          messageId: "expectedLinebreakBeforeClosingBrace",
          node,
          loc: closeBrace.loc,
          fix(fixer) {
            if (hasCommentsLastToken) return null;
            return fixer.insertTextBefore(closeBrace, "\n");
          }
        });
      } else {
        const consistent = options2.consistent;
        const hasLineBreakBetweenOpenBraceAndFirst = !(0, ast_exports.isTokenOnSameLine)(openBrace, first);
        const hasLineBreakBetweenCloseBraceAndLast = !(0, ast_exports.isTokenOnSameLine)(last, closeBrace);
        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) context.report({
          messageId: "unexpectedLinebreakAfterOpeningBrace",
          node,
          loc: openBrace.loc,
          fix(fixer) {
            if (hasCommentsFirstToken) return null;
            return fixer.removeRange([openBrace.range[1], first.range[0]]);
          }
        });
        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) context.report({
          messageId: "unexpectedLinebreakBeforeClosingBrace",
          node,
          loc: closeBrace.loc,
          fix(fixer) {
            if (hasCommentsLastToken) return null;
            return fixer.removeRange([last.range[1], closeBrace.range[0]]);
          }
        });
      }
    }
    function checkBlockLike(node) {
      check(node, node.type);
    }
    return {
      BlockStatement(node) {
        const { parent } = node;
        switch (parent.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForOfStatement":
          case "ForStatement":
          case "WhileStatement":
          case "ArrowFunctionExpression":
          case "FunctionDeclaration":
          case "WithStatement":
            check(node, parent.type);
            break;
          case "FunctionExpression":
            if (parent.parent.type === "Property" && parent.parent.method) check(node, "Property");
            else check(node, parent.type);
            break;
          case "IfStatement":
            if (node === parent.consequent) check(node, "IfStatementConsequent");
            if (node === parent.alternate) check(node, "IfStatementAlternative");
            break;
          case "TryStatement":
            if (node === parent.block) check(node, "TryStatementBlock");
            if (node === parent.finalizer) check(node, "TryStatementFinalizer");
            break;
          case "CatchClause":
            check(node, "TryStatementHandler");
            break;
          default:
            if (parent.type === "SwitchCase" && parent.consequent.length === 1) check(node, "SwitchCase");
            else check(node, "BlockStatement");
        }
      },
      SwitchStatement: checkBlockLike,
      ClassBody: checkBlockLike,
      StaticBlock: checkBlockLike,
      TSModuleBlock: checkBlockLike
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/dot-location.js
var dot_location_default = createRule({
  name: "dot-location",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent newlines before and after dots" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: ["object", "property"]
    }],
    defaultOptions: ["object"],
    messages: {
      expectedDotAfterObject: "Expected dot to be on same line as object.",
      expectedDotBeforeProperty: "Expected dot to be on same line as property."
    }
  },
  create(context, [config]) {
    const onObject = config === "object";
    const sourceCode = context.sourceCode;
    function getProperty(node) {
      if (node.type === "TSImportType") return node.qualifier;
      if (node.type === "TSQualifiedName") return node.right;
      return node.property;
    }
    function checkDotLocation(node) {
      const property = getProperty(node);
      if (!property) return;
      const dotToken = sourceCode.getTokenBefore(property);
      if (!dotToken) return;
      if (onObject) {
        const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);
        if (tokenBeforeDot && !(0, ast_exports.isTokenOnSameLine)(tokenBeforeDot, dotToken)) context.report({
          node,
          loc: dotToken.loc,
          messageId: "expectedDotAfterObject",
          *fix(fixer) {
            if (dotToken.value.startsWith(".") && isDecimalIntegerNumericToken(tokenBeforeDot)) yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);
            else yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);
            yield fixer.remove(dotToken);
          }
        });
      } else if (!(0, ast_exports.isTokenOnSameLine)(dotToken, property)) context.report({
        node,
        loc: dotToken.loc,
        messageId: "expectedDotBeforeProperty",
        *fix(fixer) {
          yield fixer.remove(dotToken);
          yield fixer.insertTextBefore(property, dotToken.value);
        }
      });
    }
    return {
      MemberExpression(node) {
        if (node.computed) return;
        checkDotLocation(node);
      },
      MetaProperty: checkDotLocation,
      JSXMemberExpression: checkDotLocation,
      TSQualifiedName: checkDotLocation,
      TSImportType: checkDotLocation
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/eol-last.js
var eol_last_default = createRule({
  name: "eol-last",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow newline at the end of files" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: [
        "always",
        "never",
        "unix",
        "windows"
      ]
    }],
    defaultOptions: ["always"],
    messages: {
      missing: "Newline required at end of file but not found.",
      unexpected: "Newline not allowed at end of file."
    }
  },
  create(context, [mode]) {
    const sourceCode = context.sourceCode;
    if (!isTextSourceCode(sourceCode) || !hasLinesAndGetLocFromIndex(sourceCode)) return {};
    const src = sourceCode.text;
    const LF = "\n";
    const CRLF = `\r${LF}`;
    const endsWithNewline = src.endsWith(LF);
    if (!src.length) return {};
    let appendCRLF = false;
    if (mode === "unix") {
      warnDeprecation('option("unix")', '"always" and "@stylistic/eslint-plugin/rules/linebreak-style"', "eol-last");
      mode = "always";
    }
    if (mode === "windows") {
      warnDeprecation('option("windows")', '"always" and "@stylistic/eslint-plugin/rules/linebreak-style"', "eol-last");
      mode = "always";
      appendCRLF = true;
    }
    if (mode === "always" && !endsWithNewline) context.report({
      loc: sourceCode.getLocFromIndex(src.length),
      messageId: "missing",
      fix(fixer) {
        return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
      }
    });
    else if (mode === "never" && endsWithNewline) {
      const startLoc = sourceCode.getLocFromIndex(src.length - (src.endsWith(CRLF) ? 2 : 1));
      const endLoc = sourceCode.getLocFromIndex(src.length);
      context.report({
        loc: {
          start: startLoc,
          end: endLoc
        },
        messageId: "unexpected",
        fix(fixer) {
          const start = /(?:\r?\n)+$/u.exec(src).index;
          const end = src.length;
          return fixer.replaceTextRange([start, end], "");
        }
      });
    }
    return {};
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/function-call-argument-newline.js
var function_call_argument_newline_default = createRule({
  name: "function-call-argument-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce line breaks between arguments of a function call" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: [
        "always",
        "never",
        "consistent"
      ]
    }],
    defaultOptions: ["always"],
    messages: {
      unexpectedLineBreak: "There should be no line break here.",
      missingLineBreak: "There should be a line break after this argument."
    }
  },
  create(context, [option]) {
    const sourceCode = context.sourceCode;
    const checkers = {
      unexpected: {
        messageId: "unexpectedLineBreak",
        check: (prevToken, currentToken) => !(0, ast_exports.isTokenOnSameLine)(prevToken, currentToken),
        createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
      },
      missing: {
        messageId: "missingLineBreak",
        check: (prevToken, currentToken) => (0, ast_exports.isTokenOnSameLine)(prevToken, currentToken),
        createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
      }
    };
    function checkArguments(argumentNodes, checker) {
      for (let i = 1; i < argumentNodes.length; i++) {
        const argumentNode = argumentNodes[i - 1];
        const prevArgToken = sourceCode.getLastToken(argumentNode);
        const currentArgToken = sourceCode.getFirstToken(argumentNodes[i]);
        if (checker.check(prevArgToken, currentArgToken)) {
          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, { includeComments: true });
          const hasLineCommentBefore = tokenBefore.type === "Line";
          context.report({
            node: argumentNodes[i - 1],
            loc: {
              start: tokenBefore.loc.end,
              end: currentArgToken.loc.start
            },
            messageId: checker.messageId,
            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
          });
        }
      }
    }
    function check(argumentNodes) {
      if (argumentNodes.length < 2) return;
      if (option === "never") checkArguments(argumentNodes, checkers.unexpected);
      else if (option === "always") checkArguments(argumentNodes, checkers.missing);
      else if (option === "consistent") if ((0, ast_exports.isTokenOnSameLine)(sourceCode.getLastToken(argumentNodes[0]), sourceCode.getFirstToken(argumentNodes[1]))) checkArguments(argumentNodes, checkers.unexpected);
      else checkArguments(argumentNodes, checkers.missing);
    }
    return {
      CallExpression: (node) => check(node.arguments),
      NewExpression: (node) => check(node.arguments),
      ImportExpression: (node) => {
        if (node.options) check([node.source, node.options]);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/function-call-spacing.js
var function_call_spacing_default = createRule({
  name: "function-call-spacing",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow spacing between function identifiers and their invocations" },
    fixable: "whitespace",
    schema: { anyOf: [{
      type: "array",
      items: [{
        type: "string",
        enum: ["never"]
      }],
      minItems: 0,
      maxItems: 1
    }, {
      type: "array",
      items: [{
        type: "string",
        enum: ["always"]
      }, {
        type: "object",
        properties: {
          allowNewlines: { type: "boolean" },
          optionalChain: {
            type: "object",
            properties: {
              before: { type: "boolean" },
              after: { type: "boolean" }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }],
      minItems: 0,
      maxItems: 2
    }] },
    defaultOptions: ["never"],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
      unexpectedNewline: "Unexpected newline between function name and paren.",
      missing: "Missing space between function name and paren."
    }
  },
  create(context, [option, config]) {
    const sourceCode = context.sourceCode;
    const text = sourceCode.getText();
    const { allowNewlines = false, optionalChain = {
      before: true,
      after: true
    } } = config ?? {};
    function checkSpacing(node, leftToken, rightToken) {
      const isOptionalCall = (0, ast_exports.isOptionalCallExpression)(node);
      const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\/\*.*?\*\//gu, "");
      const hasWhitespace = /\s/u.test(textBetweenTokens);
      const hasNewline = hasWhitespace && ast_exports.LINEBREAK_MATCHER.test(textBetweenTokens);
      if (option === "never") {
        if (hasWhitespace) return context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: rightToken.loc.start
          },
          messageId: "unexpectedWhitespace",
          fix: safeReplaceTextBetween(sourceCode, leftToken, rightToken, isOptionalCall ? "?." : "")
        });
      } else if (isOptionalCall) {
        const { before: beforeOptionChain = true, after: afterOptionChain = true } = optionalChain;
        const hasPrefixSpace = /^\s/u.test(textBetweenTokens);
        const hasSuffixSpace = /\s$/u.test(textBetweenTokens);
        const hasCorrectPrefixSpace = beforeOptionChain ? hasPrefixSpace : !hasPrefixSpace;
        const hasCorrectSuffixSpace = afterOptionChain ? hasSuffixSpace : !hasSuffixSpace;
        const hasCorrectNewline = allowNewlines || !hasNewline;
        if (!hasCorrectPrefixSpace || !hasCorrectSuffixSpace || !hasCorrectNewline) {
          const messageId = !hasCorrectNewline ? "unexpectedNewline" : !beforeOptionChain && hasPrefixSpace || !afterOptionChain && hasSuffixSpace ? "unexpectedWhitespace" : "missing";
          context.report({
            node,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId,
            fix: safeReplaceTextBetween(sourceCode, leftToken, rightToken, () => {
              let text2 = textBetweenTokens;
              if (!allowNewlines) {
                const GLOBAL_LINEBREAK_MATCHER = new RegExp(ast_exports.LINEBREAK_MATCHER.source, "g");
                text2 = text2.replaceAll(GLOBAL_LINEBREAK_MATCHER, " ");
              }
              if (!hasCorrectPrefixSpace) text2 = beforeOptionChain ? ` ${text2}` : text2.trimStart();
              if (!hasCorrectSuffixSpace) text2 = afterOptionChain ? `${text2} ` : text2.trimEnd();
              return text2;
            })
          });
        }
      } else if (!hasWhitespace) context.report({
        node,
        loc: {
          start: leftToken.loc.end,
          end: rightToken.loc.start
        },
        messageId: "missing",
        fix(fixer) {
          return fixer.insertTextBefore(rightToken, " ");
        }
      });
      else if (!allowNewlines && hasNewline) context.report({
        node,
        loc: {
          start: leftToken.loc.end,
          end: rightToken.loc.start
        },
        messageId: "unexpectedNewline",
        fix: safeReplaceTextBetween(sourceCode, leftToken, rightToken, " ")
      });
    }
    return {
      "CallExpression, NewExpression": function(node) {
        const closingParenToken = sourceCode.getLastToken(node);
        const lastCalleeTokenWithoutPossibleParens = sourceCode.getLastToken(node.typeArguments ?? node.callee);
        const openingParenToken = sourceCode.getFirstTokenBetween(lastCalleeTokenWithoutPossibleParens, closingParenToken, ast_exports.isOpeningParenToken);
        if (!openingParenToken || openingParenToken.range[1] >= node.range[1]) return;
        checkSpacing(node, sourceCode.getTokenBefore(openingParenToken, ast_exports.isNotOptionalChainPunctuator), openingParenToken);
      },
      ImportExpression(node) {
        const leftToken = sourceCode.getFirstToken(node);
        checkSpacing(node, leftToken, sourceCode.getTokenAfter(leftToken));
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/function-paren-newline.js
var function_paren_newline_default = createRule({
  name: "function-paren-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent line breaks inside function parentheses" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: [
        "always",
        "never",
        "consistent",
        "multiline",
        "multiline-arguments"
      ]
    }, {
      type: "object",
      properties: { minItems: {
        type: "integer",
        minimum: 0
      } },
      additionalProperties: false
    }] }],
    defaultOptions: ["multiline"],
    messages: {
      expectedBefore: "Expected newline before ')'.",
      expectedAfter: "Expected newline after '('.",
      expectedBetween: "Expected newline between arguments/params.",
      unexpectedBefore: "Unexpected newline before ')'.",
      unexpectedAfter: "Unexpected newline after '('."
    }
  },
  create(context, [rawOption]) {
    const sourceCode = context.sourceCode;
    const multilineOption = rawOption === "multiline";
    const multilineArgumentsOption = rawOption === "multiline-arguments";
    const consistentOption = rawOption === "consistent";
    let minItems;
    if (typeof rawOption === "object") minItems = rawOption.minItems;
    else if (rawOption === "always") minItems = 0;
    else if (rawOption === "never") minItems = Infinity;
    function shouldHaveNewlines(elements, hasLeftNewline) {
      if (multilineArgumentsOption && elements.length === 1) return hasLeftNewline;
      if (multilineOption || multilineArgumentsOption) return elements.some((element, index2) => index2 !== elements.length - 1 && !(0, ast_exports.isTokenOnSameLine)(element, elements[index2 + 1]));
      if (consistentOption) return hasLeftNewline;
      return minItems == null || elements.length >= minItems;
    }
    function validateParens(parens, elements) {
      const leftParen = parens.leftParen;
      const rightParen = parens.rightParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
      const hasLeftNewline = !(0, ast_exports.isTokenOnSameLine)(leftParen, tokenAfterLeftParen);
      const hasRightNewline = !(0, ast_exports.isTokenOnSameLine)(tokenBeforeRightParen, rightParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
      if (hasLeftNewline && !needsNewlines) context.report({
        node: leftParen,
        messageId: "unexpectedAfter",
        fix: safeReplaceTextBetween(sourceCode, leftParen, tokenAfterLeftParen, "")
      });
      else if (!hasLeftNewline && needsNewlines) context.report({
        node: leftParen,
        messageId: "expectedAfter",
        fix: (fixer) => fixer.insertTextAfter(leftParen, "\n")
      });
      if (hasRightNewline && !needsNewlines) context.report({
        node: rightParen,
        messageId: "unexpectedBefore",
        fix: safeReplaceTextBetween(sourceCode, tokenBeforeRightParen, rightParen, "")
      });
      else if (!hasRightNewline && needsNewlines) context.report({
        node: rightParen,
        messageId: "expectedBefore",
        fix: (fixer) => fixer.insertTextBefore(rightParen, "\n")
      });
    }
    function validateArguments(parens, elements) {
      const leftParen = parens.leftParen;
      const needsNewlines = shouldHaveNewlines(elements, !(0, ast_exports.isTokenOnSameLine)(leftParen, sourceCode.getTokenAfter(leftParen)));
      for (let i = 0; i <= elements.length - 2; i++) {
        const currentElement = elements[i];
        const nextElement = elements[i + 1];
        if (!!(0, ast_exports.isTokenOnSameLine)(currentElement, nextElement) && needsNewlines) context.report({
          node: currentElement,
          messageId: "expectedBetween",
          fix: (fixer) => fixer.insertTextBefore(nextElement, "\n")
        });
      }
    }
    function getParenTokens(node) {
      const isOpeningParenTokenOutsideTypeParameter = () => {
        let typeParameterOpeningLevel = 0;
        return (token) => {
          if (token.type === "Punctuator" && token.value === "<") typeParameterOpeningLevel += 1;
          if (token.type === "Punctuator" && token.value === ">") typeParameterOpeningLevel -= 1;
          return typeParameterOpeningLevel !== 0 ? false : (0, ast_exports.isOpeningParenToken)(token);
        };
      };
      switch (node.type) {
        case "NewExpression":
          if (!node.arguments.length && !((0, ast_exports.isOpeningParenToken)(sourceCode.getLastToken(node, { skip: 1 })) && (0, ast_exports.isClosingParenToken)(sourceCode.getLastToken(node)) && node.callee.range[1] < node.range[1])) return null;
        case "CallExpression":
          return {
            leftParen: sourceCode.getTokenAfter(node.callee, isOpeningParenTokenOutsideTypeParameter()),
            rightParen: sourceCode.getLastToken(node)
          };
        case "FunctionDeclaration":
        case "FunctionExpression": {
          const leftParen = sourceCode.getFirstToken(node, isOpeningParenTokenOutsideTypeParameter());
          return {
            leftParen,
            rightParen: node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], ast_exports.isClosingParenToken) : sourceCode.getTokenAfter(leftParen)
          };
        }
        case "ArrowFunctionExpression": {
          const firstToken = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });
          if (!(0, ast_exports.isOpeningParenToken)(firstToken)) return null;
          return {
            leftParen: firstToken,
            rightParen: node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], ast_exports.isClosingParenToken) : sourceCode.getTokenAfter(firstToken)
          };
        }
        case "ImportExpression":
          return {
            leftParen: sourceCode.getFirstToken(node, 1),
            rightParen: sourceCode.getLastToken(node)
          };
        default:
          throw new TypeError(`unexpected node with type ${node.type}`);
      }
    }
    return { [[
      "ArrowFunctionExpression",
      "CallExpression",
      "FunctionDeclaration",
      "FunctionExpression",
      "ImportExpression",
      "NewExpression"
    ].join(", ")](node) {
      const parens = getParenTokens(node);
      let params;
      if (node.type === "ImportExpression") params = [node.source, ...node.options ? [node.options] : []];
      else if ((0, ast_exports.isFunction)(node)) params = node.params;
      else params = node.arguments;
      if (parens) {
        validateParens(parens, params);
        if (multilineArgumentsOption) validateArguments(parens, params);
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/generator-star-spacing.js
var OVERRIDE_SCHEMA = { oneOf: [{
  type: "string",
  enum: [
    "before",
    "after",
    "both",
    "neither"
  ]
}, {
  type: "object",
  properties: {
    before: { type: "boolean" },
    after: { type: "boolean" }
  },
  additionalProperties: false
}] };
var generator_star_spacing_default = createRule({
  name: "generator-star-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing around `*` operators in generator functions" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: [
        "before",
        "after",
        "both",
        "neither"
      ]
    }, {
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" },
        named: OVERRIDE_SCHEMA,
        anonymous: OVERRIDE_SCHEMA,
        method: OVERRIDE_SCHEMA,
        shorthand: OVERRIDE_SCHEMA
      },
      additionalProperties: false
    }] }],
    defaultOptions: [{
      before: true,
      after: false
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(context, [options]) {
    const optionDefinitions = {
      before: {
        before: true,
        after: false
      },
      after: {
        before: false,
        after: true
      },
      both: {
        before: true,
        after: true
      },
      neither: {
        before: false,
        after: false
      }
    };
    function optionToDefinition(option, defaults) {
      if (!option) return defaults;
      return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
    }
    const modes = (function() {
      const defaults = optionToDefinition(options, optionDefinitions.before);
      const { named, anonymous, method, shorthand } = options;
      return {
        named: optionToDefinition(named, defaults),
        anonymous: optionToDefinition(anonymous, defaults),
        method: optionToDefinition(method, defaults),
        shorthand: optionToDefinition(shorthand ?? method, defaults)
      };
    })();
    const sourceCode = context.sourceCode;
    function isStarToken(token) {
      return token.value === "*" && token.type === "Punctuator";
    }
    function getStarToken(node) {
      return sourceCode.getFirstToken("method" in node.parent && node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
    }
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    function checkSpacing(kind, side, leftToken, rightToken) {
      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
        const after = leftToken.value === "*";
        const spaceRequired = modes[kind][side];
        const node = after ? leftToken : rightToken;
        const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
        context.report({
          node,
          messageId,
          fix(fixer) {
            if (spaceRequired) {
              if (after) return fixer.insertTextAfter(node, " ");
              return fixer.insertTextBefore(node, " ");
            }
            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }
        });
      }
    }
    function checkFunction(node) {
      if (!node.generator) return;
      const starToken = getStarToken(node);
      const prevToken = sourceCode.getTokenBefore(starToken);
      const nextToken = sourceCode.getTokenAfter(starToken);
      let kind = "named";
      if (node.parent.type === "Property" && node.parent.method) kind = "shorthand";
      else if (node.parent.type === "MethodDefinition") kind = "method";
      else if (!node.id) kind = "anonymous";
      if (!((kind === "method" || kind === "shorthand") && starToken === sourceCode.getFirstToken(node.parent))) checkSpacing(kind, "before", prevToken, starToken);
      checkSpacing(kind, "after", starToken, nextToken);
    }
    return {
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/implicit-arrow-linebreak.js
var implicit_arrow_linebreak_default = createRule({
  name: "implicit-arrow-linebreak",
  meta: {
    type: "layout",
    docs: { description: "Enforce the location of arrow function bodies" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["beside", "below"]
    }],
    defaultOptions: ["beside"],
    messages: {
      expected: "Expected a linebreak before this expression.",
      unexpected: "Expected no linebreak before this expression."
    }
  },
  create(context, [option]) {
    const sourceCode = context.sourceCode;
    function validateExpression(node) {
      if (node.body.type === "BlockStatement") return;
      const arrowToken = sourceCode.getTokenBefore(node.body, ast_exports.isNotOpeningParenToken);
      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);
      const onSameLine = (0, ast_exports.isTokenOnSameLine)(arrowToken, firstTokenOfBody);
      if (onSameLine && option === "below") context.report({
        node: firstTokenOfBody,
        messageId: "expected",
        fix: (fixer) => fixer.insertTextBefore(firstTokenOfBody, "\n")
      });
      else if (!onSameLine && option === "beside") context.report({
        node: firstTokenOfBody,
        messageId: "unexpected",
        fix: safeReplaceTextBetween(sourceCode, arrowToken, firstTokenOfBody, " ")
      });
    }
    return { ArrowFunctionExpression: (node) => validateExpression(node) };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/indent-binary-ops.js
var indent_binary_ops_default = createRule({
  name: "indent-binary-ops",
  meta: {
    type: "layout",
    docs: { description: "Indentation for binary operators" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "integer",
      minimum: 0
    }, {
      type: "string",
      enum: ["tab"]
    }] }],
    defaultOptions: [2],
    messages: { wrongIndentation: "Expected indentation of {{expected}}" }
  },
  create: (context, options) => {
    const { sourceCode } = context;
    const indentStr = options[0] === "tab" ? "	" : " ".repeat(options[0] ?? 2);
    const indentCache = /* @__PURE__ */ new Map();
    function getIndentOfLine(line) {
      if (indentCache.has(line)) return indentCache.get(line);
      return sourceCode.lines[line - 1].match(/^\s*/)?.[0] ?? "";
    }
    function subtractionIndent(indent) {
      if (options[0] === "tab") return indent.slice(1);
      return indent.slice(options[0] ?? 2);
    }
    function getTargetIndent(indent, needAdditionIndent, needSubtractionIndent) {
      if (needAdditionIndent && !needSubtractionIndent) return indent + indentStr;
      if (!needAdditionIndent && needSubtractionIndent) return subtractionIndent(indent);
      return indent;
    }
    function firstTokenOfLine(line) {
      return sourceCode.tokensAndComments.find((token) => token.loc.start.line === line);
    }
    function lastTokenOfLine(line) {
      return [...sourceCode.tokensAndComments].reverse().find((token) => token.loc.end.line === line);
    }
    function isGreaterThanCloseBracketOfLine(line) {
      const tokensAndCommentsOfLine = sourceCode.tokensAndComments.filter((token) => token.loc.start.line === line);
      let openBracketCount = 0;
      let closeBracketCount = 0;
      for (const token of tokensAndCommentsOfLine) {
        if (token.value === "(") openBracketCount++;
        if (token.value === ")") closeBracketCount++;
      }
      return openBracketCount < closeBracketCount;
    }
    function isTypeKeywordOfNode(typeToken, node) {
      while (node.parent) {
        node = node.parent;
        if (node.type === "TSTypeAliasDeclaration" && context.sourceCode.getTokenBefore(node.id) === typeToken) return true;
      }
      return false;
    }
    function handler(node, right) {
      if (node.loc.start.line === node.loc.end.line) return;
      let tokenRight = sourceCode.getFirstToken(right);
      let tokenOperator = sourceCode.getTokenBefore(tokenRight);
      while (tokenOperator.value === "(") {
        tokenRight = tokenOperator;
        tokenOperator = sourceCode.getTokenBefore(tokenRight);
        if (tokenOperator.range[0] <= right.parent.range[0]) return;
      }
      const tokenBeforeAll = sourceCode.getTokenBefore(node);
      const tokenLeft = sourceCode.getTokenBefore(tokenOperator);
      if (!(tokenRight.loc.start.line !== tokenLeft.loc.start.line)) return;
      const firstTokenOfLineLeft = firstTokenOfLine(tokenLeft.loc.start.line);
      const lastTokenOfLineLeft = lastTokenOfLine(tokenLeft.loc.start.line);
      const needAdditionIndent = isKeywordToken(firstTokenOfLineLeft) && ![
        "typeof",
        "instanceof",
        "this"
      ].includes(firstTokenOfLineLeft.value) || firstTokenOfLineLeft?.type === "Identifier" && firstTokenOfLineLeft.value === "type" && isTypeKeywordOfNode(firstTokenOfLineLeft, node) || [
        ":",
        "[",
        "(",
        "<"
      ].concat(ASSIGNMENT_OPERATOR).includes(lastTokenOfLineLeft?.value || "") || [
        "[",
        "(",
        "{",
        "=>",
        ":"
      ].concat(ASSIGNMENT_OPERATOR).includes(tokenBeforeAll?.value || "") && firstTokenOfLineLeft?.loc.start.line === tokenBeforeAll?.loc.start.line;
      const needSubtractionIndent = lastTokenOfLineLeft?.value === ")" && isGreaterThanCloseBracketOfLine(tokenLeft.loc.start.line) && ![
        "]",
        ")",
        "}"
      ].includes(firstTokenOfLineLeft?.value || "");
      const indentLeft = getIndentOfLine(tokenLeft.loc.start.line);
      const indentRight = getIndentOfLine(tokenRight.loc.start.line);
      const indentTarget = getTargetIndent(indentLeft, needAdditionIndent, needSubtractionIndent);
      if (indentTarget !== indentRight) {
        const start = {
          line: tokenRight.loc.start.line,
          column: 0
        };
        const end = {
          line: tokenRight.loc.start.line,
          column: indentRight.length
        };
        context.report({
          loc: {
            start,
            end
          },
          messageId: "wrongIndentation",
          data: { expected: `${indentTarget.length} ${options[0] === "tab" ? "tab" : "space"}${indentTarget.length === 1 ? "" : "s"}` },
          fix(fixer) {
            return fixer.replaceTextRange([sourceCode.getIndexFromLoc(start), sourceCode.getIndexFromLoc(end)], indentTarget);
          }
        });
        indentCache.set(tokenRight.loc.start.line, indentTarget);
      }
    }
    return {
      BinaryExpression(node) {
        handler(node, node.right);
      },
      LogicalExpression(node) {
        handler(node, node.right);
      },
      TSUnionType(node) {
        if (node.types.length > 1) node.types.forEach((type) => {
          handler(node, type);
        });
      },
      TSIntersectionType(node) {
        if (node.types.length > 1) node.types.forEach((type) => {
          handler(node, type);
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/indent.js
var KNOWN_NODES = /* @__PURE__ */ new Set([
  "AssignmentExpression",
  "AssignmentPattern",
  "ArrayExpression",
  "ArrayPattern",
  "ArrowFunctionExpression",
  "AwaitExpression",
  "BlockStatement",
  "BinaryExpression",
  "BreakStatement",
  "CallExpression",
  "CatchClause",
  "ChainExpression",
  "ClassBody",
  "ClassDeclaration",
  "ClassExpression",
  "ConditionalExpression",
  "ContinueStatement",
  "DoWhileStatement",
  "DebuggerStatement",
  "EmptyStatement",
  "ExpressionStatement",
  "ForStatement",
  "ForInStatement",
  "ForOfStatement",
  "FunctionDeclaration",
  "FunctionExpression",
  "Identifier",
  "IfStatement",
  "Literal",
  "LabeledStatement",
  "LogicalExpression",
  "MemberExpression",
  "MetaProperty",
  "MethodDefinition",
  "NewExpression",
  "ObjectExpression",
  "ObjectPattern",
  "PrivateIdentifier",
  "Program",
  "Property",
  "PropertyDefinition",
  import_types.AST_NODE_TYPES.AccessorProperty,
  "RestElement",
  "ReturnStatement",
  "SequenceExpression",
  "SpreadElement",
  "StaticBlock",
  "Super",
  "SwitchCase",
  "SwitchStatement",
  "TaggedTemplateExpression",
  "TemplateElement",
  "TemplateLiteral",
  "ThisExpression",
  "ThrowStatement",
  "TryStatement",
  "UnaryExpression",
  "UpdateExpression",
  "VariableDeclaration",
  "VariableDeclarator",
  "WhileStatement",
  "WithStatement",
  "YieldExpression",
  "JSXFragment",
  "JSXOpeningFragment",
  "JSXClosingFragment",
  "JSXIdentifier",
  "JSXNamespacedName",
  "JSXMemberExpression",
  "JSXEmptyExpression",
  "JSXExpressionContainer",
  "JSXElement",
  "JSXClosingElement",
  "JSXOpeningElement",
  "JSXAttribute",
  "JSXSpreadAttribute",
  "JSXText",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ExportAllDeclaration",
  "ExportSpecifier",
  "ImportDeclaration",
  "ImportSpecifier",
  "ImportDefaultSpecifier",
  "ImportNamespaceSpecifier",
  "ImportExpression",
  "ImportAttribute",
  import_types.AST_NODE_TYPES.TSAbstractKeyword,
  import_types.AST_NODE_TYPES.TSAnyKeyword,
  import_types.AST_NODE_TYPES.TSBooleanKeyword,
  import_types.AST_NODE_TYPES.TSNeverKeyword,
  import_types.AST_NODE_TYPES.TSNumberKeyword,
  import_types.AST_NODE_TYPES.TSStringKeyword,
  import_types.AST_NODE_TYPES.TSSymbolKeyword,
  import_types.AST_NODE_TYPES.TSUndefinedKeyword,
  import_types.AST_NODE_TYPES.TSUnknownKeyword,
  import_types.AST_NODE_TYPES.TSVoidKeyword,
  import_types.AST_NODE_TYPES.TSNullKeyword,
  import_types.AST_NODE_TYPES.TSAbstractPropertyDefinition,
  import_types.AST_NODE_TYPES.TSAbstractAccessorProperty,
  import_types.AST_NODE_TYPES.TSAbstractMethodDefinition,
  import_types.AST_NODE_TYPES.TSArrayType,
  import_types.AST_NODE_TYPES.TSAsExpression,
  import_types.AST_NODE_TYPES.TSCallSignatureDeclaration,
  import_types.AST_NODE_TYPES.TSConditionalType,
  import_types.AST_NODE_TYPES.TSConstructorType,
  import_types.AST_NODE_TYPES.TSConstructSignatureDeclaration,
  import_types.AST_NODE_TYPES.TSDeclareFunction,
  import_types.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
  import_types.AST_NODE_TYPES.TSEnumDeclaration,
  import_types.AST_NODE_TYPES.TSEnumBody,
  import_types.AST_NODE_TYPES.TSEnumMember,
  import_types.AST_NODE_TYPES.TSExportAssignment,
  import_types.AST_NODE_TYPES.TSExternalModuleReference,
  import_types.AST_NODE_TYPES.TSFunctionType,
  import_types.AST_NODE_TYPES.TSImportType,
  import_types.AST_NODE_TYPES.TSIndexedAccessType,
  import_types.AST_NODE_TYPES.TSIndexSignature,
  import_types.AST_NODE_TYPES.TSInferType,
  import_types.AST_NODE_TYPES.TSInterfaceBody,
  import_types.AST_NODE_TYPES.TSInterfaceDeclaration,
  import_types.AST_NODE_TYPES.TSInterfaceHeritage,
  import_types.AST_NODE_TYPES.TSImportEqualsDeclaration,
  import_types.AST_NODE_TYPES.TSLiteralType,
  import_types.AST_NODE_TYPES.TSMappedType,
  import_types.AST_NODE_TYPES.TSMethodSignature,
  import_types.AST_NODE_TYPES.TSModuleBlock,
  import_types.AST_NODE_TYPES.TSModuleDeclaration,
  import_types.AST_NODE_TYPES.TSNonNullExpression,
  import_types.AST_NODE_TYPES.TSParameterProperty,
  import_types.AST_NODE_TYPES.TSPropertySignature,
  import_types.AST_NODE_TYPES.TSQualifiedName,
  import_types.AST_NODE_TYPES.TSRestType,
  import_types.AST_NODE_TYPES.TSThisType,
  import_types.AST_NODE_TYPES.TSTupleType,
  import_types.AST_NODE_TYPES.TSTypeAliasDeclaration,
  import_types.AST_NODE_TYPES.TSTypeAnnotation,
  import_types.AST_NODE_TYPES.TSTypeLiteral,
  import_types.AST_NODE_TYPES.TSTypeOperator,
  import_types.AST_NODE_TYPES.TSTypeParameter,
  import_types.AST_NODE_TYPES.TSTypeParameterDeclaration,
  import_types.AST_NODE_TYPES.TSTypeParameterInstantiation,
  import_types.AST_NODE_TYPES.TSTypeReference,
  import_types.AST_NODE_TYPES.Decorator
]);
var IndexMap = class {
  _values;
  constructor(maxKey) {
    this._values = new Array(maxKey + 1);
  }
  insert(key, value) {
    this._values[key] = value;
  }
  findLastNotAfter(key) {
    const values = this._values;
    for (let index2 = key; index2 >= 0; index2--) {
      const value = values[index2];
      if (value) return value;
    }
  }
  deleteRange(start, end) {
    this._values.fill(void 0, start, end);
  }
};
var TokenInfo = class {
  sourceCode;
  firstTokensByLineNumber;
  constructor(sourceCode) {
    this.sourceCode = sourceCode;
    this.firstTokensByLineNumber = /* @__PURE__ */ new Map();
    const tokens = sourceCode.tokensAndComments;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (!this.firstTokensByLineNumber.has(token.loc.start.line)) this.firstTokensByLineNumber.set(token.loc.start.line, token);
      if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) this.firstTokensByLineNumber.set(token.loc.end.line, token);
    }
  }
  getFirstTokenOfLine(token) {
    return this.firstTokensByLineNumber.get(token.loc.start.line);
  }
  isFirstTokenOfLine(token) {
    return this.getFirstTokenOfLine(token) === token;
  }
  getTokenIndent(token) {
    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
  }
};
var OffsetStorage = class {
  _tokenInfo;
  _indentSize;
  _indentType;
  _indexMap;
  _lockedFirstTokens = /* @__PURE__ */ new WeakMap();
  _desiredIndentCache = /* @__PURE__ */ new WeakMap();
  _ignoredTokens = /* @__PURE__ */ new WeakSet();
  constructor(tokenInfo, indentSize, indentType, maxIndex) {
    this._tokenInfo = tokenInfo;
    this._indentSize = indentSize;
    this._indentType = indentType;
    this._indexMap = new IndexMap(maxIndex);
    this._indexMap.insert(0, {
      offset: 0,
      from: null,
      force: false
    });
  }
  _getOffsetDescriptor(token) {
    return this._indexMap.findLastNotAfter(token.range[0]);
  }
  matchOffsetOf(baseToken, offsetToken) {
    this._lockedFirstTokens.set(offsetToken, baseToken);
  }
  setDesiredOffset(token, fromToken, offset2) {
    if (token) this.setDesiredOffsets(token.range, fromToken, offset2);
  }
  setDesiredOffsets(range, fromToken, offset2, force = false) {
    const descriptorToInsert = {
      offset: offset2,
      from: fromToken,
      force
    };
    const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);
    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
    this._indexMap.deleteRange(range[0] + 1, range[1]);
    this._indexMap.insert(range[0], descriptorToInsert);
    if (fromTokenIsInRange) {
      this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);
      this._indexMap.insert(fromToken.range[1], descriptorToInsert);
    }
    this._indexMap.insert(range[1], descriptorAfterRange);
  }
  getDesiredIndent(token) {
    if (!this._desiredIndentCache.has(token)) if (this._ignoredTokens.has(token)) this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
    else if (this._lockedFirstTokens.has(token)) {
      const firstToken = this._lockedFirstTokens.get(token);
      const firstTokenOfLine = this._tokenInfo.getFirstTokenOfLine(firstToken);
      this._desiredIndentCache.set(token, this.getDesiredIndent(firstTokenOfLine) + this._indentType.repeat(firstToken.loc.start.column - firstTokenOfLine.loc.start.column));
    } else {
      const offsetInfo = this._getOffsetDescriptor(token);
      const offset2 = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;
      this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset2));
    }
    return this._desiredIndentCache.get(token);
  }
  ignoreToken(token) {
    if (this._tokenInfo.isFirstTokenOfLine(token)) this._ignoredTokens.add(token);
  }
  getFirstDependency(token) {
    return this._getOffsetDescriptor(token).from;
  }
};
var ELEMENT_LIST_SCHEMA = { oneOf: [{
  type: "integer",
  minimum: 0
}, {
  type: "string",
  enum: ["first", "off"]
}] };
var indent_default = createRule({
  name: "indent",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent indentation" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: ["tab"]
    }, {
      type: "integer",
      minimum: 0
    }] }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0
        },
        VariableDeclarator: { oneOf: [ELEMENT_LIST_SCHEMA, {
          type: "object",
          properties: {
            var: ELEMENT_LIST_SCHEMA,
            let: ELEMENT_LIST_SCHEMA,
            const: ELEMENT_LIST_SCHEMA,
            using: ELEMENT_LIST_SCHEMA
          },
          additionalProperties: false
        }] },
        assignmentOperator: { oneOf: [{
          type: "integer",
          minimum: 0
        }, {
          type: "string",
          enum: ["off"]
        }] },
        outerIIFEBody: { oneOf: [{
          type: "integer",
          minimum: 0
        }, {
          type: "string",
          enum: ["off"]
        }] },
        MemberExpression: { oneOf: [{
          type: "integer",
          minimum: 0
        }, {
          type: "string",
          enum: ["off"]
        }] },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            },
            returnType: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            },
            returnType: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        StaticBlock: {
          type: "object",
          properties: { body: {
            type: "integer",
            minimum: 0
          } },
          additionalProperties: false
        },
        CallExpression: {
          type: "object",
          properties: { arguments: ELEMENT_LIST_SCHEMA },
          additionalProperties: false
        },
        ArrayExpression: ELEMENT_LIST_SCHEMA,
        ObjectExpression: ELEMENT_LIST_SCHEMA,
        ImportDeclaration: ELEMENT_LIST_SCHEMA,
        flatTernaryExpressions: { type: "boolean" },
        offsetTernaryExpressions: { oneOf: [{ type: "boolean" }, {
          type: "object",
          properties: {
            CallExpression: { type: "boolean" },
            AwaitExpression: { type: "boolean" },
            NewExpression: { type: "boolean" }
          },
          additionalProperties: false
        }] },
        offsetTernaryExpressionsOffsetCallExpressions: { type: "boolean" },
        ignoredNodes: {
          type: "array",
          items: {
            type: "string",
            not: {
              type: "string",
              pattern: ":exit$"
            }
          }
        },
        ignoreComments: { type: "boolean" },
        tabLength: { type: "number" }
      },
      additionalProperties: false
    }],
    defaultOptions: [4, {
      SwitchCase: 1,
      flatTernaryExpressions: false,
      ignoredNodes: []
    }],
    messages: { wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}." }
  },
  create(context, optionsWithDefaults) {
    const DEFAULT_VARIABLE_INDENT = 1;
    const DEFAULT_PARAMETER_INDENT = 1;
    const DEFAULT_FUNCTION_BODY_INDENT = 1;
    const DEFAULT_FUNCTION_RETURN_TYPE_INDENT = 1;
    warnDeprecatedOptions(context.options[1], "offsetTernaryExpressionsOffsetCallExpressions", "offsetTernaryExpressions.CallExpression", "indent");
    let indentType = "space";
    let indentSize = 4;
    const options = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: DEFAULT_VARIABLE_INDENT,
        let: DEFAULT_VARIABLE_INDENT,
        const: DEFAULT_VARIABLE_INDENT,
        using: DEFAULT_VARIABLE_INDENT
      },
      outerIIFEBody: 1,
      assignmentOperator: 1,
      FunctionDeclaration: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT,
        returnType: DEFAULT_FUNCTION_RETURN_TYPE_INDENT
      },
      FunctionExpression: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT,
        returnType: DEFAULT_FUNCTION_RETURN_TYPE_INDENT
      },
      StaticBlock: { body: DEFAULT_FUNCTION_BODY_INDENT },
      CallExpression: { arguments: DEFAULT_PARAMETER_INDENT },
      MemberExpression: 1,
      ArrayExpression: 1,
      ObjectExpression: 1,
      ImportDeclaration: 1,
      flatTernaryExpressions: false,
      ignoredNodes: [],
      ignoreComments: false,
      offsetTernaryExpressions: false,
      offsetTernaryExpressionsOffsetCallExpressions: true,
      tabLength: 4
    };
    if (optionsWithDefaults.length) {
      if (optionsWithDefaults[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else {
        indentSize = optionsWithDefaults[0] ?? indentSize;
        indentType = "space";
      }
      const userOptions = optionsWithDefaults[1];
      if (userOptions) {
        Object.assign(options, userOptions);
        if (typeof userOptions.VariableDeclarator === "number" || userOptions.VariableDeclarator === "first") options.VariableDeclarator = {
          var: userOptions.VariableDeclarator,
          let: userOptions.VariableDeclarator,
          const: userOptions.VariableDeclarator,
          using: userOptions.VariableDeclarator
        };
      }
    }
    const sourceCode = context.sourceCode;
    const tokenInfo = new TokenInfo(sourceCode);
    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "	", sourceCode.text.length);
    const parameterParens = /* @__PURE__ */ new WeakSet();
    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
      const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
      const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
      let foundStatement;
      if (actualSpaces > 0) foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
      else if (actualTabs > 0) foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
      else foundStatement = "0";
      return {
        expected: expectedStatement,
        actual: foundStatement
      };
    }
    function report(token, neededIndent) {
      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
      const numSpaces = actualIndent.filter((char) => char === " ").length;
      const numTabs = actualIndent.filter((char) => char === "	").length;
      context.report({
        node: token,
        messageId: "wrongIndentation",
        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
        loc: {
          start: {
            line: token.loc.start.line,
            column: 0
          },
          end: {
            line: token.loc.start.line,
            column: token.loc.start.column
          }
        },
        fix(fixer) {
          const range = [token.range[0] - token.loc.start.column, token.range[0]];
          const newText = neededIndent;
          return fixer.replaceTextRange(range, newText);
        }
      });
    }
    function validateTokenIndent(token, desiredIndent) {
      return tokenInfo.getTokenIndent(token) === desiredIndent;
    }
    function isOuterIIFE(node) {
      if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) return false;
      let statement = node.parent && node.parent.parent;
      while (statement.type === "UnaryExpression" && [
        "!",
        "~",
        "+",
        "-"
      ].includes(statement.operator) || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") statement = statement.parent;
      return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
    }
    function countTrailingLinebreaks(string) {
      const linebreakMatches = string.match(/\s*$/u)[0].match(createGlobalLinebreakMatcher());
      return linebreakMatches === null ? 0 : linebreakMatches.length;
    }
    function addElementListIndent(elements, startToken, endToken, offset2) {
      function getFirstToken(element) {
        let token = sourceCode.getTokenBefore(element);
        while ((0, ast_exports.isOpeningParenToken)(token) && token !== startToken) token = sourceCode.getTokenBefore(token);
        return sourceCode.getTokenAfter(token);
      }
      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset2 === "number" ? offset2 : 1);
      offsets.setDesiredOffset(endToken, startToken, 0);
      if (offset2 === "first" && elements.length && !elements[0]) return;
      elements.forEach((element, index2) => {
        if (!element) return;
        if (offset2 === "off") offsets.ignoreToken(getFirstToken(element));
        if (index2 === 0) return;
        if (offset2 === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
        else {
          const previousElement = elements[index2 - 1];
          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);
          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);
        }
      });
    }
    function addBlocklessNodeIndent(node) {
      if (node.type !== "BlockStatement") {
        const lastParentToken = sourceCode.getTokenBefore(node, ast_exports.isNotOpeningParenToken);
        let firstBodyToken = sourceCode.getFirstToken(node);
        let lastBodyToken = sourceCode.getLastToken(node);
        while ((0, ast_exports.isOpeningParenToken)(sourceCode.getTokenBefore(firstBodyToken)) && (0, ast_exports.isClosingParenToken)(sourceCode.getTokenAfter(lastBodyToken))) {
          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
        }
        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
      }
    }
    function addFunctionCallIndent(node) {
      let openingParen;
      if (node.arguments.length) openingParen = sourceCode.getTokenAfter(node.typeArguments ?? node.callee, ast_exports.isOpeningParenToken);
      else openingParen = sourceCode.getLastToken(node, 1);
      const closingParen = sourceCode.getLastToken(node);
      parameterParens.add(openingParen);
      parameterParens.add(closingParen);
      if ("optional" in node && node.optional) {
        const dotToken = sourceCode.getTokenAfter(node.callee, ast_exports.isOptionalChainPunctuator);
        const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: ast_exports.isClosingParenToken }).length;
        const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 }) : sourceCode.getFirstToken(node.callee);
        const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
        const offsetBase = (0, ast_exports.isTokenOnSameLine)(lastTokenOfCallee, openingParen) ? lastTokenOfCallee : firstTokenOfCallee;
        offsets.setDesiredOffset(dotToken, offsetBase, 1);
      }
      const offsetAfterToken = node.callee.type === "TaggedTemplateExpression" ? sourceCode.getFirstToken(node.callee.quasi) : node.typeArguments ?? openingParen;
      const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);
      offsets.setDesiredOffset(openingParen, offsetToken, 0);
      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
    }
    function addParensIndent(tokens) {
      const parenStack = [];
      const parenPairs = [];
      for (let i = 0; i < tokens.length; i++) {
        const nextToken = tokens[i];
        if ((0, ast_exports.isOpeningParenToken)(nextToken)) parenStack.push(nextToken);
        else if ((0, ast_exports.isClosingParenToken)(nextToken)) parenPairs.push({
          left: parenStack.pop(),
          right: nextToken
        });
      }
      for (let i = parenPairs.length - 1; i >= 0; i--) {
        const leftParen = parenPairs[i].left;
        const rightParen = parenPairs[i].right;
        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
          parenthesizedTokens.forEach((token) => {
            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) offsets.setDesiredOffset(token, leftParen, 1);
          });
        }
        offsets.setDesiredOffset(rightParen, leftParen, 0);
      }
    }
    function ignoreNode(node) {
      const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));
      unknownNodeTokens.forEach((token) => {
        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
          if (token === firstTokenOfLine) offsets.ignoreToken(token);
          else offsets.setDesiredOffset(token, firstTokenOfLine, 0);
        }
      });
    }
    function isOnFirstLineOfStatement(token, leafNode) {
      let node = leafNode;
      while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) node = node.parent;
      node = node.parent;
      return !node || node.loc.start.line === token.loc.start.line;
    }
    function hasBlankLinesBetween(firstToken, secondToken) {
      const firstTokenLine = firstToken.loc.end.line;
      const secondTokenLine = secondToken.loc.start.line;
      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) return false;
      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) if (!tokenInfo.firstTokensByLineNumber.has(line)) return true;
      return false;
    }
    const ignoredNodeFirstTokens = /* @__PURE__ */ new Set();
    function checkAssignmentOperator(operator) {
      const left = sourceCode.getTokenBefore(operator);
      const right = sourceCode.getTokenAfter(operator);
      if (typeof options.assignmentOperator === "number") {
        offsets.setDesiredOffset(operator, left, options.assignmentOperator);
        offsets.setDesiredOffset(right, operator, options.assignmentOperator);
      } else {
        offsets.ignoreToken(operator);
        offsets.ignoreToken(right);
      }
    }
    function checkArrayLikeNode(node) {
      const elementList = node.type === import_types.AST_NODE_TYPES.TSTupleType ? node.elementTypes : node.elements;
      const openingBracket = sourceCode.getFirstToken(node);
      addElementListIndent(elementList, openingBracket, sourceCode.getTokenAfter([...elementList].reverse().find((_) => _) || openingBracket, ast_exports.isClosingBracketToken), options.ArrayExpression);
    }
    function checkObjectLikeNode(node, properties) {
      const openingCurly = sourceCode.getFirstToken(node, ast_exports.isOpeningBraceToken);
      addElementListIndent(properties, openingCurly, sourceCode.getTokenAfter(properties.length ? properties[properties.length - 1] : openingCurly, ast_exports.isClosingBraceToken), options.ObjectExpression);
    }
    function checkConditionalNode(node, test, consequent, alternate) {
      const firstToken = sourceCode.getFirstToken(node);
      if (options.flatTernaryExpressions && (0, ast_exports.isTokenOnSameLine)(test, consequent) && !isOnFirstLineOfStatement(firstToken, node)) return;
      const ternaryOptions = options.offsetTernaryExpressions === true ? {
        CallExpression: options.offsetTernaryExpressionsOffsetCallExpressions ?? true,
        AwaitExpression: options.offsetTernaryExpressionsOffsetCallExpressions ?? true,
        NewExpression: true
      } : options.offsetTernaryExpressions;
      function checkBranch(branch, branchFirstToken) {
        let offset2 = 1;
        if (ternaryOptions) {
          const branchType = skipChainExpression(branch).type;
          if (branchFirstToken.type === "Punctuator" || ternaryOptions[branchType]) offset2 = 2;
        }
        offsets.setDesiredOffset(branchFirstToken, firstToken, offset2);
      }
      const questionMarkToken = sourceCode.getFirstTokenBetween(test, consequent, isQuestionToken);
      const colonToken = sourceCode.getFirstTokenBetween(consequent, alternate, ast_exports.isColonToken);
      const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
      const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
      const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
      offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
      offsets.setDesiredOffset(colonToken, firstToken, 1);
      checkBranch(consequent, firstConsequentToken);
      if ((0, ast_exports.isTokenOnSameLine)(lastConsequentToken, firstAlternateToken)) offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
      else checkBranch(alternate, firstAlternateToken);
    }
    function checkOperatorToken(left, right, operator) {
      const operatorToken = sourceCode.getFirstTokenBetween(left, right, (token) => token.value === operator);
      const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken);
      offsets.ignoreToken(operatorToken);
      offsets.ignoreToken(tokenAfterOperator);
      offsets.setDesiredOffset(tokenAfterOperator, operatorToken, 0);
    }
    function checkMemberExpression(node, object, property, computed = false) {
      const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, property, ast_exports.isNotClosingParenToken);
      const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
      const objectParenCount = sourceCode.getTokensBetween(object, property, { filter: ast_exports.isClosingParenToken }).length;
      const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 }) : sourceCode.getFirstToken(object);
      const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
      const firstPropertyToken = computed ? firstNonObjectToken : secondNonObjectToken;
      if (computed) {
        offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
        offsets.setDesiredOffsets(property.range, firstNonObjectToken, 1);
      }
      const offsetBase = (0, ast_exports.isTokenOnSameLine)(lastObjectToken, firstPropertyToken) ? lastObjectToken : firstObjectToken;
      if (typeof options.MemberExpression === "number") {
        offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
        offsets.setDesiredOffset(secondNonObjectToken, computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
      } else {
        offsets.ignoreToken(firstNonObjectToken);
        offsets.ignoreToken(secondNonObjectToken);
        offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
        offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
      }
    }
    function checkBlockLikeNode(node) {
      let blockIndentLevel;
      if (node.parent && isOuterIIFE(node.parent)) blockIndentLevel = options.outerIIFEBody;
      else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) blockIndentLevel = options.FunctionExpression.body;
      else if (node.parent && node.parent.type === "FunctionDeclaration") blockIndentLevel = options.FunctionDeclaration.body;
      else blockIndentLevel = 1;
      if (!STATEMENT_LIST_PARENTS.has(node.parent.type)) offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
      addElementListIndent(node.type === import_types.AST_NODE_TYPES.TSEnumBody ? node.members : node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
    }
    function checkHeritages(node, heritages) {
      const classToken = sourceCode.getFirstToken(node);
      const extendsToken = sourceCode.getTokenBefore(heritages[0], ast_exports.isNotOpeningParenToken);
      offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
    }
    function checkClassProperty(node) {
      const firstToken = sourceCode.getFirstToken(node);
      const lastToken = sourceCode.getLastToken(node);
      let keyLastToken;
      if (node.computed) {
        const bracketTokenL = sourceCode.getTokenBefore(node.key, ast_exports.isOpeningBracketToken);
        const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, ast_exports.isClosingBracketToken);
        const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];
        if (bracketTokenL !== firstToken) offsets.setDesiredOffset(bracketTokenL, firstToken, 0);
        offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);
        offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);
      } else {
        const idToken = keyLastToken = sourceCode.getFirstToken(node.key);
        if (!node.decorators?.length && idToken !== firstToken) offsets.setDesiredOffset(idToken, firstToken, 1);
      }
      if (node.value) {
        const operator = sourceCode.getTokenBefore(node.value, isEqToken);
        checkAssignmentOperator(operator);
        if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.setDesiredOffset(lastToken, operator, 1);
      } else if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.setDesiredOffset(lastToken, keyLastToken, 1);
    }
    const baseOffsetListeners = {
      "ArrayExpression": checkArrayLikeNode,
      "ArrayPattern": checkArrayLikeNode,
      ObjectExpression(node) {
        checkObjectLikeNode(node, node.properties);
      },
      ObjectPattern(node) {
        checkObjectLikeNode(node, node.properties);
      },
      ArrowFunctionExpression(node) {
        const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });
        if ((0, ast_exports.isOpeningParenToken)(maybeOpeningParen)) {
          const openingParen = maybeOpeningParen;
          const closingParen = sourceCode.getTokenBefore(node.returnType ?? node.body, { filter: ast_exports.isClosingParenToken });
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
        }
        addBlocklessNodeIndent(node.body);
      },
      AssignmentExpression(node) {
        checkAssignmentOperator(sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator));
      },
      AssignmentPattern(node) {
        checkAssignmentOperator(sourceCode.getFirstTokenBetween(node.left, node.right, isEqToken));
      },
      BinaryExpression(node) {
        checkOperatorToken(node.left, node.right, node.operator);
      },
      LogicalExpression(node) {
        checkOperatorToken(node.left, node.right, node.operator);
      },
      "BlockStatement": checkBlockLikeNode,
      "ClassBody": checkBlockLikeNode,
      "CallExpression": addFunctionCallIndent,
      ClassDeclaration(node) {
        if (!node.superClass) return;
        checkHeritages(node, [node.superClass]);
      },
      ClassExpression(node) {
        if (!node.superClass) return;
        checkHeritages(node, [node.superClass]);
      },
      ConditionalExpression(node) {
        checkConditionalNode(node, node.test, node.consequent, node.alternate);
      },
      "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement": function(node) {
        addBlocklessNodeIndent(node.body);
      },
      ExportNamedDeclaration(node) {
        if (node.declaration === null) {
          const closingCurly = node.source ? sourceCode.getTokenBefore(node.source, ast_exports.isClosingBraceToken) : sourceCode.getLastToken(node, ast_exports.isClosingBraceToken);
          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);
          if (node.source) {
            const fromToken = sourceCode.getTokenAfter(closingCurly, (token) => token.type === "Identifier" && token.value === "from");
            const lastToken = sourceCode.getLastToken(node, ast_exports.isNotSemicolonToken);
            offsets.setDesiredOffsets([fromToken.range[0], lastToken.range[1]], sourceCode.getFirstToken(node), 1);
            const lastClosingCurly = sourceCode.getLastToken(node, ast_exports.isClosingBraceToken);
            if (lastClosingCurly && node.source.range[1] < lastClosingCurly.range[0]) {
              const openingCurly = sourceCode.getTokenAfter(node.source, ast_exports.isOpeningBraceToken);
              const closingCurly2 = lastClosingCurly;
              addElementListIndent(node.attributes, openingCurly, closingCurly2, 1);
            }
          }
        }
      },
      ExportAllDeclaration(node) {
        const fromToken = sourceCode.getTokenAfter(node.exported || sourceCode.getFirstToken(node), (token) => token.type === "Identifier" && token.value === "from");
        const lastToken = sourceCode.getLastToken(node, ast_exports.isNotSemicolonToken);
        offsets.setDesiredOffsets([fromToken.range[0], lastToken.range[1]], sourceCode.getFirstToken(node), 1);
        const lastClosingCurly = sourceCode.getLastToken(node, ast_exports.isClosingBraceToken);
        if (lastClosingCurly && node.source.range[1] < lastClosingCurly.range[0]) {
          const openingCurly = sourceCode.getTokenAfter(node.source, ast_exports.isOpeningBraceToken);
          const closingCurly = lastClosingCurly;
          addElementListIndent(node.attributes, openingCurly, closingCurly, 1);
        }
      },
      ForStatement(node) {
        const forOpeningParen = sourceCode.getFirstToken(node, 1);
        if (node.init) offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
        if (node.test) offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
        if (node.update) offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
        addBlocklessNodeIndent(node.body);
      },
      "FunctionDeclaration, FunctionExpression": function(node) {
        const paramsClosingParen = sourceCode.getTokenBefore(node.returnType ?? node.body, { filter: ast_exports.isClosingParenToken });
        const paramsOpeningParen = sourceCode.getTokenBefore(node.params.length ? node.params[0].decorators?.[0] ?? node.params[0] : paramsClosingParen, { filter: ast_exports.isOpeningParenToken });
        parameterParens.add(paramsOpeningParen);
        parameterParens.add(paramsClosingParen);
        addElementListIndent(node.params, paramsOpeningParen, paramsClosingParen, options[node.type].parameters);
        if (node.returnType) offsets.setDesiredOffsets(node.returnType.range, paramsClosingParen, options[node.type].returnType);
      },
      IfStatement(node) {
        addBlocklessNodeIndent(node.consequent);
        if (node.alternate) addBlocklessNodeIndent(node.alternate);
      },
      ":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit": function(node) {
        let nodesToCheck;
        if (node.type === "IfStatement") {
          nodesToCheck = [node.consequent];
          if (node.alternate) nodesToCheck.push(node.alternate);
        } else nodesToCheck = [node.body];
        for (const nodeToCheck of nodesToCheck) {
          const lastToken = sourceCode.getLastToken(nodeToCheck);
          if ((0, ast_exports.isSemicolonToken)(lastToken)) {
            const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);
            const tokenAfterLast = sourceCode.getTokenAfter(lastToken);
            if (!(0, ast_exports.isTokenOnSameLine)(tokenBeforeLast, lastToken) && tokenAfterLast && (0, ast_exports.isTokenOnSameLine)(lastToken, tokenAfterLast)) offsets.setDesiredOffset(lastToken, sourceCode.getFirstToken(node), 0);
          }
        }
      },
      ImportDeclaration(node) {
        if (node.specifiers.some((specifier) => specifier.type === "ImportSpecifier")) {
          const openingCurly = sourceCode.getFirstToken(node, ast_exports.isOpeningBraceToken);
          const closingCurly = sourceCode.getTokenBefore(node.source, ast_exports.isClosingBraceToken);
          addElementListIndent(node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
        }
        const fromToken = node.specifiers.length ? sourceCode.getTokenAfter(node.specifiers[node.specifiers.length - 1], (token) => token.type === "Identifier" && token.value === "from") : sourceCode.getFirstToken(node, (token) => token.type === "Identifier" && token.value === "from");
        const lastToken = sourceCode.getLastToken(node, ast_exports.isNotSemicolonToken);
        if (fromToken) offsets.setDesiredOffsets([fromToken.range[0], lastToken.range[1]], sourceCode.getFirstToken(node), 1);
        const lastClosingCurly = sourceCode.getLastToken(node, ast_exports.isClosingBraceToken);
        if (lastClosingCurly && node.source.range[1] < lastClosingCurly.range[0]) {
          const openingCurly = sourceCode.getTokenAfter(node.source, ast_exports.isOpeningBraceToken);
          const closingCurly = lastClosingCurly;
          if (!fromToken) {
            const withToken = sourceCode.getTokenBefore(openingCurly, (token) => token.value === "with");
            offsets.setDesiredOffsets([withToken.range[0], lastToken.range[1]], sourceCode.getFirstToken(node), 1);
          }
          addElementListIndent(node.attributes, openingCurly, closingCurly, 1);
        }
      },
      ImportExpression(node) {
        const openingParen = sourceCode.getFirstToken(node, 1);
        const closingParen = sourceCode.getLastToken(node);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
        addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);
      },
      MemberExpression(node) {
        checkMemberExpression(node, node.object, node.property, node.computed);
      },
      MetaProperty(node) {
        checkMemberExpression(node, node.meta, node.property);
      },
      NewExpression(node) {
        if (node.arguments.length > 0 || (0, ast_exports.isClosingParenToken)(sourceCode.getLastToken(node)) && (0, ast_exports.isOpeningParenToken)(sourceCode.getLastToken(node, 1))) addFunctionCallIndent(node);
      },
      Property(node) {
        if (!node.shorthand && !node.method && node.kind === "init") {
          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, ast_exports.isColonToken);
          offsets.ignoreToken(sourceCode.getTokenAfter(colon));
        }
      },
      "PropertyDefinition": checkClassProperty,
      "AccessorProperty": checkClassProperty,
      "TSAbstractPropertyDefinition": checkClassProperty,
      "TSAbstractAccessorProperty": checkClassProperty,
      StaticBlock(node) {
        const openingCurly = sourceCode.getFirstToken(node, { skip: 1 });
        const closingCurly = sourceCode.getLastToken(node);
        addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);
      },
      SwitchStatement(node) {
        const openingCurly = sourceCode.getTokenAfter(node.discriminant, ast_exports.isOpeningBraceToken);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);
        if (node.cases.length) getCommentsBetween(sourceCode, node.cases[node.cases.length - 1], closingCurly).forEach((token) => offsets.ignoreToken(token));
      },
      SwitchCase(node) {
        if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
          const caseKeyword = sourceCode.getFirstToken(node);
          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);
          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
        }
      },
      TemplateLiteral(node) {
        node.expressions.forEach((expression, index2) => {
          const previousQuasi = node.quasis[index2];
          const nextQuasi = node.quasis[index2 + 1];
          const tokenToAlignFrom = isSingleLine(previousQuasi) ? sourceCode.getFirstToken(previousQuasi) : null;
          const startsOnSameLine = (0, ast_exports.isTokenOnSameLine)(previousQuasi, expression);
          const endsOnSameLine = (0, ast_exports.isTokenOnSameLine)(expression, nextQuasi);
          if (tokenToAlignFrom || endsOnSameLine && !startsOnSameLine) {
            offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
            offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
            return;
          }
          const tokenBeforeText = sourceCode.text.slice(previousQuasi.range[1] - previousQuasi.loc.end.column, previousQuasi.range[1] - 2).split("");
          let numIndentation = tokenBeforeText.findIndex((char) => char !== " " && char !== "	");
          if (numIndentation === -1) numIndentation = tokenBeforeText.length;
          const numSpaces = tokenBeforeText.slice(0, numIndentation).filter((char) => char === " ").length;
          const indentOffset = numIndentation - numSpaces + Math.ceil(numSpaces / (indentType === "tab" ? options.tabLength : indentSize));
          const innerIndentation = endsOnSameLine ? indentOffset : indentOffset + 1;
          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, innerIndentation);
          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, indentOffset);
        });
      },
      VariableDeclaration(node) {
        if (node.declarations.length === 0) return;
        const kind = node.kind === "await using" ? "using" : node.kind;
        let variableIndent = Object.hasOwn(options.VariableDeclarator, kind) ? options.VariableDeclarator[kind] : DEFAULT_VARIABLE_INDENT;
        const alignFirstVariable = variableIndent === "first";
        const firstToken = sourceCode.getFirstToken(node);
        const lastToken = sourceCode.getLastToken(node);
        if (node.declarations.at(-1).loc.start.line > node.loc.start.line) {
          if (alignFirstVariable) {
            addElementListIndent(node.declarations, firstToken, lastToken, variableIndent);
            const firstTokenOfFirstElement = sourceCode.getFirstToken(node.declarations[0]);
            variableIndent = (tokenInfo.getTokenIndent(firstTokenOfFirstElement).length - tokenInfo.getTokenIndent(firstToken).length) / indentSize;
          }
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
        } else {
          if (alignFirstVariable) variableIndent = DEFAULT_VARIABLE_INDENT;
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
        }
        if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.ignoreToken(lastToken);
      },
      VariableDeclarator(node) {
        if (node.init) checkAssignmentOperator(sourceCode.getTokenBefore(node.init, ast_exports.isNotOpeningParenToken));
        const lastToken = sourceCode.getLastToken(node);
        if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.ignoreToken(lastToken);
      },
      JSXText(node) {
        if (!node.parent) return;
        if (node.parent.type !== "JSXElement" && node.parent.type !== "JSXFragment") return;
        const nodeIndentRegExp = new RegExp(`
(${offsets._indentType}*)[	 ]*\\S`, "g");
        const nodeIndentsPerLine = Array.from(String(node.value).matchAll(nodeIndentRegExp), (match) => match[1] ? match[1].length : 0);
        if (nodeIndentsPerLine.length === 0) return;
        const parentIndentText = sourceCode.lines[node.parent.loc.start.line - 1].slice(0, node.parent.loc.start.column);
        const parentIndent = new RegExp(`^[${offsets._indentType}]+`).exec(parentIndentText);
        const targetIndent = (parentIndent ? parentIndent[0].length : 0) + indentSize;
        nodeIndentsPerLine.forEach((nodeIndent) => {
          if (nodeIndent === targetIndent) return;
          context.report({
            node,
            messageId: "wrongIndentation",
            data: createErrorMessageData(targetIndent, nodeIndent, nodeIndent),
            fix(fixer) {
              const indentStr = new Array(targetIndent + 1).join(offsets._indentType);
              const fixedText = node.raw.replace(/\n[\t ]*(\S)/g, (match, p1) => `
${indentStr}${p1}`);
              return fixer.replaceText(node, fixedText);
            }
          });
        });
      },
      JSXAttribute(node) {
        if (!node.value) return;
        checkAssignmentOperator(sourceCode.getFirstTokenBetween(node.name, node.value, isEqToken));
      },
      JSXElement(node) {
        if (node.closingElement) addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
      },
      JSXOpeningElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        let closingToken;
        if (node.selfClosing) {
          closingToken = sourceCode.getLastToken(node, { skip: 1 });
          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
        } else closingToken = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets(node.name.range, firstToken, 0);
        addElementListIndent(node.attributes, firstToken, closingToken, 1);
      },
      JSXClosingElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        offsets.setDesiredOffsets(node.name.range, firstToken, 1);
      },
      JSXFragment(node) {
        const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);
        const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);
        addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);
      },
      JSXOpeningFragment(node) {
        const firstToken = sourceCode.getFirstToken(node);
        const closingToken = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets(node.range, firstToken, 1);
        offsets.matchOffsetOf(firstToken, closingToken);
      },
      JSXClosingFragment(node) {
        const firstToken = sourceCode.getFirstToken(node);
        const closingToken = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets(node.range, firstToken, 1);
        const slashToken = sourceCode.getLastToken(node, (token) => token.value === "/");
        if (slashToken) {
          const tokenToMatch = (0, ast_exports.isTokenOnSameLine)(slashToken, closingToken) ? slashToken : closingToken;
          offsets.matchOffsetOf(firstToken, tokenToMatch);
        }
      },
      JSXExpressionContainer(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
      },
      JSXSpreadAttribute(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
      },
      JSXMemberExpression(node) {
        checkMemberExpression(node, node.object, node.property);
      },
      TSTypeAliasDeclaration(node) {
        checkAssignmentOperator(sourceCode.getTokenBefore(node.typeAnnotation, ast_exports.isNotOpeningParenToken));
        const lastToken = sourceCode.getLastToken(node);
        if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.ignoreToken(lastToken);
      },
      "TSTupleType": checkArrayLikeNode,
      "TSEnumBody": checkBlockLikeNode,
      TSEnumMember(node) {
        if (!node.initializer) return;
        checkAssignmentOperator(sourceCode.getTokenBefore(node.initializer, isEqToken));
      },
      TSTypeLiteral(node) {
        checkObjectLikeNode(node, node.members);
      },
      TSMappedType(node) {
        const startToken = sourceCode.getFirstToken(node, ast_exports.isOpeningBraceToken);
        const endToken = sourceCode.getLastToken(node, ast_exports.isClosingBraceToken);
        offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, 1);
        offsets.setDesiredOffset(endToken, startToken, 0);
      },
      TSAsExpression(node) {
        checkOperatorToken(node.expression, node.typeAnnotation, "as");
      },
      TSConditionalType(node) {
        checkConditionalNode(node, node.extendsType, node.trueType, node.falseType);
      },
      TSImportEqualsDeclaration(node) {
        if (node.moduleReference) checkAssignmentOperator(sourceCode.getTokenBefore(node.moduleReference, isEqToken));
        const lastToken = sourceCode.getLastToken(node);
        if ((0, ast_exports.isSemicolonToken)(lastToken)) offsets.ignoreToken(lastToken);
      },
      TSIndexedAccessType(node) {
        checkMemberExpression(node, node.objectType, node.indexType, true);
      },
      "TSInterfaceBody": checkBlockLikeNode,
      TSInterfaceDeclaration(node) {
        if (node.extends.length === 0) return;
        checkHeritages(node, node.extends);
      },
      TSQualifiedName(node) {
        checkMemberExpression(node, node.left, node.right);
      },
      TSTypeParameter(node) {
        if (!node.default) return;
        checkAssignmentOperator(sourceCode.getTokenBefore(node.default, isEqToken));
      },
      TSTypeParameterDeclaration(node) {
        if (!node.params.length) return;
        const firstToken = sourceCode.getFirstToken(node);
        const closingToken = sourceCode.getLastToken(node);
        addElementListIndent(node.params, firstToken, closingToken, 1);
      },
      TSTypeParameterInstantiation(node) {
        if (!node.params.length) return;
        const firstToken = sourceCode.getFirstToken(node);
        const closingToken = sourceCode.getLastToken(node);
        addElementListIndent(node.params, firstToken, closingToken, 1);
      },
      "TSModuleBlock": checkBlockLikeNode,
      "*": function(node) {
        const firstToken = sourceCode.getFirstToken(node);
        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) offsets.setDesiredOffsets(node.range, firstToken, 0);
      }
    };
    const listenerCallQueue = [];
    const offsetListeners = {};
    for (const [selector, listener] of Object.entries(baseOffsetListeners)) offsetListeners[selector] = (node) => listenerCallQueue.push({
      listener,
      node
    });
    const ignoredNodes = /* @__PURE__ */ new Set();
    function addToIgnoredNodes(node) {
      ignoredNodes.add(node);
      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
    }
    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }), {});
    return {
      ...offsetListeners,
      ...ignoredNodeListeners,
      "*:exit": function(node) {
        if (!KNOWN_NODES.has(node.type)) addToIgnoredNodes(node);
      },
      "Program:exit": function() {
        if (options.ignoreComments) sourceCode.getAllComments().forEach((comment) => offsets.ignoreToken(comment));
        for (let i = 0; i < listenerCallQueue.length; i++) {
          const nodeInfo = listenerCallQueue[i];
          if (!ignoredNodes.has(nodeInfo.node)) nodeInfo.listener?.(nodeInfo.node);
        }
        ignoredNodes.forEach(ignoreNode);
        addParensIndent(sourceCode.ast.tokens);
        const precedingTokens = /* @__PURE__ */ new WeakMap();
        for (let i = 0; i < sourceCode.ast.comments.length; i++) {
          const comment = sourceCode.ast.comments[i];
          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
          const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;
          precedingTokens.set(comment, hasToken);
        }
        for (let i = 1; i < sourceCode.lines.length + 1; i++) {
          if (!tokenInfo.firstTokensByLineNumber.has(i)) continue;
          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);
          if (firstTokenOfLine.loc.start.line !== i) continue;
          if ((0, ast_exports.isCommentToken)(firstTokenOfLine)) {
            const tokenBefore = precedingTokens.get(firstTokenOfLine);
            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);
            if (tokenAfter && (0, ast_exports.isSemicolonToken)(tokenAfter) && !(0, ast_exports.isTokenOnSameLine)(firstTokenOfLine, tokenAfter)) offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);
            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) continue;
          }
          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) continue;
          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
        }
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-child-element-spacing.js
var INLINE_ELEMENTS = /* @__PURE__ */ new Set([
  "a",
  "abbr",
  "acronym",
  "b",
  "bdo",
  "big",
  "button",
  "cite",
  "code",
  "dfn",
  "em",
  "i",
  "img",
  "input",
  "kbd",
  "label",
  "map",
  "object",
  "q",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "textarea",
  "tt",
  "var"
]);
var jsx_child_element_spacing_default = createRule({
  name: "jsx-child-element-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce or disallow spaces inside of curly braces in JSX attributes and expressions" },
    schema: [],
    messages: {
      spacingAfterPrev: "Ambiguous spacing after previous element {{element}}",
      spacingBeforeNext: "Ambiguous spacing before next element {{element}}"
    }
  },
  create(context) {
    const TEXT_FOLLOWING_ELEMENT_PATTERN = /^[\t\v\f\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\n\s*\S/;
    const TEXT_PRECEDING_ELEMENT_PATTERN = /\S[\t\v\f\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\n\s*$/;
    const elementName = (node) => node.openingElement && node.openingElement.name && node.openingElement.name.type === "JSXIdentifier" && node.openingElement.name.name || "";
    const isInlineElement = (node) => node.type === "JSXElement" && INLINE_ELEMENTS.has(elementName(node));
    const handleJSX = (node) => {
      let lastChild = null;
      let child = null;
      [...node.children, null].forEach((nextChild) => {
        if ((lastChild || nextChild) && (!lastChild || isInlineElement(lastChild)) && child && (child.type === "Literal" || child.type === "JSXText") && (!nextChild || isInlineElement(nextChild)) && true) {
          if (lastChild && String(child.value).match(TEXT_FOLLOWING_ELEMENT_PATTERN)) context.report({
            messageId: "spacingAfterPrev",
            node: lastChild,
            loc: lastChild.loc.end,
            data: { element: elementName(lastChild) }
          });
          else if (nextChild && String(child.value).match(TEXT_PRECEDING_ELEMENT_PATTERN)) context.report({
            messageId: "spacingBeforeNext",
            node: nextChild,
            loc: nextChild.loc.start,
            data: { element: elementName(nextChild) }
          });
        }
        lastChild = child;
        child = nextChild;
      });
    };
    return {
      JSXElement: handleJSX,
      JSXFragment: handleJSX
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-closing-bracket-location.js
var jsx_closing_bracket_location_default = createRule({
  name: "jsx-closing-bracket-location",
  meta: {
    type: "layout",
    docs: { description: "Enforce closing bracket location in JSX" },
    fixable: "code",
    schema: [{ anyOf: [
      {
        type: "string",
        enum: [
          "after-props",
          "props-aligned",
          "tag-aligned",
          "line-aligned"
        ]
      },
      {
        type: "object",
        properties: { location: {
          type: "string",
          enum: [
            "after-props",
            "props-aligned",
            "tag-aligned",
            "line-aligned"
          ]
        } },
        additionalProperties: false
      },
      {
        type: "object",
        properties: {
          nonEmpty: { oneOf: [{
            type: "string",
            enum: [
              "after-props",
              "props-aligned",
              "tag-aligned",
              "line-aligned"
            ]
          }, {
            type: "boolean",
            enum: [false]
          }] },
          selfClosing: { oneOf: [{
            type: "string",
            enum: [
              "after-props",
              "props-aligned",
              "tag-aligned",
              "line-aligned"
            ]
          }, {
            type: "boolean",
            enum: [false]
          }] }
        },
        additionalProperties: false
      }
    ] }],
    defaultOptions: ["tag-aligned"],
    messages: { bracketLocation: "The closing bracket must be {{location}}{{details}}" }
  },
  create(context, [config]) {
    const MESSAGE_LOCATION2 = {
      "after-props": "placed after the last prop",
      "after-tag": "placed after the opening tag",
      "props-aligned": "aligned with the last prop",
      "tag-aligned": "aligned with the opening tag",
      "line-aligned": "aligned with the line containing the opening tag"
    };
    const { nonEmpty = "tag-aligned", selfClosing = "tag-aligned" } = typeof config === "string" ? {
      nonEmpty: config,
      selfClosing: config
    } : "location" in config ? {
      nonEmpty: config.location,
      selfClosing: config.location
    } : config;
    function getExpectedLocation(tokens) {
      let location;
      if (typeof tokens.lastProp === "undefined") location = "after-tag";
      else if (tokens.opening.line === tokens.lastProp.lastLine) location = "after-props";
      else location = tokens.selfClosing ? selfClosing : nonEmpty;
      return location;
    }
    function getCorrectColumn(tokens, expectedLocation) {
      switch (expectedLocation) {
        case "props-aligned":
          return tokens.lastProp.column;
        case "tag-aligned":
          return tokens.opening.column;
        case "line-aligned":
          return tokens.openingStartOfLine.column;
        default:
          return null;
      }
    }
    function hasCorrectLocation(tokens, expectedLocation) {
      switch (expectedLocation) {
        case "after-tag":
          return tokens.tag.line === tokens.closing.line;
        case "after-props":
          return tokens.lastProp.lastLine === tokens.closing.line;
        case "props-aligned":
        case "tag-aligned":
        case "line-aligned":
          return getCorrectColumn(tokens, expectedLocation) === tokens.closing.column;
        default:
          return true;
      }
    }
    function getIndentation(tokens, expectedLocation, correctColumn) {
      const newColumn = correctColumn || 0;
      let indentation;
      let spaces = [];
      switch (expectedLocation) {
        case "props-aligned":
          indentation = /^\s*/.exec(context.sourceCode.lines[tokens.lastProp.firstLine - 1])[0];
          break;
        case "tag-aligned":
        case "line-aligned":
          indentation = /^\s*/.exec(context.sourceCode.lines[tokens.opening.line - 1])[0];
          break;
        default:
          indentation = "";
      }
      if (indentation.length + 1 < newColumn) spaces = Array.from({ length: +correctColumn + 1 - indentation.length });
      return indentation + spaces.join(" ");
    }
    function getTokensLocations(node) {
      const sourceCode = context.sourceCode;
      const opening = sourceCode.getFirstToken(node).loc.start;
      const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
      const tag = sourceCode.getFirstToken(node.name).loc.start;
      let lastProp;
      if (node.attributes.length) {
        lastProp = node.attributes[node.attributes.length - 1];
        lastProp = {
          column: sourceCode.getFirstToken(lastProp).loc.start.column,
          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
          lastLine: sourceCode.getLastToken(lastProp).loc.end.line
        };
      }
      const openingLine = sourceCode.lines[opening.line - 1];
      const closingLine = sourceCode.lines[closing.line - 1];
      const isTab = {
        openTab: /^\t/.test(openingLine),
        closeTab: /^\t/.test(closingLine)
      };
      const openingStartOfLine = {
        column: /^\s*/.exec(openingLine)?.[0].length,
        line: opening.line
      };
      return {
        isTab,
        tag,
        opening,
        closing,
        lastProp,
        selfClosing: node.selfClosing,
        openingStartOfLine
      };
    }
    return { "JSXOpeningElement:exit": function(node) {
      const lastAttributeNode = node.attributes.at(-1);
      const cachedLastAttributeEndPos = lastAttributeNode ? lastAttributeNode.range[1] : null;
      let expectedNextLine;
      const tokens = getTokensLocations(node);
      let expectedLocation = getExpectedLocation(tokens);
      let usingSameIndentation = true;
      if (expectedLocation === "tag-aligned") usingSameIndentation = tokens.isTab.openTab === tokens.isTab.closeTab;
      const lastComment = context.sourceCode.getCommentsInside(node).at(-1);
      const hasTrailingComment = lastComment && lastComment.range[0] > (lastAttributeNode ?? node.name).range[1];
      if ((expectedLocation === "after-props" || expectedLocation === "after-tag") && !(hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) && hasTrailingComment) expectedLocation = "line-aligned";
      if (hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) return;
      const data2 = {
        location: MESSAGE_LOCATION2[expectedLocation],
        details: ""
      };
      const correctColumn = getCorrectColumn(tokens, expectedLocation);
      if (correctColumn !== null) {
        expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;
        data2.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? " on the next line)" : ")"}`;
      }
      context.report({
        node,
        messageId: "bracketLocation",
        loc: tokens.closing,
        data: data2,
        fix(fixer) {
          const closingTag = tokens.selfClosing ? "/>" : ">";
          switch (expectedLocation) {
            case "after-tag":
              if (cachedLastAttributeEndPos) return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? "\n" : "") + closingTag);
              return fixer.replaceTextRange([node.name.range[1], node.range[1]], (expectedNextLine ? "\n" : " ") + closingTag);
            case "after-props":
              return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? "\n" : "") + closingTag);
            case "props-aligned":
            case "tag-aligned":
            case "line-aligned": {
              const rangeStart = hasTrailingComment ? lastComment.range[1] : cachedLastAttributeEndPos;
              return fixer.replaceTextRange([rangeStart, node.range[1]], `
${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`);
            }
          }
          return null;
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-closing-tag-location.js
var MESSAGE_LOCATION = {
  "tag-aligned": "matchIndent",
  "line-aligned": "alignWithOpening"
};
var jsx_closing_tag_location_default = createRule({
  name: "jsx-closing-tag-location",
  meta: {
    type: "layout",
    docs: { description: "Enforce closing tag location for multiline JSX" },
    fixable: "whitespace",
    schema: [{ anyOf: [{
      type: "string",
      enum: ["tag-aligned", "line-aligned"]
    }] }],
    defaultOptions: ["tag-aligned"],
    messages: {
      onOwnLine: "Closing tag of a multiline JSX expression must be on its own line.",
      matchIndent: "Expected closing tag to match indentation of opening.",
      alignWithOpening: "Expected closing tag to be aligned with the line containing the opening tag"
    }
  },
  create(context, [option]) {
    function getIndentation(openingStartOfLine, opening) {
      if (option === "line-aligned") return openingStartOfLine.column;
      else return opening.loc.start.column;
    }
    function handleClosingElement(node) {
      if (!node.parent) return;
      const sourceCode = context.sourceCode;
      const opening = "openingFragment" in node.parent ? node.parent.openingFragment : node.parent.openingElement;
      const openingLoc = sourceCode.getFirstToken(opening).loc.start;
      const openingLine = sourceCode.lines[openingLoc.line - 1];
      const openingStartOfLine = {
        column: /^\s*/.exec(openingLine)?.[0].length,
        line: openingLoc.line
      };
      if (opening.loc.start.line === node.loc.start.line) return;
      if (opening.loc.start.column === node.loc.start.column && option === "tag-aligned") return;
      if (openingStartOfLine.column === node.loc.start.column && option === "line-aligned") return;
      const messageId = isNodeFirstInLine(context, node) ? MESSAGE_LOCATION[option] : "onOwnLine";
      context.report({
        node,
        messageId,
        loc: node.loc,
        fix(fixer) {
          const indent = new Array((getIndentation(openingStartOfLine, opening) || 0) + 1).join(" ");
          if (isNodeFirstInLine(context, node)) return fixer.replaceTextRange([node.range[0] - node.loc.start.column, node.range[0]], indent);
          return fixer.insertTextBefore(node, `
${indent}`);
        }
      });
    }
    return {
      JSXClosingElement: handleClosingElement,
      JSXClosingFragment: handleClosingElement
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-curly-brace-presence.js
var OPTION_VALUES = [
  "always",
  "never",
  "ignore"
];
var jsx_curly_brace_presence_default = createRule({
  name: "jsx-curly-brace-presence",
  meta: {
    type: "layout",
    docs: { description: "Disallow unnecessary JSX expressions when literals alone are sufficient or enforce JSX expressions on literals in JSX children or attributes" },
    fixable: "code",
    schema: [{ anyOf: [{
      type: "object",
      properties: {
        props: {
          type: "string",
          enum: OPTION_VALUES
        },
        children: {
          type: "string",
          enum: OPTION_VALUES
        },
        propElementValues: {
          type: "string",
          enum: OPTION_VALUES
        }
      },
      additionalProperties: false
    }, {
      type: "string",
      enum: OPTION_VALUES
    }] }],
    defaultOptions: [{
      props: "never",
      children: "never",
      propElementValues: "ignore"
    }],
    messages: {
      unnecessaryCurly: "Curly braces are unnecessary here.",
      missingCurly: "Need to wrap this literal in a JSX expression."
    }
  },
  create(context, [options]) {
    const HTML_ENTITY_REGEX = () => /&[A-Z\d#]+;/gi;
    const { props, children, propElementValues } = typeof options === "string" ? {
      props: options,
      children: options,
      propElementValues: "ignore"
    } : options;
    function containsLineTerminators(rawStringValue) {
      return ast_exports.LINEBREAK_MATCHER.test(rawStringValue);
    }
    function containsBackslash(rawStringValue) {
      return rawStringValue.includes("\\");
    }
    function containsHTMLEntity(rawStringValue) {
      return HTML_ENTITY_REGEX().test(rawStringValue);
    }
    function containsOnlyHtmlEntities(rawStringValue) {
      return rawStringValue.replace(HTML_ENTITY_REGEX(), "").trim() === "";
    }
    function containsDisallowedJSXTextChars(rawStringValue) {
      return /[{<>}]/.test(rawStringValue);
    }
    function containsQuoteCharacters(value) {
      return /['"]/.test(value);
    }
    function containsMultilineComment(value) {
      return /\/\*/.test(value);
    }
    function escapeDoubleQuotes(rawStringValue) {
      return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
    }
    function escapeBackslashes(rawStringValue) {
      return rawStringValue.replace(/\\/g, "\\\\");
    }
    function needToEscapeCharacterForJSX(raw, node) {
      return containsBackslash(raw) || containsHTMLEntity(raw) || node.parent.type !== "JSXAttribute" && containsDisallowedJSXTextChars(raw);
    }
    function containsWhitespaceExpression(child) {
      if (child.type === "JSXExpressionContainer") {
        const value = child.expression.value;
        return value ? isWhiteSpaces(value) : false;
      }
      return false;
    }
    function isLineBreak(text) {
      return containsLineTerminators(text) && text.trim() === "";
    }
    function wrapNonHTMLEntities(text) {
      const HTML_ENTITY = "<HTML_ENTITY>";
      const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map((word) => word === "" ? "" : `{${JSON.stringify(word)}}`).join(HTML_ENTITY);
      return text.match(HTML_ENTITY_REGEX()).reduce((acc, htmlEntity) => acc.replace(HTML_ENTITY, htmlEntity), withCurlyBraces);
    }
    function wrapWithCurlyBraces(rawText) {
      if (!containsLineTerminators(rawText)) return `{${JSON.stringify(rawText)}}`;
      return rawText.split("\n").map((line) => {
        if (line.trim() === "") return line;
        const firstCharIndex = line.search(/\S/);
        const leftWhitespace = line.slice(0, firstCharIndex);
        const text = line.slice(firstCharIndex);
        if (containsHTMLEntity(line)) return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;
        return `${leftWhitespace}{${JSON.stringify(text)}}`;
      }).join("\n");
    }
    function reportUnnecessaryCurly(JSXExpressionNode) {
      context.report({
        messageId: "unnecessaryCurly",
        node: JSXExpressionNode,
        fix(fixer) {
          const expression = JSXExpressionNode.expression;
          let textToReplace;
          if (isJSX(expression)) textToReplace = context.sourceCode.getText(expression);
          else if (JSXExpressionNode.parent.type === "JSXAttribute") textToReplace = `"${expression.type === "TemplateLiteral" ? expression.quasis[0].value.raw : expression.raw.slice(1, -1)}"`;
          else if (isJSX(expression)) textToReplace = context.sourceCode.getText(expression);
          else textToReplace = expression.type === "TemplateLiteral" ? expression.quasis[0].value.cooked : expression.value;
          return fixer.replaceText(JSXExpressionNode, textToReplace);
        }
      });
    }
    function reportMissingCurly(literalNode) {
      context.report({
        messageId: "missingCurly",
        node: literalNode,
        fix(fixer) {
          if (isJSX(literalNode)) return fixer.replaceText(literalNode, `{${context.sourceCode.getText(literalNode)}}`);
          if (containsOnlyHtmlEntities(literalNode.raw) || literalNode.parent.type === "JSXAttribute" && containsLineTerminators(literalNode.raw) || isLineBreak(literalNode.raw)) return null;
          const expression = literalNode.parent.type === "JSXAttribute" ? `{"${escapeDoubleQuotes(escapeBackslashes(literalNode.raw.slice(1, -1)))}"}` : wrapWithCurlyBraces(literalNode.raw);
          return fixer.replaceText(literalNode, expression);
        }
      });
    }
    function isWhiteSpaceLiteral(node) {
      return node.type && node.type === "Literal" && node.value && isWhiteSpaces(node.value);
    }
    function isStringWithTrailingWhiteSpaces(value) {
      return /^\s|\s$/.test(value);
    }
    function isLiteralWithTrailingWhiteSpaces(node) {
      return node.type && node.type === "Literal" && node.value && isStringWithTrailingWhiteSpaces(node.value);
    }
    function lintUnnecessaryCurly(JSXExpressionNode) {
      const expression = JSXExpressionNode.expression;
      const expressionType = expression.type;
      const sourceCode = context.sourceCode;
      if (sourceCode.getCommentsInside && sourceCode.getCommentsInside(JSXExpressionNode).length > 0) return;
      if ((expressionType === "Literal" || expressionType === "JSXText") && typeof expression.value === "string" && (JSXExpressionNode.parent.type === "JSXAttribute" && !isWhiteSpaceLiteral(expression) || !isLiteralWithTrailingWhiteSpaces(expression)) && !containsMultilineComment(expression.value) && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (isJSX(JSXExpressionNode.parent) || !containsQuoteCharacters(expression.value))) reportUnnecessaryCurly(JSXExpressionNode);
      else if (expressionType === "TemplateLiteral" && expression.expressions.length === 0 && !expression.quasis[0].value.raw.includes("\n") && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw) && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode) && !containsQuoteCharacters(expression.quasis[0].value.cooked)) reportUnnecessaryCurly(JSXExpressionNode);
      else if (isJSX(expression)) reportUnnecessaryCurly(JSXExpressionNode);
    }
    function areRuleConditionsSatisfied(parent, ruleCondition) {
      return parent.type === "JSXAttribute" && props === ruleCondition || isJSX(parent) && children === ruleCondition;
    }
    function getAdjacentSiblings(node, children2) {
      for (let i = 1; i < children2.length - 1; i++) if (node === children2[i]) return [children2[i - 1], children2[i + 1]];
      if (node === children2[0] && children2[1]) return [children2[1]];
      if (node === children2[children2.length - 1] && children2[children2.length - 2]) return [children2[children2.length - 2]];
      return [];
    }
    function hasAdjacentJsxExpressionContainers(node, children2) {
      if (!children2) return false;
      return getAdjacentSiblings(node, children2.filter((child) => !isWhiteSpaceLiteral(child))).some((x) => x.type && x.type === "JSXExpressionContainer");
    }
    function hasAdjacentJsx(node, children2) {
      if (!children2) return false;
      return getAdjacentSiblings(node, children2.filter((child) => !isWhiteSpaceLiteral(child))).some((x) => x.type && ["JSXExpressionContainer", "JSXElement"].includes(x.type));
    }
    function shouldCheckForUnnecessaryCurly(node) {
      const parent = node.parent;
      if (parent.type && parent.type === "JSXAttribute" && node.expression && node.expression.type && node.expression.type !== "Literal" && node.expression.type !== "StringLiteral" && node.expression.type !== "TemplateLiteral") return false;
      if (isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) return false;
      if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) return false;
      if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(node)) return false;
      return areRuleConditionsSatisfied(parent, "never");
    }
    function shouldCheckForMissingCurly(node) {
      if (isJSX(node)) return propElementValues !== "ignore";
      if (isLineBreak(node.raw) || containsOnlyHtmlEntities(node.raw)) return false;
      const parent = node.parent;
      if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(parent.children[0])) return false;
      return areRuleConditionsSatisfied(parent, "always");
    }
    return {
      "JSXAttribute > JSXExpressionContainer > JSXElement": function(node) {
        if (propElementValues === "never") reportUnnecessaryCurly(node.parent);
      },
      JSXExpressionContainer(node) {
        if (shouldCheckForUnnecessaryCurly(node)) lintUnnecessaryCurly(node);
      },
      "JSXAttribute > JSXElement, Literal, JSXText": function(node) {
        if (shouldCheckForMissingCurly(node)) reportMissingCurly(node);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-curly-newline.js
var jsx_curly_newline_default = createRule({
  name: "jsx-curly-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent linebreaks in curly braces in JSX attributes and expressions" },
    fixable: "whitespace",
    schema: [{ anyOf: [{
      type: "string",
      enum: ["consistent", "never"]
    }, {
      type: "object",
      properties: {
        singleline: {
          type: "string",
          enum: [
            "consistent",
            "require",
            "forbid"
          ]
        },
        multiline: {
          type: "string",
          enum: [
            "consistent",
            "require",
            "forbid"
          ]
        }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["consistent"],
    messages: {
      expectedBefore: "Expected newline before '}'.",
      expectedAfter: "Expected newline after '{'.",
      unexpectedBefore: "Unexpected newline before '}'.",
      unexpectedAfter: "Unexpected newline after '{'."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const { multiline = "consistent", singleline = "consistent" } = options === "never" ? {
      multiline: "forbid",
      singleline: "forbid"
    } : typeof options === "string" ? {
      multiline: options,
      singleline: options
    } : options;
    function shouldHaveNewlines(expression, hasLeftNewline) {
      switch (!isSingleLine(expression) ? multiline : singleline) {
        case "forbid":
          return false;
        case "require":
          return true;
        default:
          return hasLeftNewline;
      }
    }
    function validateCurlys(curlys, expression) {
      const leftCurly = curlys.leftCurly;
      const rightCurly = curlys.rightCurly;
      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);
      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);
      const hasLeftNewline = !(0, ast_exports.isTokenOnSameLine)(leftCurly, tokenAfterLeftCurly);
      const hasRightNewline = !(0, ast_exports.isTokenOnSameLine)(tokenBeforeRightCurly, rightCurly);
      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);
      if (hasLeftNewline && !needsNewlines) context.report({
        node: leftCurly,
        messageId: "unexpectedAfter",
        fix: safeReplaceTextBetween(sourceCode, leftCurly, tokenAfterLeftCurly, "")
      });
      else if (!hasLeftNewline && needsNewlines) context.report({
        node: leftCurly,
        messageId: "expectedAfter",
        fix: (fixer) => fixer.insertTextAfter(leftCurly, "\n")
      });
      if (hasRightNewline && !needsNewlines) context.report({
        node: rightCurly,
        messageId: "unexpectedBefore",
        fix: safeReplaceTextBetween(sourceCode, tokenBeforeRightCurly, rightCurly, "")
      });
      else if (!hasRightNewline && needsNewlines) context.report({
        node: rightCurly,
        messageId: "expectedBefore",
        fix: (fixer) => fixer.insertTextBefore(rightCurly, "\n")
      });
    }
    return { JSXExpressionContainer(node) {
      validateCurlys({
        leftCurly: sourceCode.getFirstToken(node),
        rightCurly: sourceCode.getLastToken(node)
      }, node.expression);
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-curly-spacing.js
var SPACING = {
  always: "always",
  never: "never"
};
var SPACING_VALUES = ["always", "never"];
var BASIC_CONFIG_SCHEMA = {
  type: "object",
  properties: {
    when: {
      type: "string",
      enum: SPACING_VALUES
    },
    allowMultiline: { type: "boolean" },
    spacing: {
      type: "object",
      properties: { objectLiterals: {
        type: "string",
        enum: SPACING_VALUES
      } },
      additionalProperties: false
    }
  },
  additionalProperties: false
};
var BASIC_CONFIG_OR_BOOLEAN_SCHEMA = { anyOf: [BASIC_CONFIG_SCHEMA, { type: "boolean" }] };
var jsx_curly_spacing_default = createRule({
  name: "jsx-curly-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce or disallow spaces inside of curly braces in JSX attributes and expressions" },
    fixable: "code",
    schema: {
      type: "array",
      items: [{ anyOf: [{
        type: "object",
        additionalProperties: false,
        properties: {
          ...BASIC_CONFIG_SCHEMA.properties,
          attributes: BASIC_CONFIG_OR_BOOLEAN_SCHEMA,
          children: BASIC_CONFIG_OR_BOOLEAN_SCHEMA
        }
      }, {
        type: "string",
        enum: SPACING_VALUES
      }] }, {
        type: "object",
        properties: {
          allowMultiline: { type: "boolean" },
          spacing: {
            type: "object",
            properties: { objectLiterals: {
              type: "string",
              enum: SPACING_VALUES
            } },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }]
    },
    defaultOptions: [{
      when: "never",
      allowMultiline: true
    }],
    messages: {
      noNewlineAfter: "There should be no newline after '{{token}}'",
      noNewlineBefore: "There should be no newline before '{{token}}'",
      noSpaceAfter: "There should be no space after '{{token}}'",
      noSpaceBefore: "There should be no space before '{{token}}'",
      spaceNeededAfter: "A space is required after '{{token}}'",
      spaceNeededBefore: "A space is required before '{{token}}'"
    }
  },
  create(context, [firstOption, secondOption = {}]) {
    const { when: defaultWhen = "never", allowMultiline: defaultAllowMultiline = true, spacing: defaultSpacing = {}, attributes = true, children = false } = typeof firstOption === "string" ? {
      when: firstOption,
      ...secondOption
    } : firstOption;
    function normalizeConfig(configOrTrue) {
      const { when = defaultWhen, allowMultiline = defaultAllowMultiline, spacing = defaultSpacing } = configOrTrue === true ? {} : configOrTrue;
      return {
        when,
        allowMultiline,
        objectLiteralSpaces: spacing.objectLiterals ?? when
      };
    }
    const attributesConfig = attributes ? normalizeConfig(attributes) : null;
    const childrenConfig = children ? normalizeConfig(children) : null;
    const sourceCode = context.sourceCode;
    function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing = "") {
      let replacementText = sourceCode.text.slice(fromLoc, toLoc);
      if (mode === "start") replacementText = replacementText.replace(/^\s+/gm, "");
      else replacementText = replacementText.replace(/\s+$/gm, "");
      if (spacing === SPACING.always) if (mode === "start") replacementText += " ";
      else replacementText = ` ${replacementText}`;
      return fixer.replaceTextRange([fromLoc, toLoc], replacementText);
    }
    function reportNoBeginningNewline(node, token, spacing) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "noNewlineAfter",
        data: { token: token.value },
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token);
          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], "start", spacing);
        }
      });
    }
    function reportNoEndingNewline(node, token, spacing) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "noNewlineBefore",
        data: { token: token.value },
        fix(fixer) {
          return fixByTrimmingWhitespace(fixer, sourceCode.getTokenBefore(token).range[1], token.range[0], "end", spacing);
        }
      });
    }
    function reportNoBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "noSpaceAfter",
        data: { token: token.value },
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token);
          const nextComment = sourceCode.getCommentsAfter(token);
          if (nextComment.length > 0) return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].range[0]), "start");
          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], "start");
        }
      });
    }
    function reportNoEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "noSpaceBefore",
        data: { token: token.value },
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token);
          const previousComment = sourceCode.getCommentsBefore(token);
          if (previousComment.length > 0) return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].range[1]), token.range[0], "end");
          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], "end");
        }
      });
    }
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "spaceNeededAfter",
        data: { token: token.value },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "spaceNeededBefore",
        data: { token: token.value },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }
    function validateBraceSpacing(node) {
      let config;
      switch (node.parent?.type) {
        case "JSXAttribute":
        case "JSXOpeningElement":
          config = attributesConfig;
          break;
        case "JSXElement":
        case "JSXFragment":
          config = childrenConfig;
          break;
        default:
          return;
      }
      if (config === null) return;
      const first = sourceCode.getFirstToken(node);
      const last = sourceCode.getLastToken(node);
      let second = sourceCode.getTokenAfter(first, { includeComments: true });
      let penultimate = sourceCode.getTokenBefore(last, { includeComments: true });
      if (!second) {
        second = sourceCode.getTokenAfter(first);
        const leadingComments = sourceCode.getCommentsBefore(second);
        second = leadingComments ? leadingComments[0] : second;
      }
      if (!penultimate) {
        penultimate = sourceCode.getTokenBefore(last);
        const trailingComments = sourceCode.getCommentsAfter(penultimate);
        penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;
      }
      const spacing = first.value === second.value ? config.objectLiteralSpaces : config.when;
      if (spacing === SPACING.always) {
        if (!sourceCode.isSpaceBetween(first, second)) reportRequiredBeginningSpace(node, first);
        else if (!config.allowMultiline && !(0, ast_exports.isTokenOnSameLine)(first, second)) reportNoBeginningNewline(node, first, spacing);
        if (!sourceCode.isSpaceBetween(penultimate, last)) reportRequiredEndingSpace(node, last);
        else if (!config.allowMultiline && !(0, ast_exports.isTokenOnSameLine)(penultimate, last)) reportNoEndingNewline(node, last, spacing);
      } else if (spacing === SPACING.never) {
        if (!(0, ast_exports.isTokenOnSameLine)(first, second)) {
          if (!config.allowMultiline) reportNoBeginningNewline(node, first, spacing);
        } else if (sourceCode.isSpaceBetween(first, second)) reportNoBeginningSpace(node, first);
        if (!(0, ast_exports.isTokenOnSameLine)(penultimate, last)) {
          if (!config.allowMultiline) reportNoEndingNewline(node, last, spacing);
        } else if (sourceCode.isSpaceBetween(penultimate, last)) reportNoEndingSpace(node, last);
      }
    }
    return {
      JSXExpressionContainer: validateBraceSpacing,
      JSXSpreadAttribute: validateBraceSpacing
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-equals-spacing.js
var jsx_equals_spacing_default = createRule({
  name: "jsx-equals-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce or disallow spaces around equal signs in JSX attributes" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["never"],
    messages: {
      noSpaceBefore: "There should be no space before '='",
      noSpaceAfter: "There should be no space after '='",
      needSpaceBefore: "A space is required before '='",
      needSpaceAfter: "A space is required after '='"
    }
  },
  create(context, [config]) {
    return { JSXOpeningElement(node) {
      node.attributes.forEach((attrNode) => {
        if (!(attrNode.type !== "JSXSpreadAttribute" && attrNode.value !== null)) return;
        const sourceCode = context.sourceCode;
        const equalToken = sourceCode.getTokenAfter(attrNode.name);
        const spacedBefore = sourceCode.isSpaceBetween(attrNode.name, equalToken);
        const spacedAfter = sourceCode.isSpaceBetween(equalToken, attrNode.value);
        if (config === "never") {
          if (spacedBefore) context.report({
            node: attrNode,
            messageId: "noSpaceBefore",
            loc: equalToken.loc.start,
            fix(fixer) {
              return fixer.removeRange([attrNode.name.range[1], equalToken.range[0]]);
            }
          });
          if (spacedAfter) context.report({
            node: attrNode,
            messageId: "noSpaceAfter",
            loc: equalToken.loc.start,
            fix(fixer) {
              return fixer.removeRange([equalToken.range[1], attrNode.value.range[0]]);
            }
          });
        } else if (config === "always") {
          if (!spacedBefore) context.report({
            messageId: "needSpaceBefore",
            node: attrNode,
            loc: equalToken.loc.start,
            fix(fixer) {
              return fixer.insertTextBefore(equalToken, " ");
            }
          });
          if (!spacedAfter) context.report({
            node: attrNode,
            messageId: "needSpaceAfter",
            loc: equalToken.loc.start,
            fix(fixer) {
              return fixer.insertTextAfter(equalToken, " ");
            }
          });
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-first-prop-new-line.js
var jsx_first_prop_new_line_default = createRule({
  name: "jsx-first-prop-new-line",
  meta: {
    type: "layout",
    docs: { description: "Enforce proper position of the first property in JSX" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: [
        "always",
        "never",
        "multiline",
        "multiline-multiprop",
        "multiprop"
      ]
    }],
    defaultOptions: ["multiline-multiprop"],
    messages: {
      propOnNewLine: "Property should be placed on a new line",
      propOnSameLine: "Property should be placed on the same line as the component declaration"
    }
  },
  create(context, [configuration]) {
    return { JSXOpeningElement(node) {
      if (configuration === "multiline" && !isSingleLine(node) || configuration === "multiline-multiprop" && !isSingleLine(node) && node.attributes.length > 1 || configuration === "multiprop" && node.attributes.length > 1 || configuration === "always") node.attributes.some((decl) => {
        if (decl.loc.start.line === node.loc.start.line) context.report({
          node: decl,
          messageId: "propOnNewLine",
          fix(fixer) {
            return fixer.replaceTextRange([(node.typeArguments || node.name).range[1], decl.range[0]], "\n");
          }
        });
        return true;
      });
      else if (configuration === "never" && node.attributes.length > 0 || configuration === "multiprop" && !isSingleLine(node) && node.attributes.length <= 1) {
        const firstNode = node.attributes[0];
        if (node.loc.start.line < firstNode.loc.start.line) context.report({
          node: firstNode,
          messageId: "propOnSameLine",
          fix(fixer) {
            return fixer.replaceTextRange([node.name.range[1], firstNode.range[0]], " ");
          }
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-function-call-newline.js
function endWithComma(context, node) {
  const nextToken = context.sourceCode.getTokenAfter(node);
  return !!nextToken && nextToken.value === "," && nextToken.range[0] >= node.range[1];
}
var jsx_function_call_newline_default = createRule({
  name: "jsx-function-call-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce line breaks before and after JSX elements when they are used as arguments to a function." },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "multiline"]
    }],
    defaultOptions: ["multiline"],
    messages: { missingLineBreak: "Missing line break around JSX" }
  },
  create(context, [option]) {
    function needsOpeningNewLine(node) {
      if ((0, ast_exports.isTokenOnSameLine)(context.sourceCode.getTokenBefore(node), node)) return true;
      return false;
    }
    function needsClosingNewLine(node) {
      const nextToken = context.sourceCode.getTokenAfter(node);
      if (endWithComma(context, node)) return false;
      if (node.loc.end.line === nextToken.loc.end.line) return true;
      return false;
    }
    function check(node) {
      if (!node || !isJSX(node)) return;
      const sourceCode = context.sourceCode;
      if (option === "always" || !isSingleLine(node)) {
        const needsOpening = needsOpeningNewLine(node);
        const needsClosing = needsClosingNewLine(node);
        if (needsOpening || needsClosing) context.report({
          node,
          messageId: "missingLineBreak",
          fix: (fixer) => {
            let fixed = sourceCode.getText(node);
            if (needsOpening) fixed = `
${fixed}`;
            if (needsClosing) fixed = `${fixed}
`;
            return fixer.replaceText(node, fixed);
          }
        });
      }
    }
    function handleCallExpression(node) {
      if (node.arguments.length === 0) return;
      node.arguments.forEach(check);
    }
    return {
      CallExpression(node) {
        handleCallExpression(node);
      },
      NewExpression(node) {
        handleCallExpression(node);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-indent-props.js
var jsx_indent_props_default = createRule({
  name: "jsx-indent-props",
  meta: {
    type: "layout",
    docs: { description: "Enforce props indentation in JSX" },
    fixable: "code",
    schema: [{ anyOf: [
      {
        type: "string",
        enum: ["tab", "first"]
      },
      { type: "integer" },
      {
        type: "object",
        properties: {
          indentMode: { anyOf: [{
            type: "string",
            enum: ["tab", "first"]
          }, { type: "integer" }] },
          ignoreTernaryOperator: { type: "boolean" }
        },
        additionalProperties: false
      }
    ] }],
    defaultOptions: [4],
    messages: { wrongIndent: "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}." }
  },
  create(context, [options]) {
    const extraColumnStart = 0;
    const line = {
      isUsingOperator: false,
      currentOperator: false
    };
    const { indentMode = 4, ignoreTernaryOperator = false } = typeof options === "object" ? options : { indentMode: options };
    const indentType = indentMode === "tab" ? "tab" : "space";
    const indentSize = indentMode === "first" ? "first" : indentMode === "tab" ? 1 : indentMode;
    function getNodeIndent(node) {
      let src = context.sourceCode.getText(node, node.loc.start.column + extraColumnStart);
      src = src.split("\n")[0];
      let regExp;
      if (indentType === "space") regExp = /^ +/;
      else regExp = /^\t+/;
      const indent = regExp.exec(src);
      const useOperator = /^[ \t]*:/.test(src) || /^[ \t]*\?/.test(src);
      const useBracket = /</.test(src);
      line.currentOperator = false;
      if (useOperator) {
        line.isUsingOperator = true;
        line.currentOperator = true;
      } else if (useBracket) line.isUsingOperator = false;
      return indent ? indent[0].length : 0;
    }
    function checkNodesIndent(nodes, indent) {
      let nestedIndent = indent;
      nodes.forEach((node) => {
        const nodeIndent = getNodeIndent(node);
        if (line.isUsingOperator && !line.currentOperator && indentSize !== "first" && !ignoreTernaryOperator) {
          nestedIndent += indentSize;
          line.isUsingOperator = false;
        }
        if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && nodeIndent !== nestedIndent && isNodeFirstInLine(context, node)) context.report({
          node,
          messageId: "wrongIndent",
          data: {
            needed: nestedIndent,
            type: indentType,
            characters: nestedIndent === 1 ? "character" : "characters",
            gotten: nodeIndent
          },
          fix(fixer) {
            return fixer.replaceTextRange([node.range[0] - node.loc.start.column, node.range[0]], new Array(nestedIndent + 1).join(indentType === "space" ? " " : "	"));
          }
        });
      });
    }
    return { JSXOpeningElement(node) {
      if (!node.attributes.length) return;
      let propIndent;
      if (indentSize === "first") propIndent = node.attributes[0].loc.start.column;
      else propIndent = getNodeIndent(node) + indentSize;
      checkNodesIndent(node.attributes, propIndent);
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-indent.js
var jsx_indent_default = createRule({
  name: "jsx-indent",
  meta: {
    type: "layout",
    docs: { description: "Enforce JSX indentation. Deprecated, use `indent` rule instead." },
    fixable: "whitespace",
    deprecated: {
      message: "The rule was replaced with a more general rule.",
      deprecatedSince: "5.0.0",
      replacedBy: [{ rule: {
        name: "indent",
        url: "https://eslint.style/rules/indent"
      } }]
    },
    schema: [{ anyOf: [{
      type: "string",
      enum: ["tab"]
    }, { type: "integer" }] }, {
      type: "object",
      properties: {
        checkAttributes: { type: "boolean" },
        indentLogicalExpressions: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [4],
    messages: { wrongIndent: "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}." }
  },
  create(context) {
    const extraColumnStart = 0;
    let indentType = "space";
    let indentSize = 4;
    if (context.options.length) {
      if (context.options[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else if (typeof context.options[0] === "number") {
        indentSize = context.options[0];
        indentType = "space";
      }
    }
    const indentChar = indentType === "space" ? " " : "	";
    const options = context.options[1] || {};
    const checkAttributes = options.checkAttributes || false;
    const indentLogicalExpressions = options.indentLogicalExpressions || false;
    function getFixerFunction(node, needed) {
      const indent = new Array(needed + 1).join(indentChar);
      if (node.type === "JSXText" || node.type === "Literal") return function fix(fixer) {
        const fixedText = node.raw.replace(/\n[\t ]*(\S)/g, (match, p1) => `
${indent}${p1}`);
        return fixer.replaceText(node, fixedText);
      };
      if (node.type === "ReturnStatement") {
        const raw = context.sourceCode.getText(node);
        if (raw.split("\n").length > 1) return function fix(fixer) {
          const lastLineStart = raw.lastIndexOf("\n");
          const lastLine = raw.slice(lastLineStart).replace(/^\n[\t ]*(\S)/, (match, p1) => `
${indent}${p1}`);
          return fixer.replaceTextRange([node.range[0] + lastLineStart, node.range[1]], lastLine);
        };
      }
      return function fix(fixer) {
        return fixer.replaceTextRange([node.range[0] - node.loc.start.column, node.range[0]], indent);
      };
    }
    function report(node, needed, gotten, loc) {
      const msgContext = {
        needed,
        type: indentType,
        characters: needed === 1 ? "character" : "characters",
        gotten
      };
      context.report({
        node,
        messageId: "wrongIndent",
        data: msgContext,
        fix: getFixerFunction(node, needed),
        ...loc ? { loc } : {}
      });
    }
    function getNodeIndent(node, byLastLine = false, excludeCommas = false) {
      let src = context.sourceCode.getText(node, node.loc.start.column + extraColumnStart);
      const lines = src.split("\n");
      if (byLastLine) src = lines[lines.length - 1];
      else src = lines[0];
      const skip = excludeCommas ? "," : "";
      let regExp;
      if (indentType === "space") regExp = new RegExp(`^[ ${skip}]+`);
      else regExp = new RegExp(`^[	${skip}]+`);
      const indent = regExp.exec(src);
      return indent ? indent[0].length : 0;
    }
    function isRightInLogicalExp(node) {
      return node.parent && node.parent.parent && node.parent.parent.type === "LogicalExpression" && node.parent.parent.right === node.parent && !indentLogicalExpressions;
    }
    function isAlternateInConditionalExp(node) {
      return node.parent && node.parent.parent && node.parent.parent.type === "ConditionalExpression" && node.parent.parent.alternate === node.parent && context.sourceCode.getTokenBefore(node).value !== "(";
    }
    function isSecondOrSubsequentExpWithinDoExp(node) {
      if (!node.parent || !node.parent.parent || node.parent.parent.type !== "ExpressionStatement") return false;
      const expStmt = node.parent.parent;
      if (!(expStmt.parent && expStmt.parent.type === "BlockStatement" && expStmt.parent.parent && expStmt.parent.parent.type === "DoExpression")) return false;
      return !(expStmt.parent.body[0] === expStmt);
    }
    function checkNodesIndent(node, indent, excludeCommas = false) {
      const nodeIndent = getNodeIndent(node, false, excludeCommas);
      const isCorrectRightInLogicalExp = isRightInLogicalExp(node) && nodeIndent - indent === indentSize;
      const isCorrectAlternateInCondExp = isAlternateInConditionalExp(node) && nodeIndent - indent === 0;
      if (nodeIndent !== indent && isNodeFirstInLine(context, node) && !isCorrectRightInLogicalExp && !isCorrectAlternateInCondExp) report(node, indent, nodeIndent);
    }
    function checkLiteralNodeIndent(node, indent) {
      const value = node.value;
      const regExp = indentType === "space" ? /\n( *)[\t ]*\S/g : /\n(\t*)[\t ]*\S/g;
      const nodeIndentsPerLine = Array.from(String(value).matchAll(regExp), (match) => match[1] ? match[1].length : 0);
      if (nodeIndentsPerLine.length > 0 && !nodeIndentsPerLine.every((actualIndent) => actualIndent === indent)) nodeIndentsPerLine.forEach((nodeIndent) => {
        report(node, indent, nodeIndent);
      });
    }
    function handleOpeningElement(node) {
      const sourceCode = context.sourceCode;
      let prevToken = sourceCode.getTokenBefore(node);
      if (!prevToken) return;
      if (prevToken.type === "JSXText" || (0, ast_exports.isCommaToken)(prevToken)) {
        prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
        prevToken = prevToken.type === "Literal" || prevToken.type === "JSXText" ? prevToken.parent : prevToken;
      } else if ((0, ast_exports.isColonToken)(prevToken)) {
        do
          prevToken = sourceCode.getTokenBefore(prevToken);
        while (prevToken.type === "Punctuator" && prevToken.value !== "/");
        prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
        while (prevToken.parent && prevToken.parent.type !== "ConditionalExpression") prevToken = prevToken.parent;
      }
      prevToken = prevToken.type === "JSXExpressionContainer" ? prevToken.expression : prevToken;
      checkNodesIndent(node, getNodeIndent(prevToken) + (prevToken.loc.start.line === node.loc.start.line || isRightInLogicalExp(node) || isAlternateInConditionalExp(node) || isSecondOrSubsequentExpWithinDoExp(node) ? 0 : indentSize));
    }
    function handleClosingElement(node) {
      if (!node.parent) return;
      checkNodesIndent(node, getNodeIndent(node.parent.openingElement || node.parent.openingFragment));
    }
    function handleAttribute(node) {
      if (!checkAttributes || !node.value || node.value.type !== "JSXExpressionContainer") return;
      const nameIndent = getNodeIndent(node.name);
      const lastToken = context.sourceCode.getLastToken(node.value);
      const firstInLine = getFirstNodeInLine(context, lastToken);
      if (firstInLine.loc.start.line !== lastToken.loc.start.line) return;
      checkNodesIndent(firstInLine, node.name.loc.start.line === firstInLine.loc.start.line ? 0 : nameIndent);
    }
    function handleLiteral(node) {
      if (!node.parent) return;
      if (node.parent.type !== "JSXElement" && node.parent.type !== "JSXFragment") return;
      checkLiteralNodeIndent(node, getNodeIndent(node.parent) + indentSize);
    }
    return {
      JSXOpeningElement: handleOpeningElement,
      JSXOpeningFragment: handleOpeningElement,
      JSXClosingElement: handleClosingElement,
      JSXClosingFragment: handleClosingElement,
      JSXAttribute: handleAttribute,
      JSXExpressionContainer(node) {
        if (!node.parent) return;
        checkNodesIndent(node, getNodeIndent(node.parent) + indentSize);
      },
      Literal: handleLiteral,
      JSXText: handleLiteral,
      ReturnStatement(node) {
        if (!node.parent || !node.argument || !isJSX(node.argument)) return;
        let fn = node.parent;
        while (fn && fn.type !== "FunctionDeclaration" && fn.type !== "FunctionExpression") fn = fn.parent;
        if (!fn || !isReturningJSX(node, context, true)) return;
        const openingIndent = getNodeIndent(node);
        const closingIndent = getNodeIndent(node, true);
        if (openingIndent !== closingIndent) report(node, openingIndent, closingIndent);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-max-props-per-line.js
function getPropName2(context, propNode) {
  if (propNode.type === "JSXSpreadAttribute") return context.sourceCode.getText(propNode.argument);
  return propNode.name.name;
}
var jsx_max_props_per_line_default = createRule({
  name: "jsx-max-props-per-line",
  meta: {
    type: "layout",
    docs: { description: "Enforce maximum of props on a single line in JSX" },
    fixable: "code",
    schema: [{ anyOf: [{
      type: "object",
      properties: { maximum: {
        type: "object",
        properties: {
          single: {
            type: "integer",
            minimum: 1
          },
          multi: {
            type: "integer",
            minimum: 1
          }
        },
        additionalProperties: false
      } },
      additionalProperties: false
    }, {
      type: "object",
      properties: {
        maximum: {
          type: "number",
          minimum: 1
        },
        when: {
          type: "string",
          enum: ["always", "multiline"]
        }
      },
      additionalProperties: false
    }] }],
    defaultOptions: [{ maximum: 1 }],
    messages: { newLine: "Prop `{{prop}}` must be placed on a new line" }
  },
  create(context, [configuration]) {
    const { maximum } = configuration;
    const { single = Infinity, multi = Infinity } = typeof maximum === "number" ? {
      single: configuration.when === "multiline" ? Infinity : maximum,
      multi: maximum
    } : maximum;
    function generateFixFunction(line, max) {
      const sourceCode = context.sourceCode;
      const output = [];
      const front = line[0].range[0];
      const back = line[line.length - 1].range[1];
      for (let i = 0; i < line.length; i += max) {
        const nodes = line.slice(i, i + max);
        output.push(nodes.reduce((prev, curr) => {
          if (prev === "") return sourceCode.getText(curr);
          return `${prev} ${sourceCode.getText(curr)}`;
        }, ""));
      }
      const code = output.join("\n");
      return function fix(fixer) {
        return fixer.replaceTextRange([front, back], code);
      };
    }
    return { JSXOpeningElement(node) {
      if (!node.attributes.length) return;
      const isSingleLineTag = isSingleLine(node);
      if ((isSingleLineTag ? single : multi) === Infinity) return;
      const linePartitionedProps = [[node.attributes[0]]];
      node.attributes.reduce((last, decl) => {
        if ((0, ast_exports.isTokenOnSameLine)(last, decl)) linePartitionedProps[linePartitionedProps.length - 1].push(decl);
        else linePartitionedProps.push([decl]);
        return decl;
      });
      linePartitionedProps.forEach((propsInLine) => {
        const maxPropsCountPerLine = isSingleLineTag && propsInLine[0].loc.start.line === node.loc.start.line ? single : multi;
        if (propsInLine.length > maxPropsCountPerLine) {
          const name = getPropName2(context, propsInLine[maxPropsCountPerLine]);
          context.report({
            messageId: "newLine",
            node: propsInLine[maxPropsCountPerLine],
            data: { prop: name },
            fix: generateFixFunction(propsInLine, maxPropsCountPerLine)
          });
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-newline.js
var jsx_newline_default = createRule({
  name: "jsx-newline",
  package: "jsx",
  meta: {
    type: "layout",
    docs: { description: "Require or prevent a new line after jsx elements and expressions." },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        prevent: { type: "boolean" },
        allowMultilines: { type: "boolean" }
      },
      additionalProperties: false,
      if: { properties: { allowMultilines: { const: true } } },
      then: {
        properties: { prevent: { const: true } },
        required: ["prevent"]
      }
    }],
    defaultOptions: [{
      prevent: false,
      allowMultilines: false
    }],
    messages: {
      require: "JSX element should start in a new line",
      prevent: "JSX element should not start in a new line",
      allowMultilines: "Multiline JSX elements should start in a new line"
    }
  },
  create(context, [configuration]) {
    const { prevent, allowMultilines } = configuration;
    const jsxElementParents = /* @__PURE__ */ new Set();
    const sourceCode = context.sourceCode;
    function isBlockCommentInCurlyBraces(element) {
      const elementRawValue = sourceCode.getText(element);
      return /^\s*\{\/\*/.test(elementRawValue);
    }
    function isNonBlockComment(element) {
      return !isBlockCommentInCurlyBraces(element) && (element.type === "JSXElement" || element.type === "JSXExpressionContainer");
    }
    return {
      "Program:exit": function() {
        jsxElementParents.forEach((parent) => {
          parent.children.forEach((element, index2, elements) => {
            if (element.type === "JSXElement" || element.type === "JSXExpressionContainer") {
              const firstAdjacentSibling = elements[index2 + 1];
              const secondAdjacentSibling = elements[index2 + 2];
              if (!(firstAdjacentSibling && secondAdjacentSibling && (firstAdjacentSibling.type === "Literal" || firstAdjacentSibling.type === "JSXText"))) return;
              const isWithoutNewLine = !/\n\s*\n/.test(firstAdjacentSibling.value);
              if (isBlockCommentInCurlyBraces(element)) return;
              const nextNonBlockComment = elements.slice(index2 + 2).find(isNonBlockComment);
              if (allowMultilines && (!isSingleLine(element) || nextNonBlockComment && !isSingleLine(nextNonBlockComment))) {
                if (!isWithoutNewLine) return;
                const regex2 = /(\n)(?!.*\1)/g;
                const replacement2 = "\n\n";
                context.report({
                  messageId: "allowMultilines",
                  node: secondAdjacentSibling,
                  fix(fixer) {
                    return fixer.replaceText(firstAdjacentSibling, sourceCode.getText(firstAdjacentSibling).replace(regex2, replacement2));
                  }
                });
                return;
              }
              if (isWithoutNewLine === prevent) return;
              const messageId = prevent ? "prevent" : "require";
              const regex = prevent ? /(\n\n)(?!.*\1)/g : /(\n)(?!.*\1)/g;
              const replacement = prevent ? "\n" : "\n\n";
              context.report({
                messageId,
                node: secondAdjacentSibling,
                fix(fixer) {
                  return fixer.replaceText(firstAdjacentSibling, sourceCode.getText(firstAdjacentSibling).replace(regex, replacement));
                }
              });
            }
          });
        });
      },
      ":matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)": (node) => {
        jsxElementParents.add(node.parent);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-one-expression-per-line.js
var jsx_one_expression_per_line_default = createRule({
  name: "jsx-one-expression-per-line",
  meta: {
    type: "layout",
    docs: { description: "Require one JSX element per line" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: { allow: {
        type: "string",
        enum: [
          "none",
          "literal",
          "single-child",
          "single-line",
          "non-jsx"
        ]
      } },
      additionalProperties: false
    }],
    defaultOptions: [{ allow: "none" }],
    messages: { moveToNewLine: "`{{descriptor}}` must be placed on a new line" }
  },
  create(context, [options]) {
    const { allow } = options;
    function nodeKey(node) {
      return `${node.loc.start.line},${node.loc.start.column}`;
    }
    function nodeDescriptor(n) {
      return "openingElement" in n && n.openingElement && "name" in n.openingElement.name ? String(n.openingElement.name.name) : context.sourceCode.getText(n).replace(/\n/g, "");
    }
    function report(node, fix) {
      context.report({
        messageId: "moveToNewLine",
        node,
        data: { descriptor: nodeDescriptor(node) },
        fix
      });
    }
    function handleJSX(node) {
      const children = node.children;
      if (!children || !children.length) return;
      if (allow === "non-jsx" && !children.some((child) => child.type === "JSXFragment" || child.type === "JSXElement")) return;
      const isFragment = node.type === "JSXFragment";
      const openingElement = isFragment ? node.openingFragment : node.openingElement;
      const closingElement = isFragment ? node.closingFragment : node.closingElement;
      const openingElementStartLine = openingElement.loc.start.line;
      const openingElementEndLine = openingElement.loc.end.line;
      const closingElementStartLine = closingElement.loc.start.line;
      const closingElementEndLine = closingElement.loc.end.line;
      if (children.length === 1) {
        const child = children[0];
        if (openingElementStartLine === openingElementEndLine && openingElementEndLine === closingElementStartLine && closingElementStartLine === closingElementEndLine && closingElementEndLine === child.loc.start.line && child.loc.start.line === child.loc.end.line) {
          if (allow === "single-child" || allow === "literal" && (child.type === "Literal" || child.type === "JSXText") || allow === "single-line") return;
        }
      }
      if (allow === "single-line") {
        const firstChild = children[0];
        const lastChild = children[children.length - 1];
        const lineDifference = lastChild.loc.end.line - firstChild.loc.start.line;
        let lineBreaks = 0;
        if (firstChild.type === "Literal" || firstChild.type === "JSXText") {
          if (/^\s*?\n/.test(firstChild.raw)) lineBreaks += 1;
        }
        if (lastChild.type === "Literal" || lastChild.type === "JSXText") {
          if (/\n\s*$/.test(lastChild.raw)) lineBreaks += 1;
        }
        if (lineDifference === 0 && lineBreaks === 0 || lineDifference === 2 && lineBreaks === 2) return;
      }
      const childrenGroupedByLine = {};
      const fixDetailsByNode = {};
      children.forEach((child) => {
        let countNewLinesBeforeContent = 0;
        let countNewLinesAfterContent = 0;
        if (child.type === "Literal" || child.type === "JSXText") {
          if (isWhiteSpaces(child.raw)) return;
          countNewLinesBeforeContent = (child.raw.match(/^\s*\n/g) || []).length;
          countNewLinesAfterContent = (child.raw.match(/\n\s*$/g) || []).length;
        }
        const startLine = child.loc.start.line + countNewLinesBeforeContent;
        const endLine = child.loc.end.line - countNewLinesAfterContent;
        if (startLine === endLine) {
          if (!childrenGroupedByLine[startLine]) childrenGroupedByLine[startLine] = [];
          childrenGroupedByLine[startLine].push(child);
        } else {
          if (!childrenGroupedByLine[startLine]) childrenGroupedByLine[startLine] = [];
          childrenGroupedByLine[startLine].push(child);
          if (!childrenGroupedByLine[endLine]) childrenGroupedByLine[endLine] = [];
          childrenGroupedByLine[endLine].push(child);
        }
      });
      const lines = Object.keys(childrenGroupedByLine);
      if (lines.length === 1 && allow === "single-line") {
        const line = parseInt(lines[0]);
        const children2 = childrenGroupedByLine[line];
        const firstChild = children2[0];
        if (line === openingElementEndLine) report(firstChild, (fixer) => fixer.insertTextBefore(firstChild, "\n"));
        const lastChild = children2.at(-1);
        if (line === closingElementStartLine) report(lastChild, (fixer) => fixer.insertTextAfter(lastChild, "\n"));
      } else {
        lines.forEach((_line) => {
          const line = parseInt(_line, 10);
          const firstIndex = 0;
          const lastIndex = childrenGroupedByLine[line].length - 1;
          childrenGroupedByLine[line].forEach((child, i) => {
            let prevChild;
            let nextChild;
            if (i === firstIndex) {
              if (line === openingElementEndLine) prevChild = openingElement;
            } else prevChild = childrenGroupedByLine[line][i - 1];
            if (i === lastIndex) {
              if (line === closingElementStartLine) nextChild = closingElement;
            }
            if (!prevChild && !nextChild) return;
            const spaceBetweenPrev = () => {
              const tokenBetweenNodes = context.sourceCode.getTokensBetween(prevChild, child)[0];
              return (prevChild.type === "Literal" || prevChild.type === "JSXText") && prevChild.raw.endsWith(" ") || (child.type === "Literal" || child.type === "JSXText") && child.raw.startsWith(" ") || isWhiteSpaces(tokenBetweenNodes?.value);
            };
            const spaceBetweenNext = () => {
              const tokenBetweenNodes = context.sourceCode.getTokensBetween(child, nextChild)[0];
              return (nextChild.type === "Literal" || nextChild.type === "JSXText") && nextChild.raw.startsWith(" ") || (child.type === "Literal" || child.type === "JSXText") && child.raw.endsWith(" ") || isWhiteSpaces(tokenBetweenNodes?.value);
            };
            const source = context.sourceCode.getText(child);
            const leadingSpace = !!(prevChild && spaceBetweenPrev());
            const trailingSpace = !!(nextChild && spaceBetweenNext());
            const leadingNewLine = !!prevChild;
            const trailingNewLine = !!nextChild;
            const key = nodeKey(child);
            if (!fixDetailsByNode[key]) fixDetailsByNode[key] = {
              node: child,
              source
            };
            if (leadingSpace) fixDetailsByNode[key].leadingSpace = true;
            if (leadingNewLine) fixDetailsByNode[key].leadingNewLine = true;
            if (trailingNewLine) fixDetailsByNode[key].trailingNewLine = true;
            if (trailingSpace) fixDetailsByNode[key].trailingSpace = true;
          });
        });
        Object.keys(fixDetailsByNode).forEach((key) => {
          const details = fixDetailsByNode[key];
          const nodeToReport = details.node;
          const source = details.source.replace(/(^ +| +$)/g, "");
          const leadingSpaceString = details.leadingSpace ? "\n{' '}" : "";
          const trailingSpaceString = details.trailingSpace ? "{' '}\n" : "";
          const replaceText = `${leadingSpaceString}${details.leadingNewLine ? "\n" : ""}${source}${details.trailingNewLine ? "\n" : ""}${trailingSpaceString}`;
          report(nodeToReport, (fixer) => fixer.replaceText(nodeToReport, replaceText));
        });
      }
    }
    return {
      JSXElement: handleJSX,
      JSXFragment: handleJSX
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-pascal-case.js
var import_picomatch = __toESM(require_picomatch2(), 1);
function testDigit(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 48 && charCode <= 57;
}
function testUpperCase(char) {
  const upperCase = char.toUpperCase();
  return char === upperCase && upperCase !== char.toLowerCase();
}
function testLowerCase(char) {
  const lowerCase = char.toLowerCase();
  return char === lowerCase && lowerCase !== char.toUpperCase();
}
function testPascalCase(name) {
  if (!testUpperCase(name.charAt(0))) return false;
  if (Array.prototype.some.call(name.slice(1), (char) => char.toLowerCase() === char.toUpperCase() && !testDigit(char))) return false;
  return Array.prototype.some.call(name.slice(1), (char) => testLowerCase(char) || testDigit(char));
}
function testAllCaps(name) {
  const firstChar = name.charAt(0);
  if (!(testUpperCase(firstChar) || testDigit(firstChar))) return false;
  for (let i = 1; i < name.length - 1; i += 1) {
    const char = name.charAt(i);
    if (!(testUpperCase(char) || testDigit(char) || char === "_")) return false;
  }
  const lastChar = name.charAt(name.length - 1);
  if (!(testUpperCase(lastChar) || testDigit(lastChar))) return false;
  return true;
}
var jsx_pascal_case_default = createRule({
  name: "jsx-pascal-case",
  meta: {
    type: "suggestion",
    docs: { description: "Enforce PascalCase for user-defined JSX components" },
    schema: [{
      type: "object",
      properties: {
        allowAllCaps: { type: "boolean" },
        allowLeadingUnderscore: { type: "boolean" },
        allowNamespace: { type: "boolean" },
        ignore: {
          items: { type: "string" },
          type: "array",
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      allowAllCaps: false,
      allowLeadingUnderscore: false,
      allowNamespace: false
    }],
    messages: {
      usePascalCase: "Imported JSX component {{name}} must be in PascalCase",
      usePascalOrSnakeCase: "Imported JSX component {{name}} must be in PascalCase or SCREAMING_SNAKE_CASE"
    }
  },
  create(context, [configuration]) {
    const { allowAllCaps, allowLeadingUnderscore, allowNamespace, ignore = [] } = configuration;
    const isMatchIgnore = (0, import_picomatch.default)(ignore, { noglobstar: true });
    function ignoreCheck(name) {
      return isMatchIgnore(name) || ignore.includes(name);
    }
    return { JSXOpeningElement(node) {
      if (isDOMComponent(node)) return;
      const name = getElementType(node);
      let checkNames = [name];
      let index2 = 0;
      if (name.includes(":")) checkNames = name.split(":");
      else if (name.includes(".")) checkNames = name.split(".");
      do {
        const splitName = checkNames[index2];
        if (splitName.length === 1) return;
        const isIgnored = ignoreCheck(splitName);
        const checkName = allowLeadingUnderscore && splitName.startsWith("_") ? splitName.slice(1) : splitName;
        const isPascalCase = testPascalCase(checkName);
        const isAllowedAllCaps = allowAllCaps && testAllCaps(checkName);
        if (!isPascalCase && !isAllowedAllCaps && !isIgnored) {
          const messageId = allowAllCaps ? "usePascalOrSnakeCase" : "usePascalCase";
          context.report({
            messageId,
            node,
            data: { name: splitName }
          });
          break;
        }
        index2 += 1;
      } while (index2 < checkNames.length && !allowNamespace);
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-props-no-multi-spaces.js
var jsx_props_no_multi_spaces_default = createRule({
  name: "jsx-props-no-multi-spaces",
  meta: {
    type: "layout",
    docs: { description: "Disallow multiple spaces between inline JSX props. Deprecated, use `no-multi-spaces` rule instead." },
    fixable: "code",
    deprecated: {
      message: "The rule was replaced with a more general rule.",
      deprecatedSince: "5.0.0",
      replacedBy: [{ rule: {
        name: "no-multi-spaces",
        url: "https://eslint.style/rules/no-multi-spaces"
      } }]
    },
    schema: [],
    messages: {
      noLineGap: "Expected no line gap between \u201C{{prop1}}\u201D and \u201C{{prop2}}\u201D",
      onlyOneSpace: "Expected only one space between \u201C{{prop1}}\u201D and \u201C{{prop2}}\u201D"
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function getPropName3(propNode) {
      switch (propNode.type) {
        case "JSXSpreadAttribute":
          return sourceCode.getText(propNode.argument);
        case "JSXIdentifier":
          return propNode.name;
        case "JSXMemberExpression":
          return `${getPropName3(propNode.object)}.${propNode.property.name}`;
        default:
          return propNode.name ? propNode.name.name : `${sourceCode.getText(propNode.object)}.${propNode.property.name}`;
      }
    }
    function hasEmptyLines(first, second) {
      const comments = sourceCode.getCommentsBefore ? sourceCode.getCommentsBefore(second) : [];
      const nodes = [].concat(first, comments, second);
      for (let i = 1; i < nodes.length; i += 1) {
        const prev = nodes[i - 1];
        if (nodes[i].loc.start.line - prev.loc.end.line >= 2) return true;
      }
      return false;
    }
    function checkSpacing(prev, node) {
      if (hasEmptyLines(prev, node)) context.report({
        messageId: "noLineGap",
        node,
        data: {
          prop1: getPropName3(prev),
          prop2: getPropName3(node)
        }
      });
      if (prev.loc.end.line !== node.loc.end.line) return;
      if (sourceCode.text.slice(prev.range[1], node.range[0]) !== " ") context.report({
        node,
        messageId: "onlyOneSpace",
        data: {
          prop1: getPropName3(prev),
          prop2: getPropName3(node)
        },
        fix(fixer) {
          return fixer.replaceTextRange([prev.range[1], node.range[0]], " ");
        }
      });
    }
    function containsGenericType(node) {
      return typeof node.typeArguments !== "undefined" && node.typeArguments?.type === "TSTypeParameterInstantiation";
    }
    function getGenericNode(node) {
      const name = node.name;
      if (containsGenericType(node)) {
        const type = node.typeArguments;
        return Object.assign({}, node, { range: [name.range[0], type?.range[1]] });
      }
      return name;
    }
    return { JSXOpeningElement(node) {
      node.attributes.reduce((prev, prop) => {
        checkSpacing(prev, prop);
        return prop;
      }, getGenericNode(node));
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-quotes.js
var QUOTE_SETTINGS = {
  "prefer-double": {
    quote: '"',
    description: "singlequote",
    convert(str) {
      return str.replace(/'/gu, '"');
    }
  },
  "prefer-single": {
    quote: "'",
    description: "doublequote",
    convert(str) {
      return str.replace(/"/gu, "'");
    }
  }
};
var jsx_quotes_default = createRule({
  name: "jsx-quotes",
  meta: {
    type: "layout",
    docs: { description: "Enforce the consistent use of either double or single quotes in JSX attributes" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["prefer-single", "prefer-double"]
    }],
    defaultOptions: ["prefer-double"],
    messages: { unexpected: "Unexpected usage of {{description}}." }
  },
  create(context, [quoteOption]) {
    const setting = QUOTE_SETTINGS[quoteOption];
    function usesExpectedQuotes(node) {
      return node.value.includes(setting.quote) || isSurroundedBy(node.raw, setting.quote);
    }
    return { JSXAttribute(node) {
      const attributeValue = node.value;
      if (attributeValue && isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) context.report({
        node: attributeValue,
        messageId: "unexpected",
        data: { description: setting.description },
        fix(fixer) {
          return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-self-closing-comp.js
var jsx_self_closing_comp_default = createRule({
  name: "jsx-self-closing-comp",
  meta: {
    type: "layout",
    docs: { description: "Disallow extra closing tags for components without children" },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        component: { type: "boolean" },
        html: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      component: true,
      html: true
    }],
    messages: { notSelfClosing: "Empty components are self-closing" }
  },
  create(context, [configuration]) {
    const { component, html } = configuration;
    function isComponent(node) {
      return node.name && (node.name.type === "JSXIdentifier" || node.name.type === "JSXMemberExpression") && !isDOMComponent(node);
    }
    function childrenIsEmpty(node) {
      return node.parent.children.length === 0;
    }
    function childrenIsMultilineSpaces(node) {
      const childrens = node.parent.children;
      return childrens.length === 1 && childrens[0].type === "JSXText" && childrens[0].value.includes("\n") && childrens[0].value.replace(/(?!\xA0)\s/g, "") === "";
    }
    function isShouldBeSelfClosed(node) {
      return (!!component && isComponent(node) || !!html && isDOMComponent(node)) && !node.selfClosing && (childrenIsEmpty(node) || childrenIsMultilineSpaces(node));
    }
    return { JSXOpeningElement(node) {
      if (!isShouldBeSelfClosed(node)) return;
      context.report({
        messageId: "notSelfClosing",
        node,
        fix(fixer) {
          const range = [node.range[1] - 1, node.parent.closingElement?.range[1] ?? NaN];
          return fixer.replaceTextRange(range, " />");
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-sort-props.js
function isCallbackPropName(name) {
  return /^on[A-Z]/.test(name);
}
var RESERVED_PROPS_LIST = [
  "children",
  "dangerouslySetInnerHTML",
  "key",
  "ref"
];
function getReservedPropIndex(name, list) {
  return list.indexOf(name.split(":")[0]);
}
var attributeMap;
function shouldSortToEnd(node) {
  const attr = attributeMap.get(node);
  return !!attr && !!attr.hasComment;
}
function contextCompare(a, b, options) {
  let aProp = getPropName(a);
  let bProp = getPropName(b);
  const aPropNamespace = aProp.split(":")[0];
  const bPropNamespace = bProp.split(":")[0];
  const aSortToEnd = shouldSortToEnd(a);
  const bSortToEnd = shouldSortToEnd(b);
  if (aSortToEnd && !bSortToEnd) return 1;
  if (!aSortToEnd && bSortToEnd) return -1;
  if (options.reservedFirst) {
    const aIndex = getReservedPropIndex(aProp, options.reservedList);
    const bIndex = getReservedPropIndex(bProp, options.reservedList);
    if (aIndex > -1 && bIndex === -1) return -1;
    if (aIndex === -1 && bIndex > -1) return 1;
    if (aIndex > -1 && bIndex > -1 && aPropNamespace !== bPropNamespace) return aIndex > bIndex ? 1 : -1;
  }
  if (options.reservedLast.length > 0) {
    const aLastIndex = getReservedPropIndex(aProp, options.reservedLast);
    const bLastIndex = getReservedPropIndex(bProp, options.reservedLast);
    if (aLastIndex > -1 && bLastIndex === -1) return 1;
    if (aLastIndex === -1 && bLastIndex > -1) return -1;
    if (aLastIndex > -1 && bLastIndex > -1 && aPropNamespace !== bPropNamespace) return aLastIndex > bLastIndex ? -1 : 1;
  }
  if (options.callbacksLast) {
    const aIsCallback = isCallbackPropName(aProp);
    const bIsCallback = isCallbackPropName(bProp);
    if (aIsCallback && !bIsCallback) return 1;
    if (!aIsCallback && bIsCallback) return -1;
  }
  if (options.shorthandFirst || options.shorthandLast) {
    const shorthandSign = options.shorthandFirst ? -1 : 1;
    if (!a.value && b.value) return shorthandSign;
    if (a.value && !b.value) return -shorthandSign;
  }
  if (options.multiline !== "ignore") {
    const multilineSign = options.multiline === "first" ? -1 : 1;
    const aIsMultiline = !isSingleLine(a);
    const bIsMultiline = !isSingleLine(b);
    if (aIsMultiline && !bIsMultiline) return multilineSign;
    if (!aIsMultiline && bIsMultiline) return -multilineSign;
  }
  if (options.noSortAlphabetically) return 0;
  const actualLocale = options.locale === "auto" ? void 0 : options.locale;
  if (options.ignoreCase) {
    aProp = aProp.toLowerCase();
    bProp = bProp.toLowerCase();
    return aProp.localeCompare(bProp, actualLocale);
  }
  if (aProp === bProp) return 0;
  if (options.locale === "auto") return aProp < bProp ? -1 : 1;
  return aProp.localeCompare(bProp, actualLocale);
}
function getGroupsOfSortableAttributes(attributes, context) {
  const sourceCode = context.sourceCode;
  const sortableAttributeGroups = [];
  let groupCount = 0;
  function addtoSortableAttributeGroups(attribute) {
    sortableAttributeGroups[groupCount - 1].push(attribute);
  }
  for (let i = 0; i < attributes.length; i++) {
    const attribute = attributes[i];
    const nextAttribute = attributes[i + 1];
    const attributeline = attribute.loc.start.line;
    let comment = [];
    try {
      comment = sourceCode.getCommentsAfter(attribute);
    } catch {
    }
    const lastAttr = attributes[i - 1];
    const attrIsSpread = attribute.type === "JSXSpreadAttribute";
    if (!lastAttr || lastAttr.type === "JSXSpreadAttribute" && !attrIsSpread) {
      groupCount += 1;
      sortableAttributeGroups[groupCount - 1] = [];
    }
    if (!attrIsSpread) if (comment.length === 0) {
      attributeMap.set(attribute, {
        end: attribute.range[1],
        hasComment: false
      });
      addtoSortableAttributeGroups(attribute);
    } else {
      const firstComment = comment[0];
      const commentline = firstComment.loc.start.line;
      if (comment.length === 1) {
        if (attributeline + 1 === commentline && nextAttribute) {
          attributeMap.set(attribute, {
            end: nextAttribute.range[1],
            hasComment: true
          });
          addtoSortableAttributeGroups(attribute);
          i += 1;
        } else if (attributeline === commentline) {
          if (firstComment.type === "Block" && nextAttribute) {
            attributeMap.set(attribute, {
              end: nextAttribute.range[1],
              hasComment: true
            });
            i += 1;
          } else if (firstComment.type === "Block") attributeMap.set(attribute, {
            end: firstComment.range[1],
            hasComment: true
          });
          else attributeMap.set(attribute, {
            end: firstComment.range[1],
            hasComment: false
          });
          addtoSortableAttributeGroups(attribute);
        }
      } else if (comment.length > 1 && attributeline + 1 === comment[1].loc.start.line && nextAttribute) {
        const commentNextAttribute = sourceCode.getCommentsAfter(nextAttribute);
        attributeMap.set(attribute, {
          end: nextAttribute.range[1],
          hasComment: true
        });
        if (commentNextAttribute.length === 1 && nextAttribute.loc.start.line === commentNextAttribute[0].loc.start.line) attributeMap.set(attribute, {
          end: commentNextAttribute[0].range[1],
          hasComment: true
        });
        addtoSortableAttributeGroups(attribute);
        i += 1;
      }
    }
  }
  return sortableAttributeGroups;
}
function generateFixerFunction(node, context, reservedList) {
  const sourceCode = context.sourceCode;
  const attributes = node.attributes.slice(0);
  const configuration = context.options[0] || {};
  const options = {
    ignoreCase: configuration.ignoreCase || false,
    callbacksLast: configuration.callbacksLast || false,
    shorthandFirst: configuration.shorthandFirst || false,
    shorthandLast: configuration.shorthandLast || false,
    multiline: configuration.multiline || "ignore",
    noSortAlphabetically: configuration.noSortAlphabetically || false,
    reservedFirst: configuration.reservedFirst || false,
    reservedList,
    reservedLast: configuration.reservedLast || [],
    locale: configuration.locale || "auto"
  };
  const sortableAttributeGroups = getGroupsOfSortableAttributes(attributes, context);
  const sortedAttributeGroups = sortableAttributeGroups.slice(0).map((group) => [...group].sort((a, b) => contextCompare(a, b, options)));
  return function fixFunction(fixer) {
    const fixers = [];
    let source = sourceCode.getText();
    sortableAttributeGroups.forEach((sortableGroup, ii) => {
      sortableGroup.forEach((attr, jj) => {
        const sortedAttr = sortedAttributeGroups[ii][jj];
        const sortedAttrText = source.slice(sortedAttr.range[0], attributeMap.get(sortedAttr).end);
        fixers.push({
          range: [attr.range[0], attributeMap.get(attr).end],
          text: sortedAttrText
        });
      });
    });
    fixers.sort((a, b) => b.range[0] - a.range[0]);
    const firstFixer = fixers[0];
    const lastFixer = fixers[fixers.length - 1];
    const rangeStart = lastFixer ? lastFixer.range[0] : 0;
    const rangeEnd = firstFixer ? firstFixer.range[1] : -0;
    fixers.forEach((fix) => {
      source = `${source.slice(0, fix.range[0])}${fix.text}${source.slice(fix.range[1])}`;
    });
    return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
  };
}
function validateReservedFirstConfig(context, reservedFirst) {
  if (reservedFirst) {
    if (Array.isArray(reservedFirst)) {
      if (reservedFirst.length === 0) return function Report(decl) {
        context.report({
          node: decl,
          messageId: "listIsEmpty"
        });
      };
    }
  }
}
var reportedNodeAttributes = /* @__PURE__ */ new WeakMap();
function reportNodeAttribute(nodeAttribute, errorType, node, context, reservedList) {
  const errors = reportedNodeAttributes.get(nodeAttribute) || [];
  if (errors.includes(errorType)) return;
  errors.push(errorType);
  reportedNodeAttributes.set(nodeAttribute, errors);
  context.report({
    node: nodeAttribute.name ?? "",
    messageId: errorType,
    fix: generateFixerFunction(node, context, reservedList)
  });
}
var jsx_sort_props_default = createRule({
  name: "jsx-sort-props",
  meta: {
    type: "layout",
    docs: { description: "Enforce props alphabetical sorting" },
    fixable: "code",
    deprecated: {
      message: "We recommend using the `eslint-plugin-perfectionist` plugin instead.",
      deprecatedSince: "5.7.0",
      replacedBy: [{
        plugin: {
          name: "eslint-plugin-perfectionist",
          url: "https://perfectionist.dev"
        },
        rule: {
          name: "sort-jsx-props",
          url: "https://perfectionist.dev/rules/sort-jsx-props"
        }
      }]
    },
    schema: [{
      type: "object",
      properties: {
        callbacksLast: { type: "boolean" },
        shorthandFirst: { type: "boolean" },
        shorthandLast: { type: "boolean" },
        multiline: {
          type: "string",
          enum: [
            "ignore",
            "first",
            "last"
          ]
        },
        ignoreCase: { type: "boolean" },
        noSortAlphabetically: { type: "boolean" },
        reservedFirst: { oneOf: [{
          type: "array",
          items: { type: "string" }
        }, { type: "boolean" }] },
        reservedLast: {
          type: "array",
          items: { type: "string" }
        },
        locale: { type: "string" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      ignoreCase: false,
      callbacksLast: false,
      shorthandFirst: false,
      shorthandLast: false,
      multiline: "ignore",
      noSortAlphabetically: false,
      reservedFirst: false,
      reservedLast: [],
      locale: "auto"
    }],
    messages: {
      listIsEmpty: "A customized reserved first list must not be empty",
      listReservedPropsFirst: "Reserved props must be listed before all other props",
      listReservedPropsLast: "Reserved props must be listed after all other props",
      listCallbacksLast: "Callbacks must be listed after all other props",
      listShorthandFirst: "Shorthand props must be listed before all other props",
      listShorthandLast: "Shorthand props must be listed after all other props",
      listMultilineFirst: "Multiline props must be listed before all other props",
      listMultilineLast: "Multiline props must be listed after all other props",
      sortPropsByAlpha: "Props should be sorted alphabetically"
    }
  },
  create(context, [options]) {
    const { ignoreCase, callbacksLast, shorthandFirst, shorthandLast, multiline, noSortAlphabetically, reservedFirst, reservedLast, locale } = options;
    const reservedFirstError = validateReservedFirstConfig(context, reservedFirst);
    const reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;
    return {
      Program() {
        attributeMap = /* @__PURE__ */ new WeakMap();
      },
      JSXOpeningElement(node) {
        const nodeReservedList = reservedFirst && !isDOMComponent(node) ? reservedList.filter((prop) => prop !== "dangerouslySetInnerHTML") : reservedList;
        node.attributes.reduce((memo, decl, idx, attrs) => {
          if (decl.type === "JSXSpreadAttribute") return attrs[idx + 1];
          let previousPropName = getPropName(memo);
          let currentPropName = getPropName(decl);
          const previousReservedNamespace = previousPropName.split(":")[0];
          const currentReservedNamespace = currentPropName.split(":")[0];
          const previousValue = memo.value;
          const currentValue = decl.value;
          const previousIsCallback = isCallbackPropName(previousPropName);
          const currentIsCallback = isCallbackPropName(currentPropName);
          if (ignoreCase) {
            previousPropName = previousPropName.toLowerCase();
            currentPropName = currentPropName.toLowerCase();
          }
          if (reservedFirst) {
            if (reservedFirstError) {
              reservedFirstError(decl);
              return memo;
            }
            const previousReservedIndex = getReservedPropIndex(previousPropName, nodeReservedList);
            const currentReservedIndex = getReservedPropIndex(currentPropName, nodeReservedList);
            if (previousReservedIndex > -1 && currentReservedIndex === -1) return decl;
            if (reservedFirst !== true && previousReservedIndex > currentReservedIndex || previousReservedIndex === -1 && currentReservedIndex > -1) {
              reportNodeAttribute(decl, "listReservedPropsFirst", node, context, nodeReservedList);
              return memo;
            }
            if (previousReservedIndex > -1 && currentReservedIndex > -1 && currentReservedIndex > previousReservedIndex && previousReservedNamespace !== currentReservedNamespace) return decl;
          }
          if (reservedLast.length > 0) {
            const previousReservedIndex = getReservedPropIndex(previousPropName, reservedLast);
            const currentReservedIndex = getReservedPropIndex(currentPropName, reservedLast);
            if (previousReservedIndex === -1 && currentReservedIndex > -1) return decl;
            if (previousReservedIndex < currentReservedIndex || previousReservedIndex > -1 && currentReservedIndex === -1) {
              reportNodeAttribute(decl, "listReservedPropsLast", node, context, nodeReservedList);
              return memo;
            }
            if (previousReservedIndex > -1 && currentReservedIndex > -1 && currentReservedIndex > previousReservedIndex && previousReservedNamespace !== currentReservedNamespace) return decl;
          }
          if (callbacksLast) {
            if (!previousIsCallback && currentIsCallback) return decl;
            if (previousIsCallback && !currentIsCallback) {
              reportNodeAttribute(memo, "listCallbacksLast", node, context, nodeReservedList);
              return memo;
            }
          }
          if (shorthandFirst) {
            if (currentValue && !previousValue) return decl;
            if (!currentValue && previousValue) {
              reportNodeAttribute(decl, "listShorthandFirst", node, context, nodeReservedList);
              return memo;
            }
          }
          if (shorthandLast) {
            if (!currentValue && previousValue) return decl;
            if (currentValue && !previousValue) {
              reportNodeAttribute(memo, "listShorthandLast", node, context, nodeReservedList);
              return memo;
            }
          }
          const previousIsMultiline = !isSingleLine(memo);
          const currentIsMultiline = !isSingleLine(decl);
          if (multiline === "first") {
            if (previousIsMultiline && !currentIsMultiline) return decl;
            if (!previousIsMultiline && currentIsMultiline) {
              reportNodeAttribute(decl, "listMultilineFirst", node, context, nodeReservedList);
              return memo;
            }
          } else if (multiline === "last") {
            if (!previousIsMultiline && currentIsMultiline) return decl;
            if (previousIsMultiline && !currentIsMultiline) {
              reportNodeAttribute(memo, "listMultilineLast", node, context, nodeReservedList);
              return memo;
            }
          }
          if (!noSortAlphabetically && (ignoreCase || locale !== "auto" ? previousPropName.localeCompare(currentPropName, locale === "auto" ? void 0 : locale) > 0 : previousPropName > currentPropName)) {
            reportNodeAttribute(decl, "sortPropsByAlpha", node, context, nodeReservedList);
            return memo;
          }
          return decl;
        }, node.attributes[0]);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-tag-spacing.js
function validateClosingSlash(context, node, option) {
  const sourceCode = context.sourceCode;
  let adjacent;
  if ("selfClosing" in node && node.selfClosing) {
    const lastTokens = sourceCode.getLastTokens(node, 2);
    adjacent = !sourceCode.isSpaceBetween(lastTokens[0], lastTokens[1]);
    if (option === "never") {
      if (!adjacent) context.report({
        node,
        messageId: "selfCloseSlashNoSpace",
        loc: {
          start: lastTokens[0].loc.start,
          end: lastTokens[1].loc.end
        },
        fix(fixer) {
          return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);
        }
      });
    } else if (option === "always" && adjacent) context.report({
      node,
      messageId: "selfCloseSlashNeedSpace",
      loc: {
        start: lastTokens[0].loc.start,
        end: lastTokens[1].loc.end
      },
      fix(fixer) {
        return fixer.insertTextBefore(lastTokens[1], " ");
      }
    });
  } else {
    const firstTokens = sourceCode.getFirstTokens(node, 2);
    adjacent = !sourceCode.isSpaceBetween(firstTokens[0], firstTokens[1]);
    if (option === "never") {
      if (!adjacent) context.report({
        node,
        messageId: "closeSlashNoSpace",
        loc: {
          start: firstTokens[0].loc.start,
          end: firstTokens[1].loc.end
        },
        fix(fixer) {
          return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);
        }
      });
    } else if (option === "always" && adjacent) context.report({
      node,
      messageId: "closeSlashNeedSpace",
      loc: {
        start: firstTokens[0].loc.start,
        end: firstTokens[1].loc.end
      },
      fix(fixer) {
        return fixer.insertTextBefore(firstTokens[1], " ");
      }
    });
  }
}
function validateBeforeSelfClosing(context, node, option) {
  const sourceCode = context.sourceCode;
  const leftToken = getTokenBeforeClosingBracket(node);
  const closingSlash = sourceCode.getTokenAfter(leftToken);
  if (!isSingleLine(node) && option === "proportional-always") {
    if ((0, ast_exports.isTokenOnSameLine)(leftToken, closingSlash)) {
      context.report({
        node,
        messageId: "beforeSelfCloseNeedNewline",
        loc: leftToken.loc.end,
        fix(fixer) {
          return fixer.insertTextBefore(closingSlash, "\n");
        }
      });
      return;
    }
  }
  if (!(0, ast_exports.isTokenOnSameLine)(leftToken, closingSlash)) return;
  const adjacent = !sourceCode.isSpaceBetween(leftToken, closingSlash);
  if ((option === "always" || option === "proportional-always") && adjacent) context.report({
    node,
    messageId: "beforeSelfCloseNeedSpace",
    loc: closingSlash.loc.start,
    fix(fixer) {
      return fixer.insertTextBefore(closingSlash, " ");
    }
  });
  else if (option === "never" && !adjacent) context.report({
    node,
    messageId: "beforeSelfCloseNoSpace",
    loc: closingSlash.loc.start,
    fix(fixer) {
      const previousToken = sourceCode.getTokenBefore(closingSlash);
      return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
    }
  });
}
function validateAfterOpening(context, node, option) {
  const sourceCode = context.sourceCode;
  const openingToken = sourceCode.getTokenBefore(node.name);
  if (option === "allow-multiline") {
    if (openingToken.loc.start.line !== node.name.loc.start.line) return;
  }
  const adjacent = !sourceCode.isSpaceBetween(openingToken, node.name);
  if (option === "never" || option === "allow-multiline") {
    if (!adjacent) context.report({
      node,
      messageId: "afterOpenNoSpace",
      loc: {
        start: openingToken.loc.start,
        end: node.name.loc.start
      },
      fix(fixer) {
        return fixer.removeRange([openingToken.range[1], node.name.range[0]]);
      }
    });
  } else if (option === "always" && adjacent) context.report({
    node,
    messageId: "afterOpenNeedSpace",
    loc: {
      start: openingToken.loc.start,
      end: node.name.loc.start
    },
    fix(fixer) {
      return fixer.insertTextBefore(node.name, " ");
    }
  });
}
function validateBeforeClosing(context, node, option) {
  if (!("selfClosing" in node && node.selfClosing)) {
    const sourceCode = context.sourceCode;
    const leftToken = option === "proportional-always" ? getTokenBeforeClosingBracket(node) : sourceCode.getLastTokens(node, 2)[0];
    const closingToken = sourceCode.getTokenAfter(leftToken);
    if (!isSingleLine(node) && option === "proportional-always") {
      if ((0, ast_exports.isTokenOnSameLine)(leftToken, closingToken)) {
        context.report({
          node,
          messageId: "beforeCloseNeedNewline",
          loc: leftToken.loc.end,
          fix(fixer) {
            return fixer.insertTextBefore(closingToken, "\n");
          }
        });
        return;
      }
    }
    if (leftToken.loc.start.line !== closingToken.loc.start.line) return;
    const adjacent = !sourceCode.isSpaceBetween(leftToken, closingToken);
    if (option === "never" && !adjacent) context.report({
      node,
      messageId: "beforeCloseNoSpace",
      loc: {
        start: leftToken.loc.end,
        end: closingToken.loc.start
      },
      fix(fixer) {
        return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);
      }
    });
    else if (option === "always" && adjacent) context.report({
      node,
      loc: {
        start: leftToken.loc.end,
        end: closingToken.loc.start
      },
      messageId: "beforeCloseNeedSpace",
      fix(fixer) {
        return fixer.insertTextBefore(closingToken, " ");
      }
    });
    else if (option === "proportional-always" && node.type === "JSXOpeningElement" && adjacent !== isSingleLine(node)) context.report({
      node,
      messageId: "beforeCloseNeedSpace",
      loc: {
        start: leftToken.loc.end,
        end: closingToken.loc.start
      },
      fix(fixer) {
        return fixer.insertTextBefore(closingToken, " ");
      }
    });
  }
}
var jsx_tag_spacing_default = createRule({
  name: "jsx-tag-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce whitespace in and around the JSX opening and closing brackets" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        closingSlash: {
          type: "string",
          enum: [
            "always",
            "never",
            "allow"
          ]
        },
        beforeSelfClosing: {
          type: "string",
          enum: [
            "always",
            "proportional-always",
            "never",
            "allow"
          ]
        },
        afterOpening: {
          type: "string",
          enum: [
            "always",
            "allow-multiline",
            "never",
            "allow"
          ]
        },
        beforeClosing: {
          type: "string",
          enum: [
            "always",
            "proportional-always",
            "never",
            "allow"
          ]
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      closingSlash: "never",
      beforeSelfClosing: "always",
      afterOpening: "never",
      beforeClosing: "allow"
    }],
    messages: {
      selfCloseSlashNoSpace: "Whitespace is forbidden between `/` and `>`; write `/>`",
      selfCloseSlashNeedSpace: "Whitespace is required between `/` and `>`; write `/ >`",
      closeSlashNoSpace: "Whitespace is forbidden between `<` and `/`; write `</`",
      closeSlashNeedSpace: "Whitespace is required between `<` and `/`; write `< /`",
      beforeSelfCloseNoSpace: "A space is forbidden before closing bracket",
      beforeSelfCloseNeedSpace: "A space is required before closing bracket",
      beforeSelfCloseNeedNewline: "A newline is required before closing bracket",
      afterOpenNoSpace: "A space is forbidden after opening bracket",
      afterOpenNeedSpace: "A space is required after opening bracket",
      beforeCloseNoSpace: "A space is forbidden before closing bracket",
      beforeCloseNeedSpace: "Whitespace is required before closing bracket",
      beforeCloseNeedNewline: "A newline is required before closing bracket"
    }
  },
  create(context, [options]) {
    const { closingSlash, beforeSelfClosing, afterOpening, beforeClosing } = options;
    return {
      JSXOpeningElement(node) {
        if (closingSlash !== "allow" && node.selfClosing) validateClosingSlash(context, node, closingSlash);
        if (afterOpening !== "allow") validateAfterOpening(context, node, afterOpening);
        if (beforeSelfClosing !== "allow" && node.selfClosing) validateBeforeSelfClosing(context, node, beforeSelfClosing);
        if (beforeClosing !== "allow") validateBeforeClosing(context, node, beforeClosing);
      },
      JSXClosingElement(node) {
        if (afterOpening !== "allow") validateAfterOpening(context, node, afterOpening);
        if (closingSlash !== "allow") validateClosingSlash(context, node, closingSlash);
        if (beforeClosing !== "allow") validateBeforeClosing(context, node, beforeClosing);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/jsx-wrap-multilines.js
var jsx_wrap_multilines_default = createRule({
  name: "jsx-wrap-multilines",
  meta: {
    type: "layout",
    docs: { description: "Disallow missing parentheses around multiline JSX" },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        declaration: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        assignment: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        return: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        arrow: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        condition: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        logical: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        prop: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        },
        propertyValue: {
          type: ["string", "boolean"],
          enum: [
            true,
            false,
            "ignore",
            "parens",
            "parens-new-line"
          ]
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      declaration: "parens",
      assignment: "parens",
      return: "parens",
      arrow: "parens",
      condition: "ignore",
      logical: "ignore",
      prop: "ignore",
      propertyValue: "ignore"
    }],
    messages: {
      missingParens: "Missing parentheses around multilines JSX",
      parensOnNewLines: "Parentheses around JSX should be on separate lines"
    }
  },
  create(context, [options]) {
    function isEnabled(type) {
      const option = options[type];
      return option && option !== "ignore";
    }
    const { sourceCode } = context;
    function needsOpeningNewLine(node) {
      const previousToken = sourceCode.getTokenBefore(node);
      if (!(0, ast_exports.isParenthesized)(node, sourceCode)) return false;
      if ((0, ast_exports.isTokenOnSameLine)(previousToken, node)) return true;
      return false;
    }
    function needsClosingNewLine(node) {
      const nextToken = sourceCode.getTokenAfter(node);
      if (!(0, ast_exports.isParenthesized)(node, sourceCode)) return false;
      if ((0, ast_exports.isTokenOnSameLine)(node, nextToken)) return true;
      return false;
    }
    function trimTokenBeforeNewline(tokenBefore) {
      const isBracket = tokenBefore.value === "{" || tokenBefore.value === "[";
      return `${tokenBefore.value.trim()}${isBracket ? "" : " "}`;
    }
    function check(node, type) {
      if (!node || !isJSX(node)) return;
      const option = options[type];
      if ((option === true || option === "parens") && !(0, ast_exports.isParenthesized)(node, sourceCode) && !isSingleLine(node)) context.report({
        node,
        messageId: "missingParens",
        fix: (fixer) => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
      });
      if (option === "parens-new-line" && !isSingleLine(node)) if (!(0, ast_exports.isParenthesized)(node, sourceCode)) {
        const tokenBefore = sourceCode.getTokenBefore(node);
        const tokenAfter = sourceCode.getTokenAfter(node);
        const start = node.loc.start;
        if (tokenBefore.loc.end.line < start.line) {
          const textBefore = sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim();
          const isTab = /^\t/.test(sourceCode.lines[start.line - 1]);
          const INDENT = isTab ? "	" : " ";
          const indentBefore = INDENT.repeat(start.column);
          const indentAfter = INDENT.repeat(Math.max(0, start.column - (isTab ? 1 : 2)));
          context.report({
            node,
            messageId: "missingParens",
            fix: (fixer) => fixer.replaceTextRange([tokenBefore.range[0], tokenAfter && (tokenAfter.value === ";" || tokenAfter.value === "}") ? tokenAfter.range[0] : node.range[1]], `${trimTokenBeforeNewline(tokenBefore)}(
${indentBefore}${textBefore}${textBefore.length > 0 ? `
${indentBefore}` : ""}${sourceCode.getText(node)}
${indentAfter})`)
          });
        } else context.report({
          node,
          messageId: "missingParens",
          fix: (fixer) => fixer.replaceText(node, `(
${sourceCode.getText(node)}
)`)
        });
      } else {
        const needsOpening = needsOpeningNewLine(node);
        const needsClosing = needsClosingNewLine(node);
        if (needsOpening || needsClosing) context.report({
          node,
          messageId: "parensOnNewLines",
          fix: (fixer) => {
            let fixed = sourceCode.getText(node);
            if (needsOpening) fixed = `
${fixed}`;
            if (needsClosing) fixed = `${fixed}
`;
            return fixer.replaceText(node, fixed);
          }
        });
      }
    }
    return {
      VariableDeclarator(node) {
        const type = "declaration";
        if (!isEnabled(type)) return;
        if (!isEnabled("condition") && node.init?.type === "ConditionalExpression") {
          check(node.init.consequent, type);
          check(node.init.alternate, type);
          return;
        }
        check(node.init, type);
      },
      AssignmentExpression(node) {
        const type = "assignment";
        if (!isEnabled(type)) return;
        if (!isEnabled("condition") && node.right.type === "ConditionalExpression") {
          check(node.right.consequent, type);
          check(node.right.alternate, type);
          return;
        }
        check(node.right, type);
      },
      ReturnStatement(node) {
        const type = "return";
        if (isEnabled(type)) check(node.argument, type);
      },
      "ArrowFunctionExpression:exit": (node) => {
        const arrowBody = node.body;
        const type = "arrow";
        if (isEnabled(type) && arrowBody.type !== "BlockStatement") check(arrowBody, type);
      },
      ConditionalExpression(node) {
        const type = "condition";
        if (isEnabled(type)) {
          check(node.consequent, type);
          check(node.alternate, type);
        }
      },
      LogicalExpression(node) {
        const type = "logical";
        if (isEnabled(type)) check(node.right, type);
      },
      JSXAttribute(node) {
        const type = "prop";
        if (isEnabled(type) && node.value?.type === "JSXExpressionContainer") check(node.value.expression, type);
      },
      ObjectExpression(node) {
        const type = "propertyValue";
        if (isEnabled(type)) node.properties.forEach((property) => {
          if (property.type === "Property" && property.value.type === "JSXElement") check(property.value, type);
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/key-spacing.js
var listeningNodes = [
  "ObjectExpression",
  "ObjectPattern",
  "ImportDeclaration",
  "ExportNamedDeclaration",
  "ExportAllDeclaration",
  "TSTypeLiteral",
  "TSInterfaceBody",
  "ClassBody"
];
function initOptionProperty(toOptions, fromOptions) {
  toOptions.mode = fromOptions.mode || "strict";
  if (typeof fromOptions.beforeColon !== "undefined") toOptions.beforeColon = +fromOptions.beforeColon;
  else toOptions.beforeColon = 0;
  if (typeof fromOptions.afterColon !== "undefined") toOptions.afterColon = +fromOptions.afterColon;
  else toOptions.afterColon = 1;
  if (typeof fromOptions.align !== "undefined") if (typeof fromOptions.align === "object") toOptions.align = fromOptions.align;
  else toOptions.align = {
    on: fromOptions.align,
    mode: toOptions.mode,
    beforeColon: toOptions.beforeColon,
    afterColon: toOptions.afterColon
  };
  return toOptions;
}
function initOptions(toOptions, fromOptions) {
  if (typeof fromOptions.align === "object") {
    toOptions.align = initOptionProperty({}, fromOptions.align);
    toOptions.align.on = fromOptions.align.on || "colon";
    toOptions.align.mode = fromOptions.align.mode || "strict";
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
  } else {
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
    if (toOptions.multiLine.align) toOptions.align = {
      on: toOptions.multiLine.align.on,
      mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
      beforeColon: toOptions.multiLine.align.beforeColon,
      afterColon: toOptions.multiLine.align.afterColon
    };
  }
  toOptions.ignoredNodes = fromOptions.ignoredNodes || [];
  return toOptions;
}
var key_spacing_default = createRule({
  name: "key-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing between property names and type annotations in types and interfaces" },
    fixable: "whitespace",
    schema: [{ anyOf: [
      {
        type: "object",
        properties: {
          align: { anyOf: [{
            type: "string",
            enum: ["colon", "value"]
          }, {
            type: "object",
            properties: {
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              on: {
                type: "string",
                enum: ["colon", "value"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          }] },
          mode: {
            type: "string",
            enum: ["strict", "minimum"]
          },
          beforeColon: { type: "boolean" },
          afterColon: { type: "boolean" },
          ignoredNodes: {
            type: "array",
            items: {
              type: "string",
              enum: listeningNodes
            }
          }
        },
        additionalProperties: false
      },
      {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              align: { anyOf: [{
                type: "string",
                enum: ["colon", "value"]
              }, {
                type: "object",
                properties: {
                  mode: {
                    type: "string",
                    enum: ["strict", "minimum"]
                  },
                  on: {
                    type: "string",
                    enum: ["colon", "value"]
                  },
                  beforeColon: { type: "boolean" },
                  afterColon: { type: "boolean" }
                },
                additionalProperties: false
              }] },
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      },
      {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          },
          align: {
            type: "object",
            properties: {
              mode: {
                type: "string",
                enum: ["strict", "minimum"]
              },
              on: {
                type: "string",
                enum: ["colon", "value"]
              },
              beforeColon: { type: "boolean" },
              afterColon: { type: "boolean" }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }
    ] }],
    defaultOptions: [{}],
    messages: {
      extraKey: "Extra space after {{computed}}key '{{key}}'.",
      extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
      missingKey: "Missing space after {{computed}}key '{{key}}'.",
      missingValue: "Missing space before value for {{computed}}key '{{key}}'."
    }
  },
  create(context, [_options]) {
    const options = _options || {};
    const ruleOptions = initOptions({}, options);
    const multiLineOptions = ruleOptions.multiLine;
    const singleLineOptions = ruleOptions.singleLine;
    const alignmentOptions = ruleOptions.align || null;
    const ignoredNodes = ruleOptions.ignoredNodes;
    const sourceCode = context.sourceCode;
    function containsLineTerminator(str) {
      return ast_exports.LINEBREAK_MATCHER.test(str);
    }
    function isSingleLineImportAttributes(node, sourceCode2) {
      if (node.type === "TSImportType") {
        if ("options" in node && node.options) return isSingleLine(node.options);
        return false;
      }
      const openingBrace = sourceCode2.getTokenBefore(node.attributes[0], ast_exports.isOpeningBraceToken);
      return (0, ast_exports.isTokenOnSameLine)(sourceCode2.getTokenAfter(node.attributes[node.attributes.length - 1], ast_exports.isClosingBraceToken), openingBrace);
    }
    function isSingleLineProperties(properties) {
      const [firstProp] = properties;
      return (0, ast_exports.isTokenOnSameLine)(properties.at(-1), firstProp);
    }
    function isKeyValueProperty(property) {
      if (property.type === "ImportAttribute") return true;
      return !("method" in property && property.method || "shorthand" in property && property.shorthand || "kind" in property && property.kind !== "init" || property.type !== "Property");
    }
    function getNextColon(node) {
      return sourceCode.getTokenAfter(node, ast_exports.isColonToken);
    }
    function getLastTokenBeforeColon(node) {
      const colonToken = getNextColon(node);
      return sourceCode.getTokenBefore(colonToken);
    }
    function getFirstTokenAfterColon(node) {
      const colonToken = getNextColon(node);
      return sourceCode.getTokenAfter(colonToken);
    }
    function continuesPropertyGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line;
      const candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;
      if (candidateValueStartLine - groupEndLine <= 1) return true;
      const leadingComments = sourceCode.getCommentsBefore(candidate);
      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - leadingComments.at(-1).loc.end.line <= 1) {
        for (let i = 1; i < leadingComments.length; i++) if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) return false;
        return true;
      }
      return false;
    }
    function getKey(property) {
      const key = property.key;
      if (property.type !== "ImportAttribute" && property.computed) return sourceCode.getText().slice(key.range[0], key.range[1]);
      return getStaticPropertyName(property);
    }
    function report(property, side, whitespace, expected, mode) {
      const diff = whitespace.length - expected;
      if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
        const nextColon = getNextColon(property.key);
        const tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true });
        const tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true });
        const isKeySide = side === "key";
        const isExtra = diff > 0;
        const diffAbs = Math.abs(diff);
        const spaces = new Array(diffAbs + 1).join(" ");
        const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
        const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
        const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
        const loc = isExtra ? {
          start: locStart,
          end: locEnd
        } : missingLoc;
        let fix;
        if (isExtra) {
          let range;
          if (isKeySide) range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
          else range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
          fix = function(fixer) {
            return fixer.removeRange(range);
          };
        } else if (isKeySide) fix = function(fixer) {
          return fixer.insertTextAfter(tokenBeforeColon, spaces);
        };
        else fix = function(fixer) {
          return fixer.insertTextBefore(tokenAfterColon, spaces);
        };
        let messageId;
        if (isExtra) messageId = side === "key" ? "extraKey" : "extraValue";
        else messageId = side === "key" ? "missingKey" : "missingValue";
        context.report({
          node: property[side],
          loc,
          messageId,
          data: {
            computed: property.type !== "ImportAttribute" && property.computed ? "computed " : "",
            key: getKey(property)
          },
          fix
        });
      }
    }
    function getKeyWidth(property) {
      const startToken = sourceCode.getFirstToken(property);
      const endToken = getLastTokenBeforeColon(property.key);
      return getStringLength(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));
    }
    function getPropertyWhitespace(property) {
      const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));
      if (whitespace) return {
        beforeColon: whitespace[1],
        afterColon: whitespace[2]
      };
      return null;
    }
    function createGroups(properties) {
      if (properties.length === 1) return [properties];
      return properties.reduce((groups, property) => {
        const currentGroup = groups.at(-1);
        const prev = currentGroup.at(-1);
        if (!prev || continuesPropertyGroup(prev, property)) currentGroup.push(property);
        else groups.push([property]);
        return groups;
      }, [[]]);
    }
    function verifyGroupAlignment(properties) {
      const length = properties.length;
      const widths = properties.map(getKeyWidth);
      const align = alignmentOptions.on;
      let targetWidth = Math.max(...widths);
      let beforeColon;
      let afterColon;
      let mode;
      if (alignmentOptions && length > 1) {
        beforeColon = alignmentOptions.beforeColon;
        afterColon = alignmentOptions.afterColon;
        mode = alignmentOptions.mode;
      } else {
        beforeColon = multiLineOptions.beforeColon;
        afterColon = multiLineOptions.afterColon;
        mode = alignmentOptions.mode;
      }
      targetWidth += align === "colon" ? beforeColon : afterColon;
      for (let i = 0; i < length; i++) {
        const property = properties[i];
        const whitespace = getPropertyWhitespace(property);
        if (whitespace) {
          const width = widths[i];
          if (align === "value") {
            report(property, "key", whitespace.beforeColon, beforeColon, mode);
            report(property, "value", whitespace.afterColon, targetWidth - width, mode);
          } else {
            report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
            report(property, "value", whitespace.afterColon, afterColon, mode);
          }
        }
      }
    }
    function verifySpacing(node, lineOptions) {
      if (ignoredNodes.includes(node.parent.type)) return;
      const actual = getPropertyWhitespace(node);
      if (actual) {
        report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
        report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
      }
    }
    function verifyListSpacing(properties, lineOptions) {
      const length = properties.length;
      for (let i = 0; i < length; i++) verifySpacing(properties[i], lineOptions);
    }
    function verifyAlignment(properties) {
      createGroups(properties).forEach((group) => {
        const properties2 = group.filter(isKeyValueProperty);
        if (properties2.length > 0 && isSingleLineProperties(properties2)) verifyListSpacing(properties2, multiLineOptions);
        else verifyGroupAlignment(properties2);
      });
    }
    function verifyImportAttributes(node) {
      if (ignoredNodes.includes(node.type)) return;
      if (!node.attributes) return;
      if (!node.attributes.length) return;
      if (isSingleLineImportAttributes(node, sourceCode)) verifyListSpacing(node.attributes, singleLineOptions);
      else verifyAlignment(node.attributes);
    }
    const baseRules = alignmentOptions ? {
      ObjectExpression(node) {
        if (ignoredNodes.includes(node.type)) return;
        if (isSingleLine(node)) verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
        else verifyAlignment(node.properties);
      },
      ImportDeclaration(node) {
        verifyImportAttributes(node);
      },
      ExportNamedDeclaration(node) {
        verifyImportAttributes(node);
      },
      ExportAllDeclaration(node) {
        verifyImportAttributes(node);
      }
    } : {
      Property(node) {
        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
      },
      ImportAttribute(node) {
        const parent = node.parent;
        verifySpacing(node, isSingleLineImportAttributes(parent, sourceCode) ? singleLineOptions : multiLineOptions);
      }
    };
    function adjustedColumn(position) {
      const line = position.line - 1;
      return getStringLength(sourceCode.lines.at(line).slice(0, position.column));
    }
    function isKeyTypeNode(node) {
      return (node.type === import_types.AST_NODE_TYPES.TSPropertySignature || node.type === import_types.AST_NODE_TYPES.TSIndexSignature || node.type === import_types.AST_NODE_TYPES.PropertyDefinition) && !!node.typeAnnotation;
    }
    function isApplicable(node) {
      return isKeyTypeNode(node) && (0, ast_exports.isTokenOnSameLine)(node, node.typeAnnotation);
    }
    function getKeyText(node) {
      if (node.type !== import_types.AST_NODE_TYPES.TSIndexSignature) return sourceCode.getText(node.key);
      return sourceCode.getText(node).slice(0, sourceCode.getTokenAfter(node.parameters.at(-1), ast_exports.isClosingBracketToken).range[1] - node.range[0]);
    }
    function getKeyLocEnd(node) {
      return getLastTokenBeforeColon(node.type !== import_types.AST_NODE_TYPES.TSIndexSignature ? node.key : node.parameters.at(-1)).loc.end;
    }
    function checkBeforeColon(node, expectedWhitespaceBeforeColon, mode) {
      const { typeAnnotation } = node;
      const difference = typeAnnotation.loc.start.column - getKeyLocEnd(node).column - expectedWhitespaceBeforeColon;
      if (mode === "strict" ? difference : difference < 0) context.report({
        node,
        messageId: difference > 0 ? "extraKey" : "missingKey",
        fix: (fixer) => {
          if (difference > 0) return fixer.removeRange([typeAnnotation.range[0] - difference, typeAnnotation.range[0]]);
          return fixer.insertTextBefore(typeAnnotation, " ".repeat(-difference));
        },
        data: {
          computed: "",
          key: getKeyText(node)
        }
      });
    }
    function checkAfterColon(node, expectedWhitespaceAfterColon, mode) {
      const { typeAnnotation } = node;
      const colonToken = sourceCode.getFirstToken(typeAnnotation);
      const difference = sourceCode.getTokenAfter(colonToken, { includeComments: true }).loc.start.column - colonToken.loc.start.column - 1 - expectedWhitespaceAfterColon;
      if (mode === "strict" ? difference : difference < 0) context.report({
        node,
        messageId: difference > 0 ? "extraValue" : "missingValue",
        fix: (fixer) => {
          if (difference > 0) return fixer.removeRange([colonToken.range[1], colonToken.range[1] + difference]);
          return fixer.insertTextAfter(colonToken, " ".repeat(-difference));
        },
        data: {
          computed: "",
          key: getKeyText(node)
        }
      });
    }
    function continuesAlignGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line;
      const candidateValueStartLine = (isKeyTypeNode(candidate) ? candidate.typeAnnotation : candidate).loc.start.line;
      if (candidateValueStartLine === groupEndLine) return false;
      if (candidateValueStartLine - groupEndLine === 1) return true;
      const leadingComments = sourceCode.getCommentsBefore(candidate);
      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - leadingComments.at(-1).loc.end.line <= 1) {
        for (let i = 1; i < leadingComments.length; i++) if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) return false;
        return true;
      }
      return false;
    }
    function checkAlignGroup(group) {
      let alignColumn = 0;
      const align = (typeof options.align === "object" ? options.align.on : typeof options.multiLine?.align === "object" ? options.multiLine.align.on : options.multiLine?.align ?? options.align) ?? "colon";
      const expectedWhitespaceBeforeColon = (typeof options.align === "object" ? options.align.beforeColon : options.multiLine ? typeof options.multiLine.align === "object" ? options.multiLine.align.beforeColon : options.multiLine.beforeColon : options.beforeColon) ?? false ? 1 : 0;
      const expectedWhitespaceAfterColon = (typeof options.align === "object" ? options.align.afterColon : options.multiLine ? typeof options.multiLine.align === "object" ? options.multiLine.align.afterColon : options.multiLine.afterColon : options.afterColon) ?? true ? 1 : 0;
      const mode = (typeof options.align === "object" ? options.align.mode : options.multiLine ? typeof options.multiLine.align === "object" ? options.multiLine.align.mode ?? options.multiLine.mode : options.multiLine.mode : options.mode) ?? "strict";
      for (const node of group) if (isKeyTypeNode(node)) {
        const keyEnd = adjustedColumn(getKeyLocEnd(node));
        alignColumn = Math.max(alignColumn, align === "colon" ? keyEnd + expectedWhitespaceBeforeColon : keyEnd + 1 + expectedWhitespaceAfterColon + expectedWhitespaceBeforeColon);
      }
      for (const node of group) {
        if (!isApplicable(node)) continue;
        const { typeAnnotation } = node;
        const toCheck = align === "colon" ? typeAnnotation : typeAnnotation.typeAnnotation;
        const difference = adjustedColumn(toCheck.loc.start) - alignColumn;
        if (difference) context.report({
          node,
          messageId: difference > 0 ? align === "colon" ? "extraKey" : "extraValue" : align === "colon" ? "missingKey" : "missingValue",
          fix: (fixer) => {
            if (difference > 0) return fixer.removeRange([toCheck.range[0] - difference, toCheck.range[0]]);
            return fixer.insertTextBefore(toCheck, " ".repeat(-difference));
          },
          data: {
            computed: "",
            key: getKeyText(node)
          }
        });
        if (align === "colon") checkAfterColon(node, expectedWhitespaceAfterColon, mode);
        else checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);
      }
    }
    function checkIndividualNode(node, { singleLine }) {
      const expectedWhitespaceBeforeColon = (singleLine ? options.singleLine ? options.singleLine.beforeColon : options.beforeColon : options.multiLine ? options.multiLine.beforeColon : options.beforeColon) ?? false ? 1 : 0;
      const expectedWhitespaceAfterColon = (singleLine ? options.singleLine ? options.singleLine.afterColon : options.afterColon : options.multiLine ? options.multiLine.afterColon : options.afterColon) ?? true ? 1 : 0;
      const mode = (singleLine ? options.singleLine ? options.singleLine.mode : options.mode : options.multiLine ? options.multiLine.mode : options.mode) ?? "strict";
      if (isApplicable(node)) {
        checkBeforeColon(node, expectedWhitespaceBeforeColon, mode);
        checkAfterColon(node, expectedWhitespaceAfterColon, mode);
      }
    }
    function validateBody(body) {
      if (ignoredNodes.includes(body.type)) return;
      const members = body.type === import_types.AST_NODE_TYPES.TSTypeLiteral ? body.members : body.body;
      let alignGroups = [];
      let unalignedElements = [];
      if (options.align || options.multiLine?.align) {
        let currentAlignGroup = [];
        alignGroups.push(currentAlignGroup);
        let prevNode;
        for (const node of members) {
          let prevAlignedNode = currentAlignGroup.at(-1);
          if (prevAlignedNode !== prevNode) prevAlignedNode = void 0;
          if (prevAlignedNode && continuesAlignGroup(prevAlignedNode, node)) currentAlignGroup.push(node);
          else if (prevNode?.loc.start.line === node.loc.start.line) {
            if (prevAlignedNode) {
              unalignedElements.push(prevAlignedNode);
              currentAlignGroup.pop();
            }
            unalignedElements.push(node);
          } else {
            currentAlignGroup = [node];
            alignGroups.push(currentAlignGroup);
          }
          prevNode = node;
        }
        unalignedElements = unalignedElements.concat(...alignGroups.filter((group) => group.length === 1));
        alignGroups = alignGroups.filter((group) => group.length >= 2);
      } else unalignedElements = members;
      for (const group of alignGroups) checkAlignGroup(group);
      for (const node of unalignedElements) checkIndividualNode(node, { singleLine: isSingleLine(body) });
    }
    return {
      ...baseRules,
      TSTypeLiteral: validateBody,
      TSInterfaceBody: validateBody,
      ClassBody: validateBody
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/keyword-spacing.js
var PREV_TOKEN = /^[)\]}>]$/u;
var NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
var PREV_TOKEN_M = /^[)\]}>*]$/u;
var NEXT_TOKEN_M = /^[{*]$/u;
var TEMPLATE_OPEN_PAREN = /\$\{$/u;
var TEMPLATE_CLOSE_PAREN = /^\}/u;
var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;
var keyword_spacing_default = createRule({
  name: "keyword-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before and after keywords" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" },
        overrides: {
          type: "object",
          properties: KEYWORDS.reduce((retv, key) => {
            retv[key] = {
              type: "object",
              properties: {
                before: { type: "boolean" },
                after: { type: "boolean" }
              },
              additionalProperties: false
            };
            return retv;
          }, {}),
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      before: true,
      after: true,
      overrides: {}
    }],
    messages: {
      expectedBefore: 'Expected space(s) before "{{value}}".',
      expectedAfter: 'Expected space(s) after "{{value}}".',
      unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
      unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const tokensToIgnore = /* @__PURE__ */ new WeakSet();
    function isOpenParenOfTemplate(token) {
      return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
    }
    function isCloseParenOfTemplate(token) {
      return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
    }
    function expectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && (0, ast_exports.isTokenOnSameLine)(prevToken, token) && !sourceCode.isSpaceBetween(prevToken, token)) context.report({
        loc: token.loc,
        messageId: "expectedBefore",
        data: token,
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }
    function unexpectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && (0, ast_exports.isTokenOnSameLine)(prevToken, token) && sourceCode.isSpaceBetween(prevToken, token)) context.report({
        loc: {
          start: prevToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedBefore",
        data: token,
        fix(fixer) {
          return fixer.removeRange([prevToken.range[1], token.range[0]]);
        }
      });
    }
    function expectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && (0, ast_exports.isTokenOnSameLine)(token, nextToken) && !sourceCode.isSpaceBetween(token, nextToken)) context.report({
        loc: token.loc,
        messageId: "expectedAfter",
        data: token,
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }
    function unexpectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && (0, ast_exports.isTokenOnSameLine)(token, nextToken) && sourceCode.isSpaceBetween(token, nextToken)) context.report({
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedAfter",
        data: token,
        fix(fixer) {
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }
    function parseOptions(options2) {
      const { before, after, overrides } = options2;
      const defaultValue = {
        before: before ? expectSpaceBefore : unexpectSpaceBefore,
        after: after ? expectSpaceAfter : unexpectSpaceAfter
      };
      const retv = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < KEYWORDS.length; ++i) {
        const key = KEYWORDS[i];
        const override = overrides[key];
        if (override) {
          const thisBefore = "before" in override ? override.before : before;
          const thisAfter = "after" in override ? override.after : after;
          retv[key] = {
            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
          };
        } else retv[key] = defaultValue;
      }
      return retv;
    }
    const checkMethodMap = parseOptions(options);
    function checkSpacingBefore(token, pattern) {
      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
    }
    function checkSpacingAfter(token, pattern) {
      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
    }
    function checkSpacingAround(token) {
      checkSpacingBefore(token);
      checkSpacingAfter(token);
    }
    function checkSpacingAroundFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (!firstToken) return;
      if (!isKeywordToken(firstToken)) if (node.type === "VariableDeclaration") {
        if (node.kind !== "using" && node.kind !== "await using" || firstToken.type !== "Identifier") return;
      } else return;
      checkSpacingAround(firstToken);
    }
    function checkSpacingBeforeFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (isKeywordToken(firstToken)) checkSpacingBefore(firstToken);
    }
    function checkSpacingAroundTokenBefore(node) {
      if (node) {
        const token = sourceCode.getTokenBefore(node, isKeywordToken);
        if (token) checkSpacingAround(token);
      }
    }
    function checkSpacingForFunction(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (firstToken && (isKeywordToken(firstToken) && firstToken.value === "function" || firstToken.value === "async")) checkSpacingBefore(firstToken);
    }
    function checkSpacingForClass(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.superClass);
    }
    function checkSpacingForModuleDeclaration(node) {
      const firstToken = sourceCode.getFirstToken(node);
      checkSpacingBefore(firstToken, PREV_TOKEN_M);
      checkSpacingAfter(firstToken, NEXT_TOKEN_M);
      if (node.type === "ExportDefaultDeclaration") checkSpacingAround(sourceCode.getTokenAfter(firstToken));
      if (node.type === "ExportAllDeclaration" && node.exported) {
        const asToken = sourceCode.getTokenBefore(node.exported);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
        checkSpacingAfter(asToken, NEXT_TOKEN_M);
      }
      if ("source" in node && node.source) {
        const fromToken = sourceCode.getTokenBefore(node.source);
        checkSpacingBefore(fromToken, PREV_TOKEN_M);
        checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        if (node.attributes) {
          const withToken = sourceCode.getTokenAfter(node.source);
          if (isKeywordToken(withToken)) checkSpacingAround(withToken);
        }
      }
      if (node.type !== "ExportDefaultDeclaration") checkSpacingForTypeKeywordInImportExport(node);
    }
    function checkSpacingForTypeKeywordInImportExport(node) {
      let kind;
      switch (node.type) {
        case import_types.AST_NODE_TYPES.ImportDeclaration:
          kind = node.importKind;
          break;
        case import_types.AST_NODE_TYPES.ExportAllDeclaration:
        case import_types.AST_NODE_TYPES.ExportNamedDeclaration:
          kind = node.exportKind;
          break;
      }
      if (kind !== "type") return;
      const typeToken = sourceCode.getFirstToken(node, { skip: 1 });
      if (!(0, ast_exports.isTypeKeyword)(typeToken)) return;
      checkSpacingBefore(typeToken, PREV_TOKEN_M);
      checkSpacingAfter(typeToken, NEXT_TOKEN_M);
    }
    function checkSpacingForProperty(node) {
      if ("static" in node && node.static) checkSpacingAroundFirstToken(node);
      if (node.kind === "get" || node.kind === "set" || ("method" in node && node.method || node.type === "MethodDefinition") && "async" in node.value && node.value.async || node.type === import_types.AST_NODE_TYPES.AccessorProperty) {
        const token = sourceCode.getTokenBefore(node.key, (tok) => {
          switch (tok.value) {
            case "get":
            case "set":
            case "async":
            case "accessor":
              return true;
            default:
              return false;
          }
        });
        if (!token) throw new Error("Failed to find token get, set, or async beside method name");
        checkSpacingAround(token);
      }
    }
    return {
      DebuggerStatement: checkSpacingAroundFirstToken,
      WithStatement: checkSpacingAroundFirstToken,
      BreakStatement: checkSpacingAroundFirstToken,
      ContinueStatement: checkSpacingAroundFirstToken,
      ReturnStatement: checkSpacingAroundFirstToken,
      ThrowStatement: checkSpacingAroundFirstToken,
      TryStatement(node) {
        checkSpacingAroundFirstToken(node);
        if (node.handler) if (node.handler.param) checkSpacingBeforeFirstToken(node.handler);
        else checkSpacingAroundFirstToken(node.handler);
        checkSpacingAroundTokenBefore(node.finalizer);
      },
      IfStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.alternate);
      },
      SwitchStatement: checkSpacingAroundFirstToken,
      SwitchCase: checkSpacingAroundFirstToken,
      DoWhileStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.test);
      },
      ForInStatement(node) {
        checkSpacingAroundFirstToken(node);
        const inToken = sourceCode.getTokenBefore(node.right, ast_exports.isNotOpeningParenToken);
        if (sourceCode.getTokenBefore(inToken).type !== "PrivateIdentifier") checkSpacingBefore(inToken);
        checkSpacingAfter(inToken);
      },
      ForOfStatement(node) {
        if (node.await) {
          checkSpacingBefore(sourceCode.getFirstToken(node, 0));
          checkSpacingAfter(sourceCode.getFirstToken(node, 1));
        } else checkSpacingAroundFirstToken(node);
        const ofToken = sourceCode.getTokenBefore(node.right, ast_exports.isNotOpeningParenToken);
        if (sourceCode.getTokenBefore(ofToken).type !== "PrivateIdentifier") checkSpacingBefore(ofToken);
        checkSpacingAfter(ofToken);
      },
      ForStatement: checkSpacingAroundFirstToken,
      WhileStatement: checkSpacingAroundFirstToken,
      ClassDeclaration: checkSpacingForClass,
      ExportNamedDeclaration: checkSpacingForModuleDeclaration,
      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
      ExportAllDeclaration: checkSpacingForModuleDeclaration,
      FunctionDeclaration: checkSpacingForFunction,
      ImportDeclaration: checkSpacingForModuleDeclaration,
      VariableDeclaration: checkSpacingAroundFirstToken,
      ArrowFunctionExpression: checkSpacingForFunction,
      AwaitExpression(node) {
        checkSpacingBefore(sourceCode.getFirstToken(node));
      },
      ClassExpression: checkSpacingForClass,
      FunctionExpression: checkSpacingForFunction,
      NewExpression: checkSpacingBeforeFirstToken,
      Super: checkSpacingBeforeFirstToken,
      ThisExpression: checkSpacingBeforeFirstToken,
      UnaryExpression: checkSpacingBeforeFirstToken,
      YieldExpression: checkSpacingBeforeFirstToken,
      ImportSpecifier(node) {
        if (node.imported.range[0] !== node.local.range[0]) checkSpacingBefore(sourceCode.getTokenBefore(node.local), PREV_TOKEN_M);
      },
      ExportSpecifier(node) {
        if (node.local.range[0] !== node.exported.range[0]) {
          const asToken = sourceCode.getTokenBefore(node.exported);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
          checkSpacingAfter(asToken, NEXT_TOKEN_M);
        }
      },
      ImportNamespaceSpecifier(node) {
        checkSpacingBefore(sourceCode.getFirstToken(node, 1), PREV_TOKEN_M);
      },
      MethodDefinition: checkSpacingForProperty,
      PropertyDefinition: checkSpacingForProperty,
      AccessorProperty: checkSpacingForProperty,
      StaticBlock: checkSpacingAroundFirstToken,
      Property: checkSpacingForProperty,
      BinaryExpression(node) {
        if (node.operator !== ">") return;
        const operatorToken = sourceCode.getTokenBefore(node.right, ast_exports.isNotOpeningParenToken);
        tokensToIgnore.add(operatorToken);
      },
      TSAsExpression(node) {
        checkSpacingAround(sourceCode.getTokenAfter(node.expression, (token) => token.value === "as"));
      },
      TSSatisfiesExpression(node) {
        checkSpacingAround(sourceCode.getTokenAfter(node.expression, (token) => token.value === "satisfies"));
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/line-comment-position.js
var line_comment_position_default = createRule({
  name: "line-comment-position",
  meta: {
    type: "layout",
    docs: { description: "Enforce position of line comments" },
    schema: [{ oneOf: [{
      type: "string",
      enum: ["above", "beside"]
    }, {
      type: "object",
      properties: {
        position: {
          type: "string",
          enum: ["above", "beside"]
        },
        ignorePattern: { type: "string" },
        applyDefaultPatterns: { type: "boolean" },
        applyDefaultIgnorePatterns: { type: "boolean" }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["above"],
    messages: {
      above: "Expected comment to be above code.",
      beside: "Expected comment to be beside code."
    }
  },
  create(context, [options]) {
    if (typeof options !== "string") warnDeprecatedOptions(options, "applyDefaultPatterns", "applyDefaultIgnorePatterns", "line-comment-position");
    const { position = "above", ignorePattern, applyDefaultPatterns = true, applyDefaultIgnorePatterns = applyDefaultPatterns } = typeof options === "string" ? { position: options } : options;
    const above = position === "above";
    const customIgnoreRegExp = ignorePattern ? new RegExp(ignorePattern, "u") : null;
    const defaultIgnoreRegExp = COMMENTS_IGNORE_PATTERN;
    const fallThroughRegExp = /^\s*falls?\s?through/u;
    const sourceCode = context.sourceCode;
    return { Program() {
      sourceCode.getAllComments().forEach((node) => {
        if (node.type !== "Line") return;
        if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) return;
        if (customIgnoreRegExp?.test(node.value)) return;
        const previous = sourceCode.getTokenBefore(node, { includeComments: true });
        const isOnSameLine = previous && (0, ast_exports.isTokenOnSameLine)(previous, node);
        if (above) {
          if (isOnSameLine) context.report({
            node,
            messageId: "above"
          });
        } else if (!isOnSameLine) context.report({
          node,
          messageId: "beside"
        });
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/linebreak-style.js
var linebreak_style_default = createRule({
  name: "linebreak-style",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent linebreak style" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["unix", "windows"]
    }],
    defaultOptions: ["unix"],
    messages: {
      expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
      expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
    }
  },
  create(context, [linebreakStyle]) {
    const sourceCode = context.sourceCode;
    if (!isTextSourceCode(sourceCode) || !hasLinesAndGetLocFromIndex(sourceCode)) return {};
    const source = sourceCode.text;
    const lines = sourceCode.lines;
    const expectedLF = linebreakStyle === "unix";
    const expectedLFChars = expectedLF ? "\n" : "\r\n";
    let currentIndex = 0;
    for (const line of lines.slice(0, -1)) {
      const startIndex = currentIndex + line.length;
      const startLoc = sourceCode.getLocFromIndex(startIndex);
      let endIndex = startIndex + 1;
      let endLoc = sourceCode.getLocFromIndex(endIndex);
      while (endLoc.line === startLoc.line && endIndex < source.length) {
        endIndex++;
        endLoc = sourceCode.getLocFromIndex(endIndex);
      }
      if (source.slice(startIndex, endIndex) !== expectedLFChars) context.report({
        loc: {
          start: startLoc,
          end: endLoc
        },
        messageId: expectedLF ? "expectedLF" : "expectedCRLF",
        fix: (fixer) => fixer.replaceTextRange([startIndex, endIndex], expectedLFChars)
      });
      currentIndex = endIndex;
    }
    return {};
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/lines-around-comment.js
function getEmptyLineNums(lines) {
  const emptyLines = [];
  lines.forEach((line, i) => {
    if (!line.trim()) emptyLines.push(i + 1);
  });
  return emptyLines;
}
function getCommentLineNums(comments) {
  const lines = [];
  comments.forEach((token) => {
    const start = token.loc.start.line;
    const end = token.loc.end.line;
    lines.push(start, end);
  });
  return lines;
}
var lines_around_comment_default = createRule({
  name: "lines-around-comment",
  meta: {
    type: "layout",
    docs: { description: "Require empty lines around comments" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        beforeBlockComment: { type: "boolean" },
        afterBlockComment: { type: "boolean" },
        beforeLineComment: { type: "boolean" },
        afterLineComment: { type: "boolean" },
        allowBlockStart: { type: "boolean" },
        allowBlockEnd: { type: "boolean" },
        allowClassStart: { type: "boolean" },
        allowClassEnd: { type: "boolean" },
        allowObjectStart: { type: "boolean" },
        allowObjectEnd: { type: "boolean" },
        allowArrayStart: { type: "boolean" },
        allowArrayEnd: { type: "boolean" },
        allowInterfaceStart: { type: "boolean" },
        allowInterfaceEnd: { type: "boolean" },
        allowTypeStart: { type: "boolean" },
        allowTypeEnd: { type: "boolean" },
        allowEnumStart: { type: "boolean" },
        allowEnumEnd: { type: "boolean" },
        allowModuleStart: { type: "boolean" },
        allowModuleEnd: { type: "boolean" },
        ignorePattern: { type: "string" },
        applyDefaultIgnorePatterns: { type: "boolean" },
        afterHashbangComment: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{ beforeBlockComment: true }],
    messages: {
      after: "Expected line after comment.",
      before: "Expected line before comment."
    }
  },
  create(context, [options]) {
    const defaultIgnoreRegExp = COMMENTS_IGNORE_PATTERN;
    const { beforeBlockComment, afterBlockComment, beforeLineComment, afterLineComment, afterHashbangComment, allowBlockStart, allowBlockEnd, allowClassStart, allowClassEnd, allowObjectStart, allowObjectEnd, allowArrayStart, allowArrayEnd, allowInterfaceStart, allowInterfaceEnd, allowTypeStart, allowTypeEnd, allowEnumStart, allowEnumEnd, allowModuleStart, allowModuleEnd, applyDefaultIgnorePatterns, ignorePattern = "" } = options;
    const customIgnoreRegExp = ignorePattern ? new RegExp(ignorePattern, "u") : null;
    const sourceCode = context.sourceCode;
    const comments = sourceCode.getAllComments();
    const lines = sourceCode.lines;
    const numLines = lines.length + 1;
    const commentLines = getCommentLineNums(comments);
    const emptyLines = getEmptyLineNums(lines);
    const commentAndEmptyLines = new Set(commentLines.concat(emptyLines));
    function codeAroundComment(token) {
      let currentToken = token;
      do
        currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
      while (currentToken && (0, ast_exports.isCommentToken)(currentToken));
      if (currentToken && (0, ast_exports.isTokenOnSameLine)(currentToken, token)) return true;
      currentToken = token;
      do
        currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
      while (currentToken && (0, ast_exports.isCommentToken)(currentToken));
      if (currentToken && (0, ast_exports.isTokenOnSameLine)(token, currentToken)) return true;
      return false;
    }
    function isParentNodeType(parent, nodeType) {
      return parent.type === nodeType;
    }
    function getParentNodeOfToken(token) {
      const node = sourceCode.getNodeByRangeIndex(token.range[0]);
      if (node && node.type === "StaticBlock") {
        const openingBrace = sourceCode.getFirstToken(node, { skip: 1 });
        return openingBrace && token.range[0] >= openingBrace.range[0] ? node : null;
      }
      return node;
    }
    function isCommentAtParentStart(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      if (parent && isParentNodeType(parent, nodeType)) {
        let parentStartNodeOrToken = parent;
        if (parent.type === "StaticBlock") parentStartNodeOrToken = sourceCode.getFirstToken(parent, { skip: 1 });
        else if (parent.type === "SwitchStatement") parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, { filter: ast_exports.isOpeningBraceToken });
        return !!parentStartNodeOrToken && token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;
      }
      return false;
    }
    function isCommentAtParentEnd(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return !!parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
    }
    function isCommentAtBlockStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ClassBody) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.BlockStatement) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.StaticBlock) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.SwitchCase) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.SwitchStatement);
    }
    function isCommentAtBlockEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ClassBody) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.BlockStatement) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.StaticBlock) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.SwitchCase) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.SwitchStatement);
    }
    function isCommentAtClassStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ClassBody);
    }
    function isCommentAtClassEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ClassBody);
    }
    function isCommentAtObjectStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ObjectExpression) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ObjectPattern);
    }
    function isCommentAtObjectEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ObjectExpression) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ObjectPattern);
    }
    function isCommentAtArrayStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ArrayExpression) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.ArrayPattern);
    }
    function isCommentAtArrayEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ArrayExpression) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.ArrayPattern);
    }
    function isCommentAtInterfaceStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.TSInterfaceBody);
    }
    function isCommentAtInterfaceEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.TSInterfaceBody);
    }
    function isCommentAtTypeStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.TSTypeLiteral);
    }
    function isCommentAtTypeEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.TSTypeLiteral);
    }
    function isCommentAtEnumStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.TSEnumBody) || isCommentAtParentStart(token, import_types.AST_NODE_TYPES.TSEnumDeclaration);
    }
    function isCommentAtEnumEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.TSEnumBody) || isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.TSEnumDeclaration);
    }
    function isCommentAtModuleStart(token) {
      return isCommentAtParentStart(token, import_types.AST_NODE_TYPES.TSModuleBlock);
    }
    function isCommentAtModuleEnd(token) {
      return isCommentAtParentEnd(token, import_types.AST_NODE_TYPES.TSModuleBlock);
    }
    function checkForEmptyLine(token, { before, after }) {
      if (applyDefaultIgnorePatterns !== false && defaultIgnoreRegExp.test(token.value)) return;
      if (customIgnoreRegExp?.test(token.value)) return;
      const prevLineNum = token.loc.start.line - 1;
      const nextLineNum = token.loc.end.line + 1;
      if (prevLineNum < 1) before = false;
      if (nextLineNum >= numLines) after = false;
      if (codeAroundComment(token)) return;
      const blockStartAllowed = Boolean(allowBlockStart) && isCommentAtBlockStart(token) && !(allowClassStart === false && isCommentAtClassStart(token));
      const blockEndAllowed = Boolean(allowBlockEnd) && isCommentAtBlockEnd(token) && !(allowClassEnd === false && isCommentAtClassEnd(token));
      const classStartAllowed = Boolean(allowClassStart) && isCommentAtClassStart(token);
      const classEndAllowed = Boolean(allowClassEnd) && isCommentAtClassEnd(token);
      const objectStartAllowed = Boolean(allowObjectStart) && isCommentAtObjectStart(token);
      const objectEndAllowed = Boolean(allowObjectEnd) && isCommentAtObjectEnd(token);
      const arrayStartAllowed = Boolean(allowArrayStart) && isCommentAtArrayStart(token);
      const arrayEndAllowed = Boolean(allowArrayEnd) && isCommentAtArrayEnd(token);
      const interfaceStartAllowed = Boolean(allowInterfaceStart) && isCommentAtInterfaceStart(token);
      const interfaceEndAllowed = Boolean(allowInterfaceEnd) && isCommentAtInterfaceEnd(token);
      const typeStartAllowed = Boolean(allowTypeStart) && isCommentAtTypeStart(token);
      const typeEndAllowed = Boolean(allowTypeEnd) && isCommentAtTypeEnd(token);
      const enumStartAllowed = Boolean(allowEnumStart) && isCommentAtEnumStart(token);
      const enumEndAllowed = Boolean(allowEnumEnd) && isCommentAtEnumEnd(token);
      const moduleStartAllowed = Boolean(allowModuleStart) && isCommentAtModuleStart(token);
      const moduleEndAllowed = Boolean(allowModuleEnd) && isCommentAtModuleEnd(token);
      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed || interfaceStartAllowed || typeStartAllowed || enumStartAllowed || moduleStartAllowed;
      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed || interfaceEndAllowed || typeEndAllowed || enumEndAllowed || moduleEndAllowed;
      const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
      const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
      if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) && !((0, ast_exports.isCommentToken)(previousTokenOrComment) && (0, ast_exports.isTokenOnSameLine)(previousTokenOrComment, token))) {
        const lineStart = token.range[0] - token.loc.start.column;
        const range = [lineStart, lineStart];
        context.report({
          node: token,
          messageId: "before",
          fix(fixer) {
            return fixer.insertTextBeforeRange(range, "\n");
          }
        });
      }
      if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) && !((0, ast_exports.isCommentToken)(nextTokenOrComment) && (0, ast_exports.isTokenOnSameLine)(token, nextTokenOrComment))) context.report({
        node: token,
        messageId: "after",
        fix(fixer) {
          return fixer.insertTextAfter(token, "\n");
        }
      });
    }
    return { Program() {
      comments.forEach((token) => {
        if (token.type === import_types.AST_TOKEN_TYPES.Line) {
          if (beforeLineComment || afterLineComment) checkForEmptyLine(token, {
            after: afterLineComment,
            before: beforeLineComment
          });
        } else if (token.type === import_types.AST_TOKEN_TYPES.Block) {
          if (beforeBlockComment || afterBlockComment) checkForEmptyLine(token, {
            after: afterBlockComment,
            before: beforeBlockComment
          });
        } else if (isHashbangComment(token)) {
          if (afterHashbangComment) checkForEmptyLine(token, {
            after: afterHashbangComment,
            before: false
          });
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/lines-between-class-members.js
var ClassMemberTypes = {
  "*": { test: () => true },
  "field": { test: (node) => node.type === "PropertyDefinition" },
  "method": { test: (node) => node.type === "MethodDefinition" }
};
var lines_between_class_members_default = createRule({
  name: "lines-between-class-members",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow an empty line between class members" },
    fixable: "whitespace",
    schema: [{ anyOf: [{
      type: "object",
      properties: { enforce: {
        type: "array",
        items: {
          type: "object",
          properties: {
            blankLine: {
              type: "string",
              enum: ["always", "never"]
            },
            prev: {
              type: "string",
              enum: [
                "method",
                "field",
                "*"
              ]
            },
            next: {
              type: "string",
              enum: [
                "method",
                "field",
                "*"
              ]
            }
          },
          additionalProperties: false,
          required: [
            "blankLine",
            "prev",
            "next"
          ]
        },
        minItems: 1
      } },
      additionalProperties: false,
      required: ["enforce"]
    }, {
      type: "string",
      enum: ["always", "never"]
    }] }, {
      type: "object",
      properties: {
        exceptAfterSingleLine: { type: "boolean" },
        exceptAfterOverload: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: ["always", {
      exceptAfterOverload: true,
      exceptAfterSingleLine: false
    }],
    messages: {
      never: "Unexpected blank line between class members.",
      always: "Expected blank line between class members."
    }
  },
  create(context, [firstOption, secondOption]) {
    const configureList = typeof firstOption === "object" ? firstOption.enforce : [{
      blankLine: firstOption,
      prev: "*",
      next: "*"
    }];
    const { exceptAfterSingleLine } = secondOption;
    const exceptAfterOverload = secondOption?.exceptAfterOverload && (firstOption === "always" || typeof firstOption !== "string" && firstOption?.enforce.some(({ blankLine, prev, next }) => blankLine === "always" && prev !== "field" && next !== "field"));
    const sourceCode = context.sourceCode;
    function getBoundaryTokens(curNode, nextNode) {
      const lastToken = sourceCode.getLastToken(curNode);
      const prevToken = sourceCode.getTokenBefore(lastToken);
      const nextToken = sourceCode.getFirstToken(nextNode);
      return (0, ast_exports.isSemicolonToken)(lastToken) && !(0, ast_exports.isTokenOnSameLine)(prevToken, lastToken) && (0, ast_exports.isTokenOnSameLine)(lastToken, nextToken) ? {
        curLast: prevToken,
        nextFirst: lastToken
      } : {
        curLast: lastToken,
        nextFirst: nextToken
      };
    }
    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {
      const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });
      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);
      return prevLastToken;
    }
    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {
      const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });
      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);
      return nextFirstToken;
    }
    function hasTokenOrCommentBetween(before, after) {
      return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;
    }
    function match(node, type) {
      return ClassMemberTypes[type].test(node);
    }
    function getPaddingType(prevNode, nextNode) {
      for (let i = configureList.length - 1; i >= 0; --i) {
        const configure = configureList[i];
        if (match(prevNode, configure.prev) && match(nextNode, configure.next)) return configure.blankLine;
      }
      return null;
    }
    function isOverload(node) {
      return (node.type === import_types.AST_NODE_TYPES.TSAbstractMethodDefinition || node.type === import_types.AST_NODE_TYPES.MethodDefinition) && node.value.type === import_types.AST_NODE_TYPES.TSEmptyBodyFunctionExpression;
    }
    return { ClassBody(node) {
      const body = exceptAfterOverload ? node.body.filter((node2) => !isOverload(node2)) : node.body;
      for (let i = 0; i < body.length - 1; i++) {
        const curFirst = sourceCode.getFirstToken(body[i]);
        const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);
        const skip = !!(0, ast_exports.isTokenOnSameLine)(curFirst, curLast) && exceptAfterSingleLine;
        const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);
        const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);
        const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
        const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
        const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);
        const paddingType = getPaddingType(body[i], body[i + 1]);
        if (paddingType === "never" && isPadded) context.report({
          node: body[i + 1],
          messageId: "never",
          fix(fixer) {
            if (hasTokenInPadding) return null;
            return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n");
          }
        });
        else if (paddingType === "always" && !skip && !isPadded) context.report({
          node: body[i + 1],
          messageId: "always",
          fix(fixer) {
            if (hasTokenInPadding) return null;
            return fixer.insertTextAfter(curLineLastToken, "\n");
          }
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/list-style.js
var list_style_default = createRule({
  name: "list-style",
  meta: {
    type: "layout",
    docs: {
      description: "Enforce consistent spacing and line break styles inside brackets.",
      experimental: true
    },
    fixable: "whitespace",
    schema: [{
      $defs: {
        singleLineConfig: {
          type: "object",
          additionalProperties: false,
          properties: {
            spacing: {
              type: "string",
              enum: ["always", "never"]
            },
            maxItems: {
              type: "integer",
              minimum: 0
            }
          }
        },
        multiLineConfig: {
          type: "object",
          additionalProperties: false,
          properties: { minItems: {
            type: "integer",
            minimum: 0
          } }
        },
        baseConfig: {
          type: "object",
          additionalProperties: false,
          properties: {
            singleLine: { $ref: "#/items/0/$defs/singleLineConfig" },
            multiline: { $ref: "#/items/0/$defs/multiLineConfig" }
          }
        }
      },
      type: "object",
      additionalProperties: false,
      properties: {
        singleLine: { $ref: "#/items/0/$defs/singleLineConfig" },
        multiLine: { $ref: "#/items/0/$defs/multiLineConfig" },
        overrides: {
          type: "object",
          additionalProperties: false,
          properties: {
            "[]": { $ref: "#/items/0/$defs/baseConfig" },
            "{}": { $ref: "#/items/0/$defs/baseConfig" },
            "<>": { $ref: "#/items/0/$defs/baseConfig" },
            "()": { $ref: "#/items/0/$defs/baseConfig" },
            "ArrayExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "ArrayPattern": { $ref: "#/items/0/$defs/baseConfig" },
            "ArrowFunctionExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "CallExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "ExportNamedDeclaration": { $ref: "#/items/0/$defs/baseConfig" },
            "FunctionDeclaration": { $ref: "#/items/0/$defs/baseConfig" },
            "FunctionExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "ImportDeclaration": { $ref: "#/items/0/$defs/baseConfig" },
            "ImportAttributes": { $ref: "#/items/0/$defs/baseConfig" },
            "NewExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "ObjectExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "ObjectPattern": { $ref: "#/items/0/$defs/baseConfig" },
            "TSDeclareFunction": { $ref: "#/items/0/$defs/baseConfig" },
            "TSFunctionType": { $ref: "#/items/0/$defs/baseConfig" },
            "TSInterfaceBody": { $ref: "#/items/0/$defs/baseConfig" },
            "TSEnumBody": { $ref: "#/items/0/$defs/baseConfig" },
            "TSTupleType": { $ref: "#/items/0/$defs/baseConfig" },
            "TSTypeLiteral": { $ref: "#/items/0/$defs/baseConfig" },
            "TSTypeParameterDeclaration": { $ref: "#/items/0/$defs/baseConfig" },
            "TSTypeParameterInstantiation": { $ref: "#/items/0/$defs/baseConfig" },
            "JSONArrayExpression": { $ref: "#/items/0/$defs/baseConfig" },
            "JSONObjectExpression": { $ref: "#/items/0/$defs/baseConfig" }
          }
        }
      }
    }],
    defaultOptions: [{
      singleLine: {
        spacing: "never",
        maxItems: Number.POSITIVE_INFINITY
      },
      multiLine: { minItems: 0 },
      overrides: { "{}": { singleLine: { spacing: "always" } } }
    }],
    messages: {
      shouldSpacing: `Should have space between '{{prev}}' and '{{next}}'`,
      shouldNotSpacing: `Should not have space(s) between '{{prev}}' and '{{next}}'`,
      shouldWrap: `Should have line break between '{{prev}}' and '{{next}}'`,
      shouldNotWrap: `Should not have line break(s) between '{{prev}}' and '{{next}}'`
    }
  },
  create: (context, [options]) => {
    const { sourceCode } = context;
    const { singleLine, multiLine, overrides } = options;
    const _resolvedOptions = {};
    function resolveOption(parenType, nodeType) {
      if (!_resolvedOptions[nodeType]) {
        const overridesByParen = overrides[parenType] ?? {};
        const overridesByNode = overrides[nodeType] ?? {};
        _resolvedOptions[nodeType] = {
          singleLine: {
            ...singleLine,
            ...overridesByParen.singleLine,
            ...overridesByNode.singleLine
          },
          multiline: {
            ...multiLine,
            ...overridesByParen.multiline,
            ...overridesByNode.multiline
          }
        };
      }
      return _resolvedOptions[nodeType];
    }
    function getDelimiter(root, current2) {
      if (root.type !== "TSInterfaceBody" && root.type !== "TSTypeLiteral") return;
      return current2.value.match(/(?:,|;)$/) ? void 0 : ",";
    }
    function checkSpacing(node, left, right, config) {
      const shouldSpace = config.singleLine.spacing === "always";
      const firstToken = sourceCode.getTokenAfter(left, { includeComments: true });
      const lastToken = sourceCode.getTokenBefore(right, { includeComments: true });
      function doCheck(prev, next) {
        const spaced = sourceCode.isSpaceBetween(prev, next);
        if (!spaced && shouldSpace) context.report({
          node,
          messageId: "shouldSpacing",
          loc: {
            start: prev.loc.end,
            end: next.loc.start
          },
          data: {
            prev: prev.value,
            next: next.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(prev, " ");
          }
        });
        else if (spaced && !shouldSpace) context.report({
          node,
          messageId: "shouldNotSpacing",
          loc: {
            start: prev.loc.end,
            end: next.loc.start
          },
          data: {
            prev: prev.value,
            next: next.value
          },
          fix(fixer) {
            return fixer.removeRange([prev.range[1], next.range[0]]);
          }
        });
      }
      doCheck(left, firstToken);
      doCheck(lastToken, right);
    }
    function checkWrap(node, items, left, right, config) {
      const len = items.length;
      const needWrap = isSingleLine(node) ? len > config.singleLine.maxItems : len >= config.multiline.minItems && !(0, ast_exports.isTokenOnSameLine)(left, items[0] ?? sourceCode.getTokenAfter(left));
      function doCheck(prev, next) {
        if ((0, ast_exports.isTokenOnSameLine)(prev, next)) {
          if (!needWrap) return;
          context.report({
            node,
            messageId: "shouldWrap",
            loc: {
              start: prev.loc.end,
              end: next.loc.start
            },
            data: {
              prev: prev.value,
              next: next.value
            },
            fix(fixer) {
              if (sourceCode.commentsExistBetween(prev, next)) return null;
              return fixer.insertTextBefore(next, "\n");
            }
          });
        } else {
          if (needWrap) return;
          context.report({
            node,
            messageId: "shouldNotWrap",
            loc: {
              start: prev.loc.end,
              end: next.loc.start
            },
            data: {
              prev: prev.value,
              next: next.value
            },
            fix: safeReplaceTextBetween(sourceCode, prev, next, () => items.length === 1 ? "" : getDelimiter(node, prev) ?? "")
          });
        }
      }
      const tokenAfterLeft = sourceCode.getTokenAfter(left, { includeComments: false });
      doCheck(left, tokenAfterLeft);
      for (let i = 0; i < len; i++) {
        const currentItem = items[i];
        if (!currentItem) continue;
        const currentFirstToken = sourceCode.getFirstToken(currentItem);
        if (i === 0 && tokenAfterLeft === currentFirstToken) continue;
        doCheck(sourceCode.getTokenBefore(currentItem, {
          filter: (token) => (0, ast_exports.isNotOpeningParenToken)(token) || token === left,
          includeComments: false
        }), currentFirstToken);
      }
      doCheck(sourceCode.getTokenBefore(right, { includeComments: false }), right);
    }
    const parenMatchers = {
      "[]": {
        left: ast_exports.isOpeningBracketToken,
        right: ast_exports.isClosingBracketToken
      },
      "{}": {
        left: ast_exports.isOpeningBraceToken,
        right: ast_exports.isClosingBraceToken
      },
      "()": {
        left: ast_exports.isOpeningParenToken,
        right: ast_exports.isClosingParenToken
      },
      "<>": {
        left: (token) => token.value === "<",
        right: (token) => token.value === ">"
      }
    };
    function getLeftParen(node, items, type) {
      switch (node.type) {
        case import_types.AST_NODE_TYPES.CallExpression:
        case import_types.AST_NODE_TYPES.NewExpression:
          return sourceCode.getTokenAfter(node.typeArguments ?? node.callee);
        case import_types.AST_NODE_TYPES.ArrayExpression:
        case import_types.AST_NODE_TYPES.ArrayPattern:
          return sourceCode.getFirstToken(node);
        default: {
          const maybeLeft = sourceCode.getTokenBefore(items[0]);
          const { left: matcher } = parenMatchers[type];
          return maybeLeft && matcher(maybeLeft) ? maybeLeft : null;
        }
      }
    }
    function getRightParen(node, items, type) {
      switch (node.type) {
        case import_types.AST_NODE_TYPES.ArrayExpression:
        case import_types.AST_NODE_TYPES.ArrayPattern:
          return sourceCode.getLastToken(node);
        default: {
          const maybeRight = sourceCode.getTokenAfter(items.at(-1), ast_exports.isNotCommaToken);
          const { right: matcher } = parenMatchers[type];
          return maybeRight && matcher(maybeRight) ? maybeRight : null;
        }
      }
    }
    function check(parenType, node, items) {
      if (items.length === 0) return;
      const left = getLeftParen(node, items, parenType);
      const right = getRightParen(node, items, parenType);
      if (!left || !right) return;
      const config = resolveOption(parenType, items[0]?.type === "ImportAttribute" ? "ImportAttributes" : node.type);
      if ((0, ast_exports.isTokenOnSameLine)(left, right) && items.length <= config.singleLine.maxItems) checkSpacing(node, left, right, config);
      else checkWrap(node, items, left, right, config);
    }
    return {
      ArrayExpression(node) {
        check("[]", node, node.elements);
      },
      ArrayPattern(node) {
        check("[]", node, node.elements);
      },
      ObjectExpression(node) {
        check("{}", node, node.properties);
      },
      ObjectPattern(node) {
        check("{}", node, node.properties);
      },
      FunctionDeclaration(node) {
        check("()", node, node.params);
      },
      FunctionExpression(node) {
        check("()", node, node.params);
      },
      ArrowFunctionExpression(node) {
        check("()", node, node.params);
      },
      CallExpression(node) {
        check("()", node, node.arguments);
      },
      NewExpression(node) {
        check("()", node, node.arguments);
      },
      ImportDeclaration(node) {
        check("{}", node, node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier"));
        if (node.attributes) check("{}", node, node.attributes);
      },
      ExportNamedDeclaration(node) {
        check("{}", node, node.specifiers);
        if (node.attributes) check("{}", node, node.attributes);
      },
      ExportAllDeclaration(node) {
        if (node.attributes) check("{}", node, node.attributes);
      },
      TSTupleType(node) {
        check("[]", node, node.elementTypes);
      },
      TSTypeLiteral(node) {
        check("{}", node, node.members);
      },
      TSInterfaceBody(node) {
        check("{}", node, node.body);
      },
      TSEnumBody(node) {
        check("{}", node, node.members);
      },
      TSDeclareFunction(node) {
        check("()", node, node.params);
      },
      TSFunctionType(node) {
        check("()", node, node.params);
      },
      TSTypeParameterDeclaration(node) {
        check("<>", node, node.params);
      },
      TSTypeParameterInstantiation(node) {
        check("<>", node, node.params);
      },
      JSONArrayExpression(node) {
        check("[]", node, node.elements);
      },
      JSONObjectExpression(node) {
        check("{}", node, node.properties);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/max-len.js
var OPTIONS_SCHEMA = {
  type: "object",
  properties: {
    code: {
      type: "integer",
      minimum: 0
    },
    comments: {
      type: "integer",
      minimum: 0
    },
    tabWidth: {
      type: "integer",
      minimum: 0
    },
    ignorePattern: { type: "string" },
    ignoreComments: { type: "boolean" },
    ignoreStrings: { type: "boolean" },
    ignoreUrls: { type: "boolean" },
    ignoreTemplateLiterals: { type: "boolean" },
    ignoreRegExpLiterals: { type: "boolean" },
    ignoreTrailingComments: { type: "boolean" }
  },
  additionalProperties: false
};
var OPTIONS_OR_INTEGER_SCHEMA = { anyOf: [OPTIONS_SCHEMA, {
  type: "integer",
  minimum: 0
}] };
var max_len_default = createRule({
  name: "max-len",
  meta: {
    type: "layout",
    docs: { description: "Enforce a maximum line length" },
    schema: [
      OPTIONS_OR_INTEGER_SCHEMA,
      OPTIONS_OR_INTEGER_SCHEMA,
      OPTIONS_SCHEMA
    ],
    defaultOptions: [{
      code: 80,
      tabWidth: 4
    }],
    messages: {
      max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
      maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
    }
  },
  create(context) {
    const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
    const sourceCode = context.sourceCode;
    function computeLineLength(line, tabWidth2) {
      let extraCharacterCount = 0;
      line.replace(/\t/gu, (_, offset2) => {
        const totalOffset = offset2 + extraCharacterCount;
        const spaceCount = tabWidth2 - (tabWidth2 ? totalOffset % tabWidth2 : 0);
        extraCharacterCount += spaceCount - 1;
        return "";
      });
      return Array.from(line).length + extraCharacterCount;
    }
    const options = Object.assign({}, context.options[context.options.length - 1]);
    if (typeof context.options[0] === "number") options.code = context.options[0];
    if (typeof context.options[1] === "number") options.tabWidth = context.options[1];
    const maxLength = typeof options.code === "number" ? options.code : 80;
    const tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4;
    const ignoreComments = !!options.ignoreComments;
    const ignoreStrings = !!options.ignoreStrings;
    const ignoreTemplateLiterals = !!options.ignoreTemplateLiterals;
    const ignoreRegExpLiterals = !!options.ignoreRegExpLiterals;
    const ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments;
    const ignoreUrls = !!options.ignoreUrls;
    const maxCommentLength = options.comments;
    let ignorePattern = null;
    if (options.ignorePattern) ignorePattern = new RegExp(options.ignorePattern, "u");
    function isTrailingComment(line, lineNumber, comment) {
      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
    }
    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start;
      const end = comment.loc.end;
      const isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
    }
    function isJSXEmptyExpressionInSingleLineContainer(node) {
      if (!node || !node.parent || node.type !== "JSXEmptyExpression" || node.parent.type !== "JSXExpressionContainer") return false;
      const parent = node.parent;
      return isSingleLine(parent);
    }
    function stripTrailingComment(line, comment) {
      return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
    }
    function ensureArrayAndPush(object, key, value) {
      if (!Array.isArray(object[key])) object[key] = [];
      object[key].push(value);
    }
    function getAllStrings() {
      return sourceCode.ast.tokens.filter((token) => token.type === "String" || token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute");
    }
    function getAllTemplateLiterals() {
      return sourceCode.ast.tokens.filter((token) => token.type === "Template");
    }
    function getAllRegExpLiterals() {
      return sourceCode.ast.tokens.filter((token) => token.type === "RegularExpression");
    }
    function groupArrayByLineNumber(arr) {
      const obj = {};
      for (let i = 0; i < arr.length; i++) {
        const node = arr[i];
        for (let j = node.loc.start.line; j <= node.loc.end.line; ++j) ensureArrayAndPush(obj, j, node);
      }
      return obj;
    }
    function getAllComments() {
      const comments = [];
      sourceCode.getAllComments().forEach((commentNode) => {
        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);
        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
          if (comments[comments.length - 1] !== containingNode.parent) comments.push(containingNode.parent);
        } else comments.push(commentNode);
      });
      return comments;
    }
    function checkProgramForMaxLength(node) {
      const lines = sourceCode.lines;
      const comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
      let commentsIndex = 0;
      const stringsByLine = groupArrayByLineNumber(getAllStrings());
      const templateLiteralsByLine = groupArrayByLineNumber(getAllTemplateLiterals());
      const regExpLiteralsByLine = groupArrayByLineNumber(getAllRegExpLiterals());
      lines.forEach((line, i) => {
        const lineNumber = i + 1;
        let lineIsComment = false;
        let textToMeasure;
        if (commentsIndex < comments.length) {
          let comment = null;
          do
            comment = comments[++commentsIndex];
          while (comment && comment.loc.start.line <= lineNumber);
          comment = comments[--commentsIndex];
          if (isFullLineComment(line, lineNumber, comment)) {
            lineIsComment = true;
            textToMeasure = line;
          } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
            textToMeasure = stripTrailingComment(line, comment);
            let lastIndex = commentsIndex;
            while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
          } else textToMeasure = line;
        } else textToMeasure = line;
        if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) return;
        const lineLength = computeLineLength(textToMeasure, tabWidth);
        const commentLengthApplies = lineIsComment && maxCommentLength;
        if (lineIsComment && ignoreComments) return;
        const loc = {
          start: {
            line: lineNumber,
            column: 0
          },
          end: {
            line: lineNumber,
            column: textToMeasure.length
          }
        };
        if (commentLengthApplies) {
          if (lineLength > maxCommentLength) context.report({
            node,
            loc,
            messageId: "maxComment",
            data: {
              lineLength,
              maxCommentLength
            }
          });
        } else if (lineLength > maxLength) context.report({
          node,
          loc,
          messageId: "max",
          data: {
            lineLength,
            maxLength
          }
        });
      });
    }
    return { Program: checkProgramForMaxLength };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/max-statements-per-line.js
var listeningNodes2 = [
  "BreakStatement",
  "ClassDeclaration",
  "ContinueStatement",
  "DebuggerStatement",
  "DoWhileStatement",
  "ExpressionStatement",
  "ForInStatement",
  "ForOfStatement",
  "ForStatement",
  "FunctionDeclaration",
  "IfStatement",
  "ImportDeclaration",
  "LabeledStatement",
  "ReturnStatement",
  "SwitchStatement",
  "ThrowStatement",
  "TryStatement",
  "VariableDeclaration",
  "WhileStatement",
  "WithStatement",
  "ExportNamedDeclaration",
  "ExportDefaultDeclaration",
  "ExportAllDeclaration"
];
var max_statements_per_line_default = createRule({
  name: "max-statements-per-line",
  meta: {
    type: "layout",
    docs: { description: "Enforce a maximum number of statements allowed per line" },
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 1
        },
        ignoredNodes: {
          type: "array",
          items: {
            type: "string",
            enum: listeningNodes2
          }
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{ max: 1 }],
    messages: { exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}." }
  },
  create(context, [options]) {
    const { max: maxStatementsPerLine = 1, ignoredNodes = [] } = options;
    const sourceCode = context.sourceCode;
    let lastStatementLine = 0;
    let numberOfStatementsOnThisLine = 0;
    let firstExtraStatement = null;
    const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;
    function reportFirstExtraStatementAndClear() {
      if (firstExtraStatement) context.report({
        node: firstExtraStatement,
        messageId: "exceed",
        data: {
          numberOfStatementsOnThisLine,
          maxStatementsPerLine,
          statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
        }
      });
      firstExtraStatement = null;
    }
    function getActualLastToken2(node) {
      return sourceCode.getLastToken(node, ast_exports.isNotSemicolonToken);
    }
    function enterStatement(node) {
      const line = node.loc.start.line;
      if (node.parent && SINGLE_CHILD_ALLOWED.test(node.parent.type) && (!("alternate" in node.parent) || node.parent.alternate !== node)) return;
      if (line === lastStatementLine) numberOfStatementsOnThisLine += 1;
      else {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }
      if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) firstExtraStatement = firstExtraStatement || node;
    }
    function leaveStatement(node) {
      const line = getActualLastToken2(node).loc.end.line;
      if (line !== lastStatementLine) {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }
    }
    const listeners = { "Program:exit": reportFirstExtraStatementAndClear };
    for (const node of listeningNodes2) {
      if (ignoredNodes.includes(node)) continue;
      listeners[node] = enterStatement;
      listeners[`${node}:exit`] = leaveStatement;
    }
    return listeners;
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/member-delimiter-style.js
function isLastTokenEndOfLine(token, line) {
  return token.loc.start.column === line.length - 1;
}
function isCommentsEndOfLine(token, comments, line) {
  if (!comments) return false;
  if (comments.loc.end.line > token.loc.end.line) return true;
  return comments.loc.end.column === line.length;
}
function makeFixFunction({ optsNone, optsSemi, lastToken, commentsAfterLastToken, missingDelimiter, lastTokenLine, isSingleLine: isSingleLine2 }) {
  if (optsNone && !isLastTokenEndOfLine(lastToken, lastTokenLine) && !isCommentsEndOfLine(lastToken, commentsAfterLastToken, lastTokenLine) && !isSingleLine2) return;
  return (fixer) => {
    if (optsNone) return fixer.remove(lastToken);
    const token = optsSemi ? ";" : ",";
    if (missingDelimiter) return fixer.insertTextAfter(lastToken, token);
    return fixer.replaceText(lastToken, token);
  };
}
var BASE_SCHEMA = {
  type: "object",
  properties: {
    multiline: {
      type: "object",
      properties: {
        delimiter: { $ref: "#/items/0/$defs/multiLineOption" },
        requireLast: { type: "boolean" }
      },
      additionalProperties: false
    },
    singleline: {
      type: "object",
      properties: {
        delimiter: { $ref: "#/items/0/$defs/singleLineOption" },
        requireLast: { type: "boolean" }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};
var member_delimiter_style_default = createRule({
  name: "member-delimiter-style",
  meta: {
    type: "layout",
    docs: { description: "Require a specific member delimiter style for interfaces and type literals" },
    fixable: "whitespace",
    schema: [{
      $defs: {
        multiLineOption: {
          type: "string",
          enum: [
            "none",
            "semi",
            "comma"
          ]
        },
        singleLineOption: {
          type: "string",
          enum: ["semi", "comma"]
        },
        delimiterConfig: BASE_SCHEMA
      },
      type: "object",
      properties: {
        ...BASE_SCHEMA.properties,
        overrides: {
          type: "object",
          properties: {
            interface: { $ref: "#/items/0/$defs/delimiterConfig" },
            typeLiteral: { $ref: "#/items/0/$defs/delimiterConfig" }
          },
          additionalProperties: false
        },
        multilineDetection: {
          type: "string",
          enum: ["brackets", "last-member"]
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      multiline: {
        delimiter: "semi",
        requireLast: true
      },
      singleline: {
        delimiter: "semi",
        requireLast: false
      },
      multilineDetection: "brackets"
    }],
    messages: {
      unexpectedComma: "Unexpected separator (,).",
      unexpectedSemi: "Unexpected separator (;).",
      expectedComma: "Expected a comma.",
      expectedSemi: "Expected a semicolon."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const baseOptions = options;
    const overrides = baseOptions.overrides ?? {};
    const interfaceOptions = deepMerge(baseOptions, overrides.interface);
    const typeLiteralOptions = deepMerge(baseOptions, overrides.typeLiteral);
    function checkLastToken(member, opts, isLast) {
      function getOption(type) {
        if (isLast && !opts.requireLast) return type === "none";
        return opts.delimiter === type;
      }
      let messageId = null;
      let missingDelimiter = false;
      const lastToken = sourceCode.getLastToken(member, { includeComments: false });
      if (!lastToken) return;
      const commentsAfterLastToken = sourceCode.getCommentsAfter(lastToken).pop();
      const lastTokenLine = sourceCode.getLines()[lastToken?.loc.start.line - 1];
      const optsSemi = getOption("semi");
      const optsComma = getOption("comma");
      const optsNone = getOption("none");
      if (lastToken.value === ";") {
        if (optsComma) messageId = "expectedComma";
        else if (optsNone) {
          missingDelimiter = true;
          messageId = "unexpectedSemi";
        }
      } else if (lastToken.value === ",") {
        if (optsSemi) messageId = "expectedSemi";
        else if (optsNone) {
          missingDelimiter = true;
          messageId = "unexpectedComma";
        }
      } else if (optsSemi) {
        missingDelimiter = true;
        messageId = "expectedSemi";
      } else if (optsComma) {
        missingDelimiter = true;
        messageId = "expectedComma";
      }
      if (messageId) context.report({
        node: lastToken,
        loc: {
          start: {
            line: lastToken.loc.end.line,
            column: lastToken.loc.end.column
          },
          end: {
            line: lastToken.loc.end.line,
            column: lastToken.loc.end.column
          }
        },
        messageId,
        fix: makeFixFunction({
          optsNone,
          optsSemi,
          lastToken,
          commentsAfterLastToken,
          missingDelimiter,
          lastTokenLine,
          isSingleLine: opts.type === "single-line"
        })
      });
    }
    function checkMemberSeparatorStyle(node) {
      const members = node.type === import_types.AST_NODE_TYPES.TSInterfaceBody ? node.body : node.members;
      let _isSingleLine = isSingleLine(node);
      if (options.multilineDetection === "last-member" && !_isSingleLine && members.length > 0) {
        if (members[members.length - 1].loc.end.line === node.loc.end.line) _isSingleLine = true;
      }
      const typeOpts = node.type === import_types.AST_NODE_TYPES.TSInterfaceBody ? interfaceOptions : typeLiteralOptions;
      const opts = _isSingleLine ? {
        ...typeOpts.singleline,
        type: "single-line"
      } : {
        ...typeOpts.multiline,
        type: "multi-line"
      };
      members.forEach((member, index2) => {
        checkLastToken(member, opts ?? {}, index2 === members.length - 1);
      });
    }
    return {
      TSInterfaceBody: checkMemberSeparatorStyle,
      TSTypeLiteral: checkMemberSeparatorStyle
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/multiline-comment-style.js
var multiline_comment_style_default = createRule({
  name: "multiline-comment-style",
  meta: {
    type: "suggestion",
    docs: { description: "Enforce a particular style for multiline comments" },
    fixable: "whitespace",
    schema: { anyOf: [{
      type: "array",
      items: [{
        enum: ["starred-block", "bare-block"],
        type: "string"
      }],
      additionalItems: false
    }, {
      type: "array",
      items: [{
        enum: ["separate-lines"],
        type: "string"
      }, {
        type: "object",
        properties: {
          checkJSDoc: { type: "boolean" },
          checkExclamation: { type: "boolean" }
        },
        additionalProperties: false
      }],
      additionalItems: false
    }] },
    defaultOptions: ["starred-block"],
    messages: {
      expectedBlock: "Expected a block comment instead of consecutive line comments.",
      expectedBareBlock: "Expected a block comment without padding stars.",
      startNewline: "Expected a linebreak after '/*'.",
      endNewline: "Expected a linebreak before '*/'.",
      missingStar: "Expected a '*' at the start of this line.",
      alignment: "Expected this line to be aligned with the start of the comment.",
      expectedLines: "Expected multiple line comments instead of a block comment."
    }
  },
  create(context, [style, options = {}]) {
    const { checkJSDoc, checkExclamation } = options;
    const sourceCode = context.sourceCode;
    function isStarredCommentLine(line) {
      return /^\s*\*/u.test(line);
    }
    function isStarredBlockComment([firstComment]) {
      if (firstComment.type !== "Block") return false;
      const lines = firstComment.value.split(ast_exports.LINEBREAK_MATCHER);
      return lines.length > 0 && lines.every((line, i) => i === 0 || i === lines.length - 1 ? isWhiteSpaces(line) : isStarredCommentLine(line));
    }
    function isJSDocComment([firstComment]) {
      if (firstComment.type !== "Block") return false;
      const lines = firstComment.value.split(ast_exports.LINEBREAK_MATCHER);
      return /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every((line) => /^\s* /u.test(line)) && isWhiteSpaces(lines.at(-1));
    }
    function isExclamationComment([firstComment]) {
      if (firstComment.type !== "Block") return false;
      const lines = firstComment.value.split(ast_exports.LINEBREAK_MATCHER);
      return /^!\s*$/u.test(lines[0]) && lines.slice(1, -1).every((line) => /^\s* /u.test(line)) && isWhiteSpaces(lines.at(-1));
    }
    function processSeparateLineComments(commentGroup) {
      const allLinesHaveLeadingSpace = commentGroup.every(({ value: line }) => line.trim().length === 0 || line.startsWith(" "));
      return commentGroup.map(({ value }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, "") : value);
    }
    function processStarredBlockComment(comment) {
      const lines = comment.value.split(ast_exports.LINEBREAK_MATCHER).slice(1, -1).map((line) => line.replace(WHITE_SPACES_PATTERN, ""));
      const allLinesHaveLeadingSpace = lines.every((line) => {
        const lineWithoutPrefix = line.replace(/\s*\*/u, "");
        return lineWithoutPrefix.trim().length === 0 || lineWithoutPrefix.startsWith(" ");
      });
      return lines.map((line) => line.replace(allLinesHaveLeadingSpace ? /\s*\* ?/u : /\s*\*/u, ""));
    }
    function processBareBlockComment(comment) {
      const lines = comment.value.split(ast_exports.LINEBREAK_MATCHER).map((line) => line.replace(WHITE_SPACES_PATTERN, ""));
      const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;
      let offset2 = "";
      for (const [i, line] of lines.entries()) {
        if (!line.trim().length || i === 0) continue;
        const [, lineOffset] = line.match(/^(\s*\*?\s*)/u);
        if (lineOffset.length < leadingWhitespace.length) {
          const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);
          if (newOffset.length > offset2.length) offset2 = newOffset;
        }
      }
      return lines.map((line) => {
        const [, lineOffset, lineContents] = line.match(/^(\s*\*?\s*)(.*)/u);
        if (lineOffset.length > leadingWhitespace.length) return `${lineOffset.slice(leadingWhitespace.length - (offset2.length + lineOffset.length))}${lineContents}`;
        if (lineOffset.length < leadingWhitespace.length) return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;
        return lineContents;
      });
    }
    function getCommentLines(commentGroup) {
      const [firstComment] = commentGroup;
      if (firstComment.type === "Line") return processSeparateLineComments(commentGroup);
      if (isStarredBlockComment(commentGroup)) return processStarredBlockComment(firstComment);
      return processBareBlockComment(firstComment);
    }
    function getInitialOffset(comment) {
      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);
    }
    function convertToStarredBlock(firstComment, commentLinesList) {
      const initialOffset = getInitialOffset(firstComment);
      return `/*
${commentLinesList.map((line) => `${initialOffset} * ${line}`).join("\n")}
${initialOffset} */`;
    }
    function convertToSeparateLines(firstComment, commentLinesList) {
      return commentLinesList.map((line) => `// ${line}`).join(`
${getInitialOffset(firstComment)}`);
    }
    function convertToBlock(firstComment, commentLinesList) {
      return `/* ${commentLinesList.join(`
${getInitialOffset(firstComment)}   `)} */`;
    }
    const commentGroupCheckers = {
      "starred-block": function(commentGroup) {
        const [firstComment] = commentGroup;
        const commentLines = getCommentLines(commentGroup);
        if (commentLines.some((value) => value.includes("*/"))) return;
        if (commentGroup.length > 1) context.report({
          loc: {
            start: firstComment.loc.start,
            end: commentGroup.at(-1).loc.end
          },
          messageId: "expectedBlock",
          fix(fixer) {
            const range = [firstComment.range[0], commentGroup.at(-1).range[1]];
            return commentLines.some((value) => value.startsWith("/")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));
          }
        });
        else {
          const lines = firstComment.value.split(ast_exports.LINEBREAK_MATCHER);
          const expectedLinePrefix = `${getInitialOffset(firstComment)} *`;
          if (!/^[*!]?\s*$/u.test(lines[0])) {
            const start = /^[*!]/.test(firstComment.value) ? firstComment.range[0] + 1 : firstComment.range[0];
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: {
                  line: firstComment.loc.start.line,
                  column: firstComment.loc.start.column + 2
                }
              },
              messageId: "startNewline",
              fix: (fixer) => fixer.insertTextAfterRange([start, start + 2], `
${expectedLinePrefix}`)
            });
          }
          if (!isWhiteSpaces(lines.at(-1))) context.report({
            loc: {
              start: {
                line: firstComment.loc.end.line,
                column: firstComment.loc.end.column - 2
              },
              end: firstComment.loc.end
            },
            messageId: "endNewline",
            fix: (fixer) => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `
${expectedLinePrefix}/`)
          });
          for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
            const lineText = sourceCode.lines[lineNumber - 1];
            const errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";
            if (!lineText.startsWith(expectedLinePrefix)) context.report({
              loc: {
                start: {
                  line: lineNumber,
                  column: 0
                },
                end: {
                  line: lineNumber,
                  column: lineText.length
                }
              },
              messageId: errorType,
              fix(fixer) {
                const lineStartIndex = sourceCode.getIndexFromLoc({
                  line: lineNumber,
                  column: 0
                });
                if (errorType === "alignment") {
                  const [, commentTextPrefix2 = ""] = lineText.match(/^(\s*\*)/u) || [];
                  const commentTextStartIndex2 = lineStartIndex + commentTextPrefix2.length;
                  return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex2], expectedLinePrefix);
                }
                const [, commentTextPrefix = ""] = lineText.match(/^(\s*)/u) || [];
                const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                let offset2;
                for (const [idx, line] of lines.entries()) {
                  if (!/\S+/u.test(line)) continue;
                  const [, prefix = "", initialOffset = ""] = sourceCode.lines[firstComment.loc.start.line - 1 + idx].match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                  offset2 = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;
                  if (/^\s*\//u.test(lineText) && offset2.length === 0) offset2 += " ";
                  break;
                }
                return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset2}`);
              }
            });
          }
        }
      },
      "separate-lines": function(commentGroup) {
        const [firstComment] = commentGroup;
        const isJSDoc = isJSDocComment(commentGroup);
        const isExclamation = isExclamationComment(commentGroup);
        if (firstComment.type !== "Block" || !checkJSDoc && isJSDoc || !checkExclamation && isExclamation) return;
        let commentLines = getCommentLines(commentGroup);
        if (isJSDoc || isExclamation) commentLines = commentLines.slice(1, commentLines.length - 1);
        const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });
        if (tokenAfter && (0, ast_exports.isTokenOnSameLine)(firstComment, tokenAfter)) return;
        context.report({
          loc: {
            start: firstComment.loc.start,
            end: {
              line: firstComment.loc.start.line,
              column: firstComment.loc.start.column + 2
            }
          },
          messageId: "expectedLines",
          fix(fixer) {
            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));
          }
        });
      },
      "bare-block": function(commentGroup) {
        if (isJSDocComment(commentGroup) || isExclamationComment(commentGroup)) return;
        const [firstComment] = commentGroup;
        const commentLines = getCommentLines(commentGroup);
        if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some((value) => value.includes("*/"))) context.report({
          loc: {
            start: firstComment.loc.start,
            end: commentGroup.at(-1).loc.end
          },
          messageId: "expectedBlock",
          fix(fixer) {
            return fixer.replaceTextRange([firstComment.range[0], commentGroup.at(-1).range[1]], convertToBlock(firstComment, commentLines));
          }
        });
        if (isStarredBlockComment(commentGroup)) context.report({
          loc: {
            start: firstComment.loc.start,
            end: {
              line: firstComment.loc.start.line,
              column: firstComment.loc.start.column + 2
            }
          },
          messageId: "expectedBareBlock",
          fix(fixer) {
            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));
          }
        });
      }
    };
    return { Program() {
      return sourceCode.getAllComments().filter((comment) => {
        if (isHashbangComment(comment) || COMMENTS_IGNORE_PATTERN.test(comment.value)) return false;
        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
      }).reduce((commentGroups, comment, index2, commentList) => {
        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
        if (comment.type === "Line" && index2 && commentList[index2 - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index2 - 1]) commentGroups.at(-1).push(comment);
        else commentGroups.push([comment]);
        return commentGroups;
      }, []).forEach((commentGroup) => {
        if (commentGroup.length === 1 && isSingleLine(commentGroup[0])) return;
        const check = commentGroupCheckers[style];
        check(commentGroup);
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/multiline-ternary.js
var multiline_ternary_default = createRule({
  name: "multiline-ternary",
  meta: {
    type: "layout",
    docs: { description: "Enforce newlines between operands of ternary expressions" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: [
        "always",
        "always-multiline",
        "never"
      ]
    }, {
      type: "object",
      properties: { ignoreJSX: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["always"],
    messages: {
      expectedTestCons: "Expected newline between test and consequent of ternary expression.",
      expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
      unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
      unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
    }
  },
  create(context, [style, options = {}]) {
    const multiline = style !== "never";
    const allowSingleLine = style === "always-multiline";
    const { ignoreJSX } = options;
    const sourceCode = context.sourceCode;
    return { ConditionalExpression(node) {
      const questionToken = sourceCode.getTokenAfter(node.test, ast_exports.isNotClosingParenToken);
      const colonToken = sourceCode.getTokenAfter(node.consequent, ast_exports.isNotClosingParenToken);
      const firstTokenOfTest = sourceCode.getFirstToken(node);
      const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);
      const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);
      const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);
      const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);
      const areTestAndConsequentOnSameLine = (0, ast_exports.isTokenOnSameLine)(lastTokenOfTest, firstTokenOfConsequent);
      const areConsequentAndAlternateOnSameLine = (0, ast_exports.isTokenOnSameLine)(lastTokenOfConsequent, firstTokenOfAlternate);
      const hasComments = !!sourceCode.getCommentsInside(node).length;
      if (ignoreJSX) {
        if (node.parent.type === "JSXElement" || node.parent.type === "JSXFragment" || node.parent.type === "JSXExpressionContainer") return null;
      }
      if (!multiline) {
        if (!areTestAndConsequentOnSameLine) context.report({
          node: node.test,
          loc: {
            start: firstTokenOfTest.loc.start,
            end: lastTokenOfTest.loc.end
          },
          messageId: "unexpectedTestCons",
          fix(fixer) {
            if (hasComments) return null;
            const fixers = [];
            const areTestAndQuestionOnSameLine = (0, ast_exports.isTokenOnSameLine)(lastTokenOfTest, questionToken);
            const areQuestionAndConsOnSameLine = (0, ast_exports.isTokenOnSameLine)(questionToken, firstTokenOfConsequent);
            if (!areTestAndQuestionOnSameLine) fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));
            if (!areQuestionAndConsOnSameLine) fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));
            return fixers;
          }
        });
        if (!areConsequentAndAlternateOnSameLine) context.report({
          node: node.consequent,
          loc: {
            start: firstTokenOfConsequent.loc.start,
            end: lastTokenOfConsequent.loc.end
          },
          messageId: "unexpectedConsAlt",
          fix(fixer) {
            if (hasComments) return null;
            const fixers = [];
            const areConsAndColonOnSameLine = (0, ast_exports.isTokenOnSameLine)(lastTokenOfConsequent, colonToken);
            const areColonAndAltOnSameLine = (0, ast_exports.isTokenOnSameLine)(colonToken, firstTokenOfAlternate);
            if (!areConsAndColonOnSameLine) fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));
            if (!areColonAndAltOnSameLine) fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));
            return fixers;
          }
        });
      } else {
        if (allowSingleLine && isSingleLine(node)) return;
        if (areTestAndConsequentOnSameLine) context.report({
          node: node.test,
          loc: {
            start: firstTokenOfTest.loc.start,
            end: lastTokenOfTest.loc.end
          },
          messageId: "expectedTestCons",
          fix: (fixer) => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], "\n")
        });
        if (areConsequentAndAlternateOnSameLine) context.report({
          node: node.consequent,
          loc: {
            start: firstTokenOfConsequent.loc.start,
            end: lastTokenOfConsequent.loc.end
          },
          messageId: "expectedConsAlt",
          fix: (fixer) => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], "\n")
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/new-parens.js
var new_parens_default = createRule({
  name: "new-parens",
  meta: {
    type: "layout",
    docs: { description: "Enforce or disallow parentheses when invoking a constructor with no arguments" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["always"],
    messages: {
      missing: "Missing '()' invoking a constructor.",
      unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
    }
  },
  create(context, [style]) {
    const always = style !== "never";
    const sourceCode = context.sourceCode;
    return { NewExpression(node) {
      if (node.arguments.length !== 0) return;
      const lastToken = sourceCode.getLastToken(node);
      const hasLastParen = lastToken && (0, ast_exports.isClosingParenToken)(lastToken);
      const tokenBeforeLastToken = sourceCode.getTokenBefore(lastToken);
      const hasParens = hasLastParen && (0, ast_exports.isOpeningParenToken)(tokenBeforeLastToken) && node.callee.range[1] < node.range[1];
      if (always) {
        if (!hasParens) context.report({
          node,
          messageId: "missing",
          fix: (fixer) => fixer.insertTextAfter(node, "()")
        });
      } else if (hasParens) context.report({
        node,
        messageId: "unnecessary",
        fix: (fixer) => [
          fixer.remove(tokenBeforeLastToken),
          fixer.remove(lastToken),
          fixer.insertTextBefore(node, "("),
          fixer.insertTextAfter(node, ")")
        ]
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/newline-per-chained-call.js
var newline_per_chained_call_default = createRule({
  name: "newline-per-chained-call",
  meta: {
    type: "layout",
    docs: { description: "Require a newline after each call in a method chain" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: { ignoreChainWithDepth: {
        type: "integer",
        minimum: 1,
        maximum: 10
      } },
      additionalProperties: false
    }],
    defaultOptions: [{ ignoreChainWithDepth: 2 }],
    messages: { expected: "Expected line break before `{{callee}}`." }
  },
  create(context, [options]) {
    const { ignoreChainWithDepth } = options;
    const sourceCode = context.sourceCode;
    function getPrefix(node) {
      if (node.computed) {
        if (node.optional) return "?.[";
        return "[";
      }
      if (node.optional) return "?.";
      return ".";
    }
    function getPropertyText(node) {
      const prefix = getPrefix(node);
      const lines = sourceCode.getText(node.property).split(ast_exports.LINEBREAK_MATCHER);
      const suffix = node.computed && lines.length === 1 ? "]" : "";
      return prefix + lines[0] + suffix;
    }
    return { "CallExpression:exit": function(node) {
      const callee = skipChainExpression(node.callee);
      if (callee.type !== "MemberExpression") return;
      let parent = skipChainExpression(callee.object);
      let depth = 1;
      while (parent && "callee" in parent && parent.callee) {
        depth += 1;
        const parentCallee = skipChainExpression(parent.callee);
        if (!("object" in parentCallee)) break;
        parent = skipChainExpression(parentCallee.object);
      }
      if (depth > ignoreChainWithDepth && (0, ast_exports.isTokenOnSameLine)(callee.object, callee.property)) {
        const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, ast_exports.isNotClosingParenToken);
        context.report({
          node: callee.property,
          loc: {
            start: firstTokenAfterObject.loc.start,
            end: callee.loc.end
          },
          messageId: "expected",
          data: { callee: getPropertyText(callee) },
          fix(fixer) {
            return fixer.insertTextBefore(firstTokenAfterObject, "\n");
          }
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-confusing-arrow.js
function isConditional(node) {
  return node.type === "ConditionalExpression";
}
var no_confusing_arrow_default = createRule({
  name: "no-confusing-arrow",
  meta: {
    type: "layout",
    docs: { description: "Disallow arrow functions where they could be confused with comparisons" },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        allowParens: { type: "boolean" },
        onlyOneSimpleParam: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      allowParens: true,
      onlyOneSimpleParam: false
    }],
    messages: { confusing: "Arrow function used ambiguously with a conditional expression." }
  },
  create(context, [options]) {
    const { allowParens, onlyOneSimpleParam } = options;
    const sourceCode = context.sourceCode;
    function checkArrowFunc(node) {
      const body = node.body;
      if (isConditional(body) && !(allowParens && isParenthesised(sourceCode, body)) && !(onlyOneSimpleParam && !(node.params.length === 1 && node.params[0].type === "Identifier"))) context.report({
        node,
        messageId: "confusing",
        fix(fixer) {
          return allowParens ? fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`) : null;
        }
      });
    }
    return { ArrowFunctionExpression: checkArrowFunc };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-extra-parens.js
var isTypeAssertion = (0, ast_exports.isNodeOfTypes)([
  import_types.AST_NODE_TYPES.TSAsExpression,
  import_types.AST_NODE_TYPES.TSNonNullExpression,
  import_types.AST_NODE_TYPES.TSSatisfiesExpression,
  import_types.AST_NODE_TYPES.TSTypeAssertion
]);
var no_extra_parens_default = createRule({
  name: "no-extra-parens",
  meta: {
    type: "layout",
    docs: { description: "Disallow unnecessary parentheses" },
    fixable: "code",
    schema: { anyOf: [{
      type: "array",
      items: [{
        type: "string",
        enum: ["functions"]
      }],
      minItems: 0,
      maxItems: 1
    }, {
      type: "array",
      items: [{
        type: "string",
        enum: ["all"]
      }, {
        type: "object",
        properties: {
          conditionalAssign: { type: "boolean" },
          ternaryOperandBinaryExpressions: { type: "boolean" },
          nestedBinaryExpressions: { type: "boolean" },
          returnAssign: { type: "boolean" },
          ignoreJSX: {
            type: "string",
            enum: [
              "none",
              "all",
              "single-line",
              "multi-line"
            ]
          },
          enforceForArrowConditionals: { type: "boolean" },
          enforceForSequenceExpressions: { type: "boolean" },
          enforceForNewInMemberExpressions: { type: "boolean" },
          enforceForFunctionPrototypeMethods: { type: "boolean" },
          allowParensAfterCommentPattern: { type: "string" },
          nestedConditionalExpressions: { type: "boolean" },
          allowNodesInSpreadElement: {
            type: "object",
            properties: {
              ConditionalExpression: { type: "boolean" },
              LogicalExpression: { type: "boolean" },
              AwaitExpression: { type: "boolean" }
            },
            additionalProperties: false
          },
          ignoredNodes: {
            type: "array",
            items: {
              type: "string",
              not: {
                type: "string",
                pattern: ":exit$"
              }
            }
          }
        },
        additionalProperties: false
      }],
      minItems: 0,
      maxItems: 2
    }] },
    defaultOptions: ["all"],
    messages: { unexpected: "Unnecessary parentheses around expression." }
  },
  create(context, [nodes, options]) {
    const sourceCode = context.sourceCode;
    const tokensToIgnore = /* @__PURE__ */ new WeakSet();
    const precedence = getPrecedence;
    const ALL_NODES = nodes !== "functions";
    const EXCEPT_COND_ASSIGN = ALL_NODES && options?.conditionalAssign === false;
    const EXCEPT_COND_TERNARY = ALL_NODES && options?.ternaryOperandBinaryExpressions === false;
    const IGNORE_NESTED_BINARY = ALL_NODES && options?.nestedBinaryExpressions === false;
    const EXCEPT_RETURN_ASSIGN = ALL_NODES && options?.returnAssign === false;
    const IGNORE_JSX = ALL_NODES && options?.ignoreJSX;
    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && options?.enforceForArrowConditionals === false;
    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && options?.enforceForSequenceExpressions === false;
    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && options?.enforceForNewInMemberExpressions === false;
    const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && options?.enforceForFunctionPrototypeMethods === false;
    const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && options?.allowParensAfterCommentPattern;
    const ALLOW_NESTED_TERNARY = ALL_NODES && options?.nestedConditionalExpressions === false;
    const ALLOW_NODES_IN_SPREAD = ALL_NODES && options && new Set(Object.entries(options.allowNodesInSpreadElement || {}).filter(([_, value]) => value).map(([key]) => key));
    warnDeprecatedOptions(options, [
      "enforceForArrowConditionals",
      "enforceForNewInMemberExpressions",
      "allowNodesInSpreadElement"
    ], "ignoredNodes", "no-extra-parens");
    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: "AssignmentExpression" });
    const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: "UpdateExpression" });
    let reportsBuffer;
    function pathToAncestor(node, ancestor) {
      const path = [node];
      let currentNode = node;
      while (currentNode !== ancestor) {
        currentNode = currentNode.parent;
        if (currentNode === null || currentNode === void 0) throw new Error("Nodes are not in the ancestor-descendant relationship.");
        path.push(currentNode);
      }
      return path;
    }
    function pathToDescendant(node, descendant) {
      return pathToAncestor(descendant, node).reverse();
    }
    function isSafelyEnclosingInExpression(node, child) {
      switch (node.type) {
        case "ArrayExpression":
        case "ArrayPattern":
        case "BlockStatement":
        case "ObjectExpression":
        case "ObjectPattern":
        case "TemplateLiteral":
          return true;
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return node.params.includes(child);
        case "CallExpression":
        case "NewExpression":
          return node.arguments.includes(child);
        case "MemberExpression":
          return node.computed && node.property === child;
        case "ConditionalExpression":
          return node.consequent === child;
        default:
          return false;
      }
    }
    function startNewReportsBuffering() {
      reportsBuffer = {
        upper: reportsBuffer,
        inExpressionNodes: [],
        reports: []
      };
    }
    function endCurrentReportsBuffering() {
      const { upper, inExpressionNodes, reports } = reportsBuffer ?? {};
      if (upper) {
        upper.inExpressionNodes.push(...inExpressionNodes ?? []);
        upper.reports.push(...reports ?? []);
      } else reports?.forEach(({ finishReport }) => finishReport());
      reportsBuffer = upper;
    }
    function isInCurrentReportsBuffer(node) {
      return reportsBuffer?.reports.some((r) => r.node === node);
    }
    function removeFromCurrentReportsBuffer(node) {
      if (reportsBuffer) reportsBuffer.reports = reportsBuffer.reports.filter((r) => r.node !== node);
    }
    function isImmediateFunctionPrototypeMethodCall(node) {
      const callNode = skipChainExpression(node);
      if (callNode.type !== "CallExpression") return false;
      const callee = skipChainExpression(callNode.callee);
      return callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && ["call", "apply"].includes(getStaticPropertyName(callee));
    }
    function ruleApplies(node) {
      if (node.type === "JSXElement" || node.type === "JSXFragment") switch (IGNORE_JSX) {
        case "all":
          return false;
        case "multi-line":
          return isSingleLine(node);
        case "single-line":
          return !isSingleLine(node);
        case "none":
          break;
      }
      if (node.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) return false;
      if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) return false;
      return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }
    function isParenthesised2(node) {
      return (0, ast_exports.isParenthesized)(1, node, sourceCode);
    }
    function isParenthesisedTwice(node) {
      return (0, ast_exports.isParenthesized)(2, node, sourceCode);
    }
    function hasExcessParens(node) {
      return ruleApplies(node) && isParenthesised2(node);
    }
    function hasDoubleExcessParens(node) {
      return ruleApplies(node) && isParenthesisedTwice(node);
    }
    function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {
      if (ruleApplies(node) && isParenthesised2(node)) {
        if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) return true;
      }
      return false;
    }
    function isCondAssignException(node) {
      return EXCEPT_COND_ASSIGN && node.test && node.test.type === "AssignmentExpression";
    }
    function isInReturnStatement(node) {
      for (let currentNode = node; currentNode; currentNode = currentNode.parent) if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") return true;
      return false;
    }
    function isNewExpressionWithParens(newExpression) {
      const lastToken = sourceCode.getLastToken(newExpression);
      const penultimateToken = sourceCode.getTokenBefore(lastToken);
      return newExpression.arguments.length > 0 || (0, ast_exports.isOpeningParenToken)(penultimateToken) && (0, ast_exports.isClosingParenToken)(lastToken) && newExpression.callee.range[1] < newExpression.range[1];
    }
    function isMemberExpInNewCallee(node) {
      if (node.type === "MemberExpression") return node.parent.type === "NewExpression" && node.parent.callee === node ? true : "object" in node.parent && node.parent.object === node && isMemberExpInNewCallee(node.parent);
      return false;
    }
    function doesMemberExpressionContainCallExpression(node) {
      let currentNode = node.object;
      let currentNodeType = node.object.type;
      while (currentNodeType === "MemberExpression") {
        if (!("object" in currentNode)) break;
        currentNode = currentNode.object;
        currentNodeType = currentNode.type;
      }
      return currentNodeType === "CallExpression";
    }
    function containsAssignment(node) {
      if (node.type === "AssignmentExpression") return true;
      if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) return true;
      if ("left" in node && (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression")) return true;
      return false;
    }
    function isReturnAssignException(node) {
      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) return false;
      if (node.type === "ReturnStatement") return node.argument && containsAssignment(node.argument);
      if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") return containsAssignment(node.body);
      return containsAssignment(node);
    }
    function hasExcessParensNoLineTerminator(token, node) {
      if ((0, ast_exports.isTokenOnSameLine)(token, node)) return hasExcessParens(node);
      return hasDoubleExcessParens(node);
    }
    function requiresLeadingSpace(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });
      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);
    }
    function requiresTrailingSpace(node) {
      const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
      const rightParenToken = nextTwoTokens[0];
      const tokenAfterRightParen = nextTwoTokens[1];
      const tokenBeforeRightParen = sourceCode.getLastToken(node);
      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetween(rightParenToken, tokenAfterRightParen) && !canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
    }
    function isIIFE(node) {
      const maybeCallNode = skipChainExpression(node);
      return maybeCallNode.type === "CallExpression" && maybeCallNode.callee.type === "FunctionExpression";
    }
    function canBeAssignmentTarget(node) {
      return !!(node && (node.type === "Identifier" || node.type === "MemberExpression"));
    }
    function isAnonymousFunctionAssignmentException({ left, operator, right }) {
      if (left.type === "Identifier" && [
        "=",
        "&&=",
        "||=",
        "??="
      ].includes(operator)) {
        const rhsType = right.type;
        if (rhsType === "ArrowFunctionExpression") return true;
        if ((rhsType === "FunctionExpression" || rhsType === "ClassExpression") && !right.id) return true;
      }
      return false;
    }
    function isFixable(node) {
      if (node.type !== "Literal" || typeof node.value !== "string") return true;
      if (isParenthesisedTwice(node)) return true;
      return !isTopLevelExpressionStatement(node.parent);
    }
    function report(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const rightParenToken = sourceCode.getTokenAfter(node);
      if (!isParenthesisedTwice(node)) {
        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) return;
        if (isIIFE(node) && !("callee" in node && isParenthesised2(node.callee))) return;
        if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {
          const commentsBeforeLeftParenToken = sourceCode.getCommentsBefore(leftParenToken);
          const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;
          const ignorePattern = new RegExp(ALLOW_PARENS_AFTER_COMMENT_PATTERN, "u");
          if (totalCommentsBeforeLeftParenTokenCount > 0 && ignorePattern.test(commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value)) return;
        }
      }
      function finishReport() {
        context.report({
          node,
          loc: leftParenToken.loc,
          messageId: "unexpected",
          fix: isFixable(node) ? (fixer) => {
            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
          } : null
        });
      }
      if (reportsBuffer) {
        reportsBuffer.reports.push({
          node,
          finishReport
        });
        return;
      }
      finishReport();
    }
    function checkArgumentWithPrecedence(node) {
      if ("argument" in node && node.argument && hasExcessParensWithPrecedence(node.argument, precedence(node))) report(node.argument);
    }
    function checkBinaryLogical(node) {
      const isLeftTypeAssertion = isTypeAssertion(node.left);
      const isRightTypeAssertion = isTypeAssertion(node.right);
      if (isLeftTypeAssertion && isRightTypeAssertion) return;
      const rule = (n) => {
        const prec = precedence(n);
        const leftPrecedence = precedence(n.left);
        const rightPrecedence = precedence(n.right);
        const isExponentiation = n.operator === "**";
        const shouldSkipLeft = IGNORE_NESTED_BINARY && (n.left.type === "BinaryExpression" || n.left.type === "LogicalExpression");
        const shouldSkipRight = IGNORE_NESTED_BINARY && (n.right.type === "BinaryExpression" || n.right.type === "LogicalExpression");
        if (!shouldSkipLeft && hasExcessParens(n.left)) {
          if (!(["AwaitExpression", "UnaryExpression"].includes(n.left.type) && isExponentiation) && !isMixedLogicalAndCoalesceExpressions(n.left, n) && !(n.parent.type === "ReturnStatement" && n.parent.loc.start.line !== n.left.loc.start.line && !isParenthesised2(n)) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(n.left)) report(n.left);
        }
        if (!shouldSkipRight && hasExcessParens(n.right)) {
          if (!isMixedLogicalAndCoalesceExpressions(n.right, n) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(n.right)) report(n.right);
        }
      };
      if (isLeftTypeAssertion) return rule({
        ...node,
        left: {
          ...node.left,
          type: import_types.AST_NODE_TYPES.SequenceExpression
        }
      });
      if (isRightTypeAssertion) return rule({
        ...node,
        right: {
          ...node.right,
          type: import_types.AST_NODE_TYPES.SequenceExpression
        }
      });
      return rule(node);
    }
    function checkCallNew(node) {
      const rule = (node2) => {
        const callee = node2.callee;
        if (hasExcessParensWithPrecedence(callee, precedence(node2))) {
          if (hasDoubleExcessParens(callee) || !(isIIFE(node2) || callee.type === "NewExpression" && !isNewExpressionWithParens(callee) && !(node2.type === "NewExpression" && !isNewExpressionWithParens(node2)) || node2.type === "NewExpression" && callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee) || (!("optional" in node2) || !node2.optional) && callee.type === "ChainExpression")) report(node2.callee);
        }
        node2.arguments.forEach((arg) => {
          if (hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(arg);
        });
      };
      if (isTypeAssertion(node.callee)) return rule({
        ...node,
        callee: {
          ...node.callee,
          type: import_types.AST_NODE_TYPES.SequenceExpression
        }
      });
      return rule(node);
    }
    function checkClass(node) {
      if (!node.superClass) return;
      if (precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass)) report(node.superClass);
    }
    function checkExpressionOrExportStatement(node) {
      const firstToken = isParenthesised2(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
      const secondToken = sourceCode.getTokenAfter(firstToken, ast_exports.isNotOpeningParenToken);
      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, ast_exports.isNotClosingParenToken) : null;
      if ((0, ast_exports.isOpeningParenToken)(firstToken) && ((0, ast_exports.isOpeningBraceToken)(secondToken) || isKeywordToken(secondToken) && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && ((0, ast_exports.isOpeningBracketToken)(tokenAfterClosingParens) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && isKeywordToken(thirdToken) && thirdToken.value === "function")) tokensToIgnore.add(secondToken);
      if (node.parent.type === "ExportDefaultDeclaration" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node)) report(node);
    }
    function checkUnaryUpdate(node) {
      if (isTypeAssertion(node.argument)) return checkArgumentWithPrecedence({
        ...node,
        argument: {
          ...node.argument,
          type: import_types.AST_NODE_TYPES.SequenceExpression
        }
      });
      return checkArgumentWithPrecedence(node);
    }
    function checkClassProperty(node) {
      if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node.key);
      if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node.value);
    }
    function checkTSBinaryType(node) {
      node.types.forEach((type) => {
        if (IGNORE_NESTED_BINARY && (0, ast_exports.isNodeOfTypes)([import_types.AST_NODE_TYPES.TSUnionType, import_types.AST_NODE_TYPES.TSIntersectionType])(type) ? isParenthesisedTwice(type) : hasExcessParensWithPrecedence(type, precedence(node))) report(type);
      });
    }
    const baseListeners = {
      ArrayExpression(node) {
        node.elements.map((element) => isTypeAssertion(element) ? {
          ...element,
          type: import_types.AST_NODE_TYPES.FunctionExpression
        } : element).forEach((ele) => {
          if (!!ele && hasExcessParensWithPrecedence(ele, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(ele);
        });
      },
      ArrayPattern(node) {
        node.elements.forEach((ele) => {
          if (!!ele && canBeAssignmentTarget(ele) && hasExcessParens(ele)) report(ele);
        });
      },
      ArrowFunctionExpression(node) {
        if (isTypeAssertion(node.body)) return;
        if (isReturnAssignException(node)) return;
        if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS) return;
        if (node.body.type === "BlockStatement") return;
        const firstBodyToken = sourceCode.getFirstToken(node.body, ast_exports.isNotOpeningParenToken);
        if ((0, ast_exports.isOpeningParenToken)(sourceCode.getTokenBefore(firstBodyToken)) && (0, ast_exports.isOpeningBraceToken)(firstBodyToken)) tokensToIgnore.add(firstBodyToken);
        if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node.body);
      },
      AssignmentExpression(node) {
        if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left) && (!isAnonymousFunctionAssignmentException(node) || isParenthesisedTwice(node.left))) report(node.left);
        if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) report(node.right);
      },
      AssignmentPattern(node) {
        const { left, right } = node;
        if (canBeAssignmentTarget(left) && hasExcessParens(left)) report(left);
        if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(right);
      },
      AwaitExpression(node) {
        if (isTypeAssertion(node.argument)) return checkArgumentWithPrecedence({
          ...node,
          argument: {
            ...node.argument,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        return checkArgumentWithPrecedence(node);
      },
      BinaryExpression(node) {
        if (reportsBuffer && node.operator === "in") reportsBuffer.inExpressionNodes.push(node);
        checkBinaryLogical(node);
      },
      "CallExpression": checkCallNew,
      ClassDeclaration(node) {
        if (node.superClass?.type === import_types.AST_NODE_TYPES.TSAsExpression) return checkClass({
          ...node,
          superClass: {
            ...node.superClass,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        return checkClass(node);
      },
      ClassExpression(node) {
        if (node.superClass?.type === import_types.AST_NODE_TYPES.TSAsExpression) return checkClass({
          ...node,
          superClass: {
            ...node.superClass,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        return checkClass(node);
      },
      ConditionalExpression(node) {
        const rule = (node2) => {
          if (isReturnAssignException(node2)) return;
          const availableTypes = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression"]);
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.test.type)) && !(ALLOW_NESTED_TERNARY && ["ConditionalExpression"].includes(node2.test.type)) && !isCondAssignException(node2) && hasExcessParensWithPrecedence(node2.test, precedence({
            type: "LogicalExpression",
            operator: "||"
          }))) report(node2.test);
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.consequent.type)) && !(ALLOW_NESTED_TERNARY && ["ConditionalExpression"].includes(node2.consequent.type)) && hasExcessParensWithPrecedence(node2.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node2.consequent);
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.alternate.type)) && !(ALLOW_NESTED_TERNARY && ["ConditionalExpression"].includes(node2.alternate.type)) && hasExcessParensWithPrecedence(node2.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node2.alternate);
        };
        if (isTypeAssertion(node.test)) return rule({
          ...node,
          test: {
            ...node.test,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        if (isTypeAssertion(node.consequent)) return rule({
          ...node,
          consequent: {
            ...node.consequent,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        if (isTypeAssertion(node.alternate)) return rule({
          ...node,
          alternate: {
            ...node.alternate,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        return rule(node);
      },
      DoWhileStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) report(node.test);
      },
      ExportDefaultDeclaration(node) {
        checkExpressionOrExportStatement(node.declaration);
      },
      ExpressionStatement(node) {
        checkExpressionOrExportStatement(node.expression);
      },
      ForInStatement(node) {
        if (isTypeAssertion(node.right)) return;
        if (node.left.type !== "VariableDeclaration") {
          const firstLeftToken = sourceCode.getFirstToken(node.left, ast_exports.isNotOpeningParenToken);
          if (firstLeftToken.value === "let" && (0, ast_exports.isOpeningBracketToken)(sourceCode.getTokenAfter(firstLeftToken, ast_exports.isNotClosingParenToken))) tokensToIgnore.add(firstLeftToken);
        }
        if (hasExcessParens(node.left)) report(node.left);
        if (hasExcessParens(node.right)) report(node.right);
      },
      ForOfStatement(node) {
        if (node.left.type !== "VariableDeclaration") {
          const firstLeftToken = sourceCode.getFirstToken(node.left, ast_exports.isNotOpeningParenToken);
          if (firstLeftToken.value === "let") tokensToIgnore.add(firstLeftToken);
        }
        if (hasExcessParens(node.left)) report(node.left);
        if (!isTypeAssertion(node.right) && hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node.right);
      },
      ForStatement(node) {
        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node) && !isTypeAssertion(node.test)) report(node.test);
        if (node.update && hasExcessParens(node.update) && !isTypeAssertion(node.update)) report(node.update);
        if (node.init && !isTypeAssertion(node.init)) {
          if (node.init.type !== "VariableDeclaration") {
            const firstToken = sourceCode.getFirstToken(node.init, ast_exports.isNotOpeningParenToken);
            if (firstToken.value === "let" && (0, ast_exports.isOpeningBracketToken)(sourceCode.getTokenAfter(firstToken, ast_exports.isNotClosingParenToken))) tokensToIgnore.add(firstToken);
          }
          startNewReportsBuffering();
          if (hasExcessParens(node.init)) report(node.init);
        }
      },
      "ForStatement > *.init:exit": function(node) {
        if (isTypeAssertion(node)) return;
        if (reportsBuffer?.reports.length) reportsBuffer.inExpressionNodes.forEach((inExpressionNode) => {
          const path = pathToDescendant(node, inExpressionNode);
          let nodeToExclude = null;
          for (let i = 0; i < path.length; i++) {
            const pathNode = path[i];
            if (i < path.length - 1) {
              const nextPathNode = path[i + 1];
              if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) return;
            }
            if (isParenthesised2(pathNode)) if (isInCurrentReportsBuffer(pathNode)) {
              if (isParenthesisedTwice(pathNode)) return;
              if (!nodeToExclude) nodeToExclude = pathNode;
            } else return;
          }
          if (nodeToExclude) removeFromCurrentReportsBuffer(nodeToExclude);
        });
        endCurrentReportsBuffering();
      },
      IfStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) report(node.test);
      },
      ImportExpression(node) {
        const { source } = node;
        if (source.type === "SequenceExpression") {
          if (hasDoubleExcessParens(source)) report(source);
        } else if (hasExcessParens(source)) report(source);
      },
      "LogicalExpression": checkBinaryLogical,
      MemberExpression(node) {
        const rule = (node2) => {
          const nodeObjHasExcessParens = isMemberExpInNewCallee(node2) && doesMemberExpressionContainCallExpression(node2) ? hasDoubleExcessParens(node2.object) : hasExcessParens(node2.object) && !(isImmediateFunctionPrototypeMethodCall(node2.parent) && "callee" in node2.parent && node2.parent.callee === node2 && IGNORE_FUNCTION_PROTOTYPE_METHODS);
          if (nodeObjHasExcessParens && precedence(node2.object) >= precedence(node2) && (node2.computed || !(isDecimalInteger(node2.object) || isRegExpLiteral(node2.object)))) report(node2.object);
          if (nodeObjHasExcessParens && node2.object.type === "CallExpression") report(node2.object);
          if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node2.object.type === "NewExpression" && isNewExpressionWithParens(node2.object)) report(node2.object);
          if (nodeObjHasExcessParens && node2.optional && node2.object.type === "ChainExpression") report(node2.object);
          if (node2.computed && hasExcessParens(node2.property)) report(node2.property);
        };
        if (isTypeAssertion(node.object)) return rule({
          ...node,
          object: {
            ...node.object,
            type: import_types.AST_NODE_TYPES.SequenceExpression
          }
        });
        if (isTypeAssertion(node.property)) return rule({
          ...node,
          property: {
            ...node.property,
            type: import_types.AST_NODE_TYPES.FunctionExpression
          }
        });
        return rule(node);
      },
      MethodDefinition(node) {
        if (!node.computed) return;
        if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(node.key);
      },
      "NewExpression": checkCallNew,
      ObjectExpression(node) {
        node.properties.forEach((property) => {
          if (property.type === "Property" && property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(property.value);
        });
      },
      ObjectPattern(node) {
        node.properties.forEach(({ value }) => {
          if (value && canBeAssignmentTarget(value) && hasExcessParens(value)) report(value);
        });
      },
      Property(node) {
        if (node.computed) {
          const { key } = node;
          if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) report(key);
        }
      },
      "PropertyDefinition": checkClassProperty,
      "AccessorProperty": checkClassProperty,
      RestElement(node) {
        const argument = node.argument;
        if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) report(argument);
      },
      ReturnStatement(node) {
        const returnToken = sourceCode.getFirstToken(node);
        if (isReturnAssignException(node)) return;
        if (node.argument && returnToken && hasExcessParensNoLineTerminator(returnToken, node.argument) && !isRegExpLiteral(node.argument)) report(node.argument);
      },
      SequenceExpression(node) {
        const precedenceOfNode = precedence(node);
        node.expressions.forEach((expression) => {
          if (hasExcessParensWithPrecedence(expression, precedenceOfNode)) report(expression);
        });
      },
      SpreadElement(node) {
        if (isTypeAssertion(node.argument)) return;
        if (ALLOW_NODES_IN_SPREAD && ALLOW_NODES_IN_SPREAD.has(node.argument.type)) return;
        if (!hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) return;
        report(node.argument);
      },
      SwitchCase(node) {
        if (node.test && !isTypeAssertion(node.test) && hasExcessParens(node.test)) report(node.test);
      },
      SwitchStatement(node) {
        if (hasExcessParens(node.discriminant)) report(node.discriminant);
      },
      TemplateLiteral(node) {
        node.expressions.forEach((expression) => {
          if (hasExcessParens(expression)) report(expression);
        });
      },
      ThrowStatement(node) {
        if (!node.argument || isTypeAssertion(node.argument)) return;
        const throwToken = sourceCode.getFirstToken(node);
        if (!throwToken) return;
        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) report(node.argument);
      },
      "UnaryExpression": checkUnaryUpdate,
      UpdateExpression(node) {
        if (isTypeAssertion(node.argument)) return checkUnaryUpdate(node);
        if (node.prefix) checkArgumentWithPrecedence(node);
        else {
          const { argument } = node;
          if ((0, ast_exports.isTokenOnSameLine)(argument, sourceCode.getLastToken(node))) checkArgumentWithPrecedence(node);
          else if (hasDoubleExcessParens(argument)) report(argument);
        }
      },
      VariableDeclarator(node) {
        const rule = (node2) => {
          if (node2.init && hasExcessParensWithPrecedence(node2.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && !isRegExpLiteral(node2.init)) report(node2.init);
        };
        if (isTypeAssertion(node.init)) return rule({
          ...node,
          type: import_types.AST_NODE_TYPES.VariableDeclarator,
          init: {
            ...node.init,
            type: import_types.AST_NODE_TYPES.FunctionExpression
          }
        });
        return rule(node);
      },
      WhileStatement(node) {
        if (hasExcessParens(node.test) && !isCondAssignException(node)) report(node.test);
      },
      WithStatement(node) {
        if (hasExcessParens(node.object)) report(node.object);
      },
      YieldExpression(node) {
        if (!node.argument || isTypeAssertion(node.argument)) return;
        const yieldToken = sourceCode.getFirstToken(node);
        if (precedence(node.argument) >= precedence(node) && yieldToken && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) report(node.argument);
      },
      TSArrayType(node) {
        if (hasExcessParensWithPrecedence(node.elementType, precedence(node))) report(node.elementType);
      },
      "TSIntersectionType": checkTSBinaryType,
      "TSUnionType": checkTSBinaryType,
      TSTypeAnnotation(node) {
        if (hasExcessParens(node.typeAnnotation)) report(node.typeAnnotation);
      },
      TSTypeAliasDeclaration(node) {
        if (hasExcessParens(node.typeAnnotation)) report(node.typeAnnotation);
      },
      TSEnumMember(node) {
        if (!node.initializer) return;
        if (hasExcessParens(node.initializer)) report(node.initializer);
      }
    };
    const listeners = {};
    const ignoreNodes = /* @__PURE__ */ new Set();
    const listenerCallQueue = [];
    for (const key in baseListeners) listeners[key] = (node) => listenerCallQueue.push({
      node,
      listener: baseListeners[key]
    });
    return {
      ...listeners,
      ...options?.ignoredNodes?.reduce((listener, selector) => Object.assign(listener, { [selector]: (node) => ignoreNodes.add(node) }), {}),
      "Program:exit": function() {
        for (let i = 0; i < listenerCallQueue.length; i++) {
          const { node, listener } = listenerCallQueue[i];
          if (!ignoreNodes.has(node)) listener(node);
        }
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-extra-semi.js
var no_extra_semi_default = createRule({
  name: "no-extra-semi",
  meta: {
    type: "layout",
    docs: { description: "Disallow unnecessary semicolons" },
    fixable: "code",
    schema: [],
    messages: { unexpected: "Unnecessary semicolon." }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function isFixable(nodeOrToken) {
      const nextToken = sourceCode.getTokenAfter(nodeOrToken);
      if (!nextToken || nextToken.type !== "String") return true;
      return !isTopLevelExpressionStatement(sourceCode.getNodeByRangeIndex(nextToken.range[0]).parent);
    }
    function report(nodeOrToken) {
      context.report({
        node: nodeOrToken,
        messageId: "unexpected",
        fix: isFixable(nodeOrToken) ? (fixer) => new FixTracker(fixer, context.sourceCode).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken) : null
      });
    }
    function checkForPartOfClassBody(firstToken) {
      for (let token = firstToken; token.type === "Punctuator" && !(0, ast_exports.isClosingBraceToken)(token); token = sourceCode.getTokenAfter(token)) if ((0, ast_exports.isSemicolonToken)(token)) report(token);
    }
    return {
      EmptyStatement(node) {
        const parent = node.parent;
        if (![
          "ForStatement",
          "ForInStatement",
          "ForOfStatement",
          "WhileStatement",
          "DoWhileStatement",
          "IfStatement",
          "LabeledStatement",
          "WithStatement"
        ].includes(parent.type)) report(node);
      },
      ClassBody(node) {
        checkForPartOfClassBody(sourceCode.getFirstToken(node, 1));
      },
      MethodDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      },
      PropertyDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      },
      AccessorProperty(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      },
      StaticBlock(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      },
      TSAbstractMethodDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      },
      TSAbstractPropertyDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-floating-decimal.js
var no_floating_decimal_default = createRule({
  name: "no-floating-decimal",
  meta: {
    type: "layout",
    docs: { description: "Disallow leading or trailing decimal points in numeric literals" },
    fixable: "code",
    schema: [],
    messages: {
      leading: "A leading decimal point can be confused with a dot.",
      trailing: "A trailing decimal point can be confused with a dot."
    }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    return { Literal(node) {
      if (typeof node.value === "number") {
        if (node.raw.startsWith(".")) context.report({
          node,
          messageId: "leading",
          fix(fixer) {
            const tokenBefore = sourceCode.getTokenBefore(node);
            const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
            return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
          }
        });
        if (node.raw.indexOf(".") === node.raw.length - 1) context.report({
          node,
          messageId: "trailing",
          fix: (fixer) => fixer.insertTextAfter(node, "0")
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-mixed-operators.js
var ARITHMETIC_OPERATORS = [
  "+",
  "-",
  "*",
  "/",
  "%",
  "**"
];
var BITWISE_OPERATORS = [
  "&",
  "|",
  "^",
  "~",
  "<<",
  ">>",
  ">>>"
];
var COMPARISON_OPERATORS = [
  "==",
  "!=",
  "===",
  "!==",
  ">",
  ">=",
  "<",
  "<="
];
var LOGICAL_OPERATORS = ["&&", "||"];
var RELATIONAL_OPERATORS = ["in", "instanceof"];
var ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, ["?:"], ["??"]);
var DEFAULT_GROUPS = [
  ARITHMETIC_OPERATORS,
  BITWISE_OPERATORS,
  COMPARISON_OPERATORS,
  LOGICAL_OPERATORS,
  RELATIONAL_OPERATORS
];
var TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;
function includesBothInAGroup(groups, left, right) {
  return groups.some((group) => group.includes(left) && group.includes(right));
}
function getChildNode(node) {
  return node.type === "ConditionalExpression" ? node.test : node.left;
}
var no_mixed_operators_default = createRule({
  name: "no-mixed-operators",
  meta: {
    type: "layout",
    docs: { description: "Disallow mixed binary operators" },
    schema: [{
      type: "object",
      properties: {
        groups: {
          type: "array",
          items: {
            type: "array",
            items: {
              type: "string",
              enum: ALL_OPERATORS
            },
            minItems: 2,
            uniqueItems: true
          },
          uniqueItems: true
        },
        allowSamePrecedence: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      groups: DEFAULT_GROUPS,
      allowSamePrecedence: true
    }],
    messages: { unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations." }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const { groups, allowSamePrecedence } = options;
    function shouldIgnore(node) {
      const a = node;
      const b = node.parent;
      return !includesBothInAGroup(groups, a.operator, b.type === "ConditionalExpression" ? "?:" : b.operator) || allowSamePrecedence && getPrecedence(a) === getPrecedence(b);
    }
    function isMixedWithParent(node) {
      return node.operator !== node.parent.operator && !isParenthesised(sourceCode, node);
    }
    function getOperatorToken(node) {
      return sourceCode.getTokenAfter(getChildNode(node), ast_exports.isNotClosingParenToken);
    }
    function reportBothOperators(node) {
      const parent = node.parent;
      const left = getChildNode(parent) === node ? node : parent;
      const right = getChildNode(parent) !== node ? node : parent;
      const data2 = {
        leftOperator: left.operator || "?:",
        rightOperator: right.operator || "?:"
      };
      context.report({
        node: left,
        loc: getOperatorToken(left).loc,
        messageId: "unexpectedMixedOperator",
        data: data2
      });
      context.report({
        node: right,
        loc: getOperatorToken(right).loc,
        messageId: "unexpectedMixedOperator",
        data: data2
      });
    }
    function check(node) {
      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) reportBothOperators(node);
    }
    return {
      BinaryExpression: check,
      LogicalExpression: check
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-mixed-spaces-and-tabs.js
var no_mixed_spaces_and_tabs_default = createRule({
  name: "no-mixed-spaces-and-tabs",
  meta: {
    type: "layout",
    docs: { description: "Disallow mixed spaces and tabs for indentation" },
    schema: [{ oneOf: [{
      type: "string",
      enum: ["smart-tabs"]
    }, { type: "boolean" }] }],
    defaultOptions: [false],
    messages: { mixedSpacesAndTabs: "Mixed spaces and tabs." }
  },
  create(context, [style]) {
    const sourceCode = context.sourceCode;
    const smartTabs = typeof style === "boolean" ? style : style === "smart-tabs";
    return { "Program:exit": function(node) {
      const lines = sourceCode.lines;
      const comments = sourceCode.getAllComments();
      const ignoredCommentLines = /* @__PURE__ */ new Set();
      comments.forEach((comment) => {
        for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) ignoredCommentLines.add(i);
      });
      let regex = /^(?=( +|\t+))\1(?:\t| )/u;
      if (smartTabs) regex = /^(?=(\t*))\1(?=( +))\2\t/u;
      lines.forEach((line, i) => {
        const match = regex.exec(line);
        if (match) {
          const lineNumber = i + 1;
          const loc = {
            start: {
              line: lineNumber,
              column: match[0].length - 2
            },
            end: {
              line: lineNumber,
              column: match[0].length
            }
          };
          if (!ignoredCommentLines.has(lineNumber)) {
            const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));
            if (!(containingNode && ["Literal", "TemplateElement"].includes(containingNode.type))) context.report({
              node,
              loc,
              messageId: "mixedSpacesAndTabs"
            });
          }
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-multi-spaces.js
var no_multi_spaces_default = createRule({
  name: "no-multi-spaces",
  meta: {
    type: "layout",
    docs: { description: "Disallow multiple spaces" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          patternProperties: { "^([A-Z][a-z]*)+$": { type: "boolean" } },
          additionalProperties: false
        },
        ignoreEOLComments: { type: "boolean" },
        includeTabs: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      exceptions: {
        Property: true,
        ImportAttribute: true
      },
      ignoreEOLComments: false,
      includeTabs: true
    }],
    messages: { multipleSpaces: "Multiple spaces found before '{{displayValue}}'." }
  },
  create(context, [options]) {
    const { ignoreEOLComments, exceptions, includeTabs } = options;
    const sourceCode = context.sourceCode;
    const hasExceptions = Object.keys(exceptions).some((key) => exceptions[key]);
    const spacesRe = includeTabs ? /[ \t]{2}/ : / {2}/;
    function formatReportedCommentValue(token) {
      const valueLines = token.value.split("\n");
      const value = valueLines[0];
      const formattedValue = `${value.slice(0, 12)}...`;
      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
    }
    return { Program() {
      sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
        if (leftIndex === tokensAndComments.length - 1) return;
        const rightToken = tokensAndComments[leftIndex + 1];
        if (!spacesRe.test(sourceCode.text.slice(leftToken.range[1], rightToken.range[0])) || leftToken.loc.end.line < rightToken.loc.start.line) return;
        if (ignoreEOLComments && (0, ast_exports.isCommentToken)(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) return;
        if (hasExceptions) {
          const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);
          if (parentNode && exceptions[parentNode.type]) return;
        }
        let displayValue;
        if (rightToken.type === "Block") displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
        else if (rightToken.type === "Line") displayValue = `//${formatReportedCommentValue(rightToken)}`;
        else displayValue = rightToken.value;
        context.report({
          node: rightToken,
          loc: {
            start: leftToken.loc.end,
            end: rightToken.loc.start
          },
          messageId: "multipleSpaces",
          data: { displayValue },
          fix: (fixer) => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
        });
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-multiple-empty-lines.js
var no_multiple_empty_lines_default = createRule({
  name: "no-multiple-empty-lines",
  meta: {
    type: "layout",
    docs: { description: "Disallow multiple empty lines" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 0
        },
        maxEOF: {
          type: "integer",
          minimum: 0
        },
        maxBOF: {
          type: "integer",
          minimum: 0
        }
      },
      required: ["max"],
      additionalProperties: false
    }],
    defaultOptions: [{ max: 2 }],
    messages: {
      blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
      blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
      consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
    }
  },
  create(context, [options]) {
    const { max, maxEOF = max, maxBOF = max } = options;
    const sourceCode = context.sourceCode;
    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
    const templateLiteralLines = /* @__PURE__ */ new Set();
    return {
      TemplateLiteral(node) {
        node.quasis.forEach((literalPart) => {
          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) templateLiteralLines.add(ignoredLine);
        });
      },
      "Program:exit": function(node) {
        return allLines.reduce((nonEmptyLineNumbers, line, index2) => {
          if (line.trim() || templateLiteralLines.has(index2 + 1)) nonEmptyLineNumbers.push(index2 + 1);
          return nonEmptyLineNumbers;
        }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {
          let messageId, maxAllowed;
          if (lastLineNumber === 0) {
            messageId = "blankBeginningOfFile";
            maxAllowed = maxBOF;
          } else if (lineNumber === allLines.length + 1) {
            messageId = "blankEndOfFile";
            maxAllowed = maxEOF;
          } else {
            messageId = "consecutiveBlank";
            maxAllowed = max;
          }
          if (lineNumber - lastLineNumber - 1 > maxAllowed) context.report({
            node,
            loc: {
              start: {
                line: lastLineNumber + maxAllowed + 1,
                column: 0
              },
              end: {
                line: lineNumber,
                column: 0
              }
            },
            messageId,
            data: {
              max: maxAllowed,
              pluralizedLines: maxAllowed === 1 ? "line" : "lines"
            },
            fix(fixer) {
              const rangeStart = sourceCode.getIndexFromLoc({
                line: lastLineNumber + 1,
                column: 0
              });
              const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
              const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({
                line: lineNumberAfterRemovedLines,
                column: 0
              }) : sourceCode.text.length;
              return fixer.removeRange([rangeStart, rangeEnd]);
            }
          });
          return lineNumber;
        }, 0);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-tabs.js
var tabRegex = /\t+/gu;
var anyNonWhitespaceRegex = /\S/u;
var no_tabs_default = createRule({
  name: "no-tabs",
  meta: {
    type: "layout",
    docs: { description: "Disallow all tabs" },
    schema: [{
      type: "object",
      properties: { allowIndentationTabs: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: [{ allowIndentationTabs: false }],
    messages: { unexpectedTab: "Unexpected tab character." }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const { allowIndentationTabs } = options;
    return { Program(node) {
      sourceCode.getLines().forEach((line, index2) => {
        let match;
        while ((match = tabRegex.exec(line)) !== null) {
          if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) continue;
          context.report({
            node,
            loc: {
              start: {
                line: index2 + 1,
                column: match.index
              },
              end: {
                line: index2 + 1,
                column: match.index + match[0].length
              }
            },
            messageId: "unexpectedTab"
          });
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-trailing-spaces.js
var no_trailing_spaces_default = createRule({
  name: "no-trailing-spaces",
  meta: {
    type: "layout",
    docs: { description: "Disallow trailing whitespace at the end of lines" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        skipBlankLines: { type: "boolean" },
        ignoreComments: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      skipBlankLines: false,
      ignoreComments: false
    }],
    messages: { trailingSpace: "Trailing spaces not allowed." }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const BLANK_CLASS = "[ 	\xA0\u2000-\u200B\u3000]";
    const SKIP_BLANK = `^${BLANK_CLASS}*$`;
    const NONBLANK = `${BLANK_CLASS}+$`;
    const { skipBlankLines, ignoreComments } = options;
    function report(node, location, fixRange) {
      context.report({
        node,
        loc: location,
        messageId: "trailingSpace",
        fix(fixer) {
          return fixer.removeRange(fixRange);
        }
      });
    }
    function getCommentLineNumbers(comments) {
      const lines = /* @__PURE__ */ new Set();
      comments.forEach((comment) => {
        const endLine = comment.type === "Block" ? comment.loc.end.line - 1 : comment.loc.end.line;
        for (let i = comment.loc.start.line; i <= endLine; i++) lines.add(i);
      });
      return lines;
    }
    return { Program: function checkTrailingSpaces(node) {
      const re = new RegExp(NONBLANK, "u");
      const skipMatch = new RegExp(SKIP_BLANK, "u");
      const lines = sourceCode.lines;
      const linebreaks = sourceCode.getText().match(createGlobalLinebreakMatcher());
      const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
      let totalLength = 0;
      for (let i = 0, ii = lines.length; i < ii; i++) {
        const lineNumber = i + 1;
        const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
        const lineLength = lines[i].length + linebreakLength;
        const matches = re.exec(lines[i]);
        if (matches) {
          const location = {
            start: {
              line: lineNumber,
              column: matches.index
            },
            end: {
              line: lineNumber,
              column: lineLength - linebreakLength
            }
          };
          const rangeStart = totalLength + location.start.column;
          const rangeEnd = totalLength + location.end.column;
          const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
          if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
            totalLength += lineLength;
            continue;
          }
          if (skipBlankLines && skipMatch.test(lines[i])) {
            totalLength += lineLength;
            continue;
          }
          const fixRange = [rangeStart, rangeEnd];
          if (!ignoreComments || !commentLineNumbers.has(lineNumber)) report(node, location, fixRange);
        }
        totalLength += lineLength;
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/no-whitespace-before-property.js
var no_whitespace_before_property_default = createRule({
  name: "no-whitespace-before-property",
  meta: {
    type: "layout",
    docs: { description: "Disallow whitespace before properties" },
    fixable: "whitespace",
    schema: [],
    messages: { unexpectedWhitespace: "Unexpected whitespace before property {{propName}}." }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    function reportError(descriptor) {
      const { node, leftToken, rightToken, propName, replacementText = "", preventAutoFix } = descriptor;
      context.report({
        node,
        messageId: "unexpectedWhitespace",
        data: { propName },
        fix: preventAutoFix?.() ? null : safeReplaceTextBetween(sourceCode, leftToken, rightToken, replacementText)
      });
    }
    return {
      MemberExpression(node) {
        if (!(0, ast_exports.isTokenOnSameLine)(node.object, node.property)) return;
        let rightToken;
        let leftToken;
        if (node.computed) {
          rightToken = sourceCode.getTokenBefore(node.property, ast_exports.isOpeningBracketToken);
          leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
        } else {
          rightToken = sourceCode.getFirstToken(node.property);
          leftToken = sourceCode.getTokenBefore(rightToken, 1);
        }
        if (!sourceCode.isSpaceBetween(leftToken, rightToken)) return;
        let replacementText = "";
        if (node.optional) replacementText = "?.";
        else if (!node.computed) replacementText = ".";
        reportError({
          node,
          leftToken,
          rightToken,
          propName: sourceCode.getText(node.property),
          replacementText,
          preventAutoFix: () => !node.computed && !node.optional && isDecimalInteger(node.object)
        });
      },
      TSIndexedAccessType(node) {
        const rightToken = sourceCode.getTokenBefore(node.indexType, ast_exports.isOpeningBracketToken);
        const leftToken = sourceCode.getTokenBefore(rightToken);
        if (!sourceCode.isSpaceBetween(leftToken, rightToken)) return;
        reportError({
          node,
          leftToken,
          rightToken,
          propName: sourceCode.getText(node.indexType)
        });
      },
      TSQualifiedName(node) {
        const leftToken = node.left;
        const rightToken = node.right;
        if (!sourceCode.isSpaceBetween(leftToken, rightToken)) return;
        reportError({
          node,
          leftToken,
          rightToken,
          replacementText: ".",
          propName: sourceCode.getText(node.right)
        });
      },
      TSImportType(node) {
        if (!node.qualifier) return;
        const rightToken = node.qualifier;
        const leftToken = sourceCode.getTokenBefore(rightToken, 1);
        if (!sourceCode.isSpaceBetween(leftToken, rightToken)) return;
        reportError({
          node,
          leftToken,
          rightToken,
          replacementText: ".",
          propName: sourceCode.getText(node.qualifier)
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/nonblock-statement-body-position.js
var POSITION_SCHEMA = {
  type: "string",
  enum: [
    "beside",
    "below",
    "any"
  ]
};
var nonblock_statement_body_position_default = createRule({
  name: "nonblock-statement-body-position",
  meta: {
    type: "layout",
    docs: { description: "Enforce the location of single-line statements" },
    fixable: "whitespace",
    schema: [POSITION_SCHEMA, {
      type: "object",
      properties: { overrides: {
        type: "object",
        properties: {
          if: POSITION_SCHEMA,
          else: POSITION_SCHEMA,
          while: POSITION_SCHEMA,
          do: POSITION_SCHEMA,
          for: POSITION_SCHEMA
        },
        additionalProperties: false
      } },
      additionalProperties: false
    }],
    defaultOptions: ["beside"],
    messages: {
      expectNoLinebreak: "Expected no linebreak before this statement.",
      expectLinebreak: "Expected a linebreak before this statement."
    }
  },
  create(context, [style, { overrides = {} } = {}]) {
    const sourceCode = context.sourceCode;
    function validateStatement(node, keywordName) {
      const option = overrides[keywordName] ?? style;
      if (node.type === "BlockStatement" || option === "any") return;
      const tokenBefore = sourceCode.getTokenBefore(node);
      const onSameLine = (0, ast_exports.isTokenOnSameLine)(tokenBefore, node);
      if (onSameLine && option === "below") context.report({
        node,
        messageId: "expectLinebreak",
        fix: (fixer) => fixer.insertTextBefore(node, "\n")
      });
      else if (!onSameLine && option === "beside") context.report({
        node,
        messageId: "expectNoLinebreak",
        fix: safeReplaceTextBetween(sourceCode, tokenBefore, node, " ")
      });
    }
    return {
      IfStatement(node) {
        validateStatement(node.consequent, "if");
        if (node.alternate && node.alternate.type !== "IfStatement") validateStatement(node.alternate, "else");
      },
      WhileStatement: (node) => validateStatement(node.body, "while"),
      DoWhileStatement: (node) => validateStatement(node.body, "do"),
      ForStatement: (node) => validateStatement(node.body, "for"),
      ForInStatement: (node) => validateStatement(node.body, "for"),
      ForOfStatement: (node) => validateStatement(node.body, "for")
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/object-curly-newline.js
var OPTION_VALUE = { oneOf: [{
  type: "string",
  enum: ["always", "never"]
}, {
  type: "object",
  properties: {
    multiline: { type: "boolean" },
    minProperties: {
      type: "integer",
      minimum: 0
    },
    consistent: { type: "boolean" }
  },
  additionalProperties: false,
  minProperties: 1
}] };
var object_curly_newline_default = createRule({
  name: "object-curly-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent line breaks after opening and before closing braces" },
    fixable: "whitespace",
    schema: [{ oneOf: [OPTION_VALUE, {
      type: "object",
      properties: {
        ObjectExpression: OPTION_VALUE,
        ObjectPattern: OPTION_VALUE,
        ImportDeclaration: OPTION_VALUE,
        ExportDeclaration: OPTION_VALUE,
        TSTypeLiteral: OPTION_VALUE,
        TSInterfaceBody: OPTION_VALUE,
        TSEnumBody: OPTION_VALUE
      },
      additionalProperties: false,
      minProperties: 1
    }] }],
    defaultOptions: [],
    messages: {
      unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
      unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
      expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
      expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    function normalizeOptionValue2(value) {
      let multiline = false;
      let minProperties = Number.POSITIVE_INFINITY;
      let consistent = false;
      if (value) if (value === "always") minProperties = 0;
      else if (value === "never") minProperties = Number.POSITIVE_INFINITY;
      else {
        multiline = Boolean(value.multiline);
        minProperties = value.minProperties || Number.POSITIVE_INFINITY;
        consistent = Boolean(value.consistent);
      }
      else consistent = true;
      return {
        multiline,
        minProperties,
        consistent
      };
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isNodeSpecificOption(option) {
      return isObject(option) || typeof option === "string";
    }
    function normalizeOptions3(options2) {
      if (isObject(options2) && Object.values(options2).some(isNodeSpecificOption)) return {
        ObjectExpression: normalizeOptionValue2(options2.ObjectExpression),
        ObjectPattern: normalizeOptionValue2(options2.ObjectPattern),
        ImportDeclaration: normalizeOptionValue2(options2.ImportDeclaration),
        ExportNamedDeclaration: normalizeOptionValue2(options2.ExportDeclaration),
        TSTypeLiteral: normalizeOptionValue2(options2.TSTypeLiteral),
        TSInterfaceBody: normalizeOptionValue2(options2.TSInterfaceBody),
        TSEnumBody: normalizeOptionValue2(options2.TSEnumBody)
      };
      const value = normalizeOptionValue2(options2);
      return {
        ObjectExpression: value,
        ObjectPattern: value,
        ImportDeclaration: value,
        ExportNamedDeclaration: value,
        TSTypeLiteral: value,
        TSInterfaceBody: value,
        TSEnumBody: value
      };
    }
    const normalizedOptions = normalizeOptions3(options);
    function areLineBreaksRequired(node, options2, first, last) {
      let objectProperties;
      if (node.type === "ObjectExpression" || node.type === "ObjectPattern") objectProperties = node.properties;
      else if (node.type === "TSTypeLiteral") objectProperties = node.members;
      else if (node.type === "TSInterfaceBody") objectProperties = node.body;
      else if (node.type === "TSEnumBody") objectProperties = node.members;
      else objectProperties = node.specifiers.filter((s) => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
      return objectProperties.length >= options2.minProperties || options2.multiline && objectProperties.length > 0 && !(0, ast_exports.isTokenOnSameLine)(last, first);
    }
    function check(node) {
      const options2 = normalizedOptions[node.type];
      if (node.type === "ImportDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ImportSpecifier") || node.type === "ExportNamedDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ExportSpecifier")) return;
      const openBrace = sourceCode.getFirstToken(node, (token) => token.value === "{");
      let closeBrace;
      if (node.type === "ObjectPattern" && node.typeAnnotation) closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
      else closeBrace = sourceCode.getLastToken(node, (token) => token.value === "}");
      let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
      let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
      const needsLineBreaks = areLineBreaksRequired(node, options2, first, last);
      const hasCommentsFirstToken = (0, ast_exports.isCommentToken)(first);
      const hasCommentsLastToken = (0, ast_exports.isCommentToken)(last);
      first = sourceCode.getTokenAfter(openBrace);
      last = sourceCode.getTokenBefore(closeBrace);
      if (needsLineBreaks) {
        if ((0, ast_exports.isTokenOnSameLine)(openBrace, first)) context.report({
          messageId: "expectedLinebreakAfterOpeningBrace",
          node,
          loc: openBrace.loc,
          fix(fixer) {
            if (hasCommentsFirstToken) return null;
            return fixer.insertTextAfter(openBrace, "\n");
          }
        });
        if ((0, ast_exports.isTokenOnSameLine)(last, closeBrace)) context.report({
          messageId: "expectedLinebreakBeforeClosingBrace",
          node,
          loc: closeBrace.loc,
          fix(fixer) {
            if (hasCommentsLastToken) return null;
            return fixer.insertTextBefore(closeBrace, "\n");
          }
        });
      } else {
        const consistent = options2.consistent;
        const hasLineBreakBetweenOpenBraceAndFirst = !(0, ast_exports.isTokenOnSameLine)(openBrace, first);
        const hasLineBreakBetweenCloseBraceAndLast = !(0, ast_exports.isTokenOnSameLine)(last, closeBrace);
        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) context.report({
          messageId: "unexpectedLinebreakAfterOpeningBrace",
          node,
          loc: openBrace.loc,
          fix(fixer) {
            if (hasCommentsFirstToken) return null;
            return fixer.removeRange([openBrace.range[1], first.range[0]]);
          }
        });
        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) context.report({
          messageId: "unexpectedLinebreakBeforeClosingBrace",
          node,
          loc: closeBrace.loc,
          fix(fixer) {
            if (hasCommentsLastToken) return null;
            return fixer.removeRange([last.range[1], closeBrace.range[0]]);
          }
        });
      }
    }
    return {
      ObjectExpression: check,
      ObjectPattern: check,
      ImportDeclaration: check,
      ExportNamedDeclaration: check,
      TSTypeLiteral: check,
      TSInterfaceBody: check,
      TSEnumBody: check
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/object-curly-spacing.js
var object_curly_spacing_default = createRule({
  name: "object-curly-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing inside braces" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        arraysInObjects: { type: "boolean" },
        objectsInObjects: { type: "boolean" },
        overrides: {
          type: "object",
          properties: Object.fromEntries([
            "ObjectPattern",
            "ObjectExpression",
            "ImportDeclaration",
            "ImportAttributes",
            "ExportNamedDeclaration",
            "ExportAllDeclaration",
            "TSMappedType",
            "TSTypeLiteral",
            "TSInterfaceBody",
            "TSEnumBody"
          ].map((node) => [node, {
            type: "string",
            enum: ["always", "never"]
          }])),
          additionalProperties: false
        },
        emptyObjects: {
          type: "string",
          enum: [
            "ignore",
            "always",
            "never"
          ]
        }
      },
      additionalProperties: false
    }],
    defaultOptions: ["never"],
    messages: {
      requireSpaceBefore: "A space is required before '{{token}}'.",
      requireSpaceAfter: "A space is required after '{{token}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{token}}'.",
      requiredSpaceInEmptyObject: "A space is required in empty '{{node}}'.",
      unexpectedSpaceInEmptyObject: "There should be no space in empty '{{node}}'."
    }
  },
  create(context, [firstOption, secondOption]) {
    const spaced = firstOption === "always";
    const sourceCode = context.sourceCode;
    function isOptionSet(option) {
      return secondOption ? secondOption[option] === !spaced : false;
    }
    const options = {
      spaced,
      arraysInObjectsException: isOptionSet("arraysInObjects"),
      objectsInObjectsException: isOptionSet("objectsInObjects"),
      overrides: secondOption?.overrides ?? {},
      emptyObjects: secondOption?.emptyObjects ?? "ignore"
    };
    function reportNoBeginningSpace(node, token) {
      const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
      context.report({
        node,
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: { token: token.value },
        fix(fixer) {
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }
    function reportNoEndingSpace(node, token) {
      const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });
      context.report({
        node,
        loc: {
          start: previousToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: { token: token.value },
        fix(fixer) {
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "requireSpaceAfter",
        data: { token: token.value },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "requireSpaceBefore",
        data: { token: token.value },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }
    function validateBraceSpacing(node, openingToken, closingToken, nodeType = node.type) {
      const tokenAfterOpening = sourceCode.getTokenAfter(openingToken, { includeComments: true });
      const spaced2 = options.overrides[nodeType] ? options.overrides[nodeType] === "always" : options.spaced;
      if ((0, ast_exports.isTokenOnSameLine)(openingToken, tokenAfterOpening)) {
        const firstSpaced = sourceCode.isSpaceBetween(openingToken, tokenAfterOpening);
        const secondType = sourceCode.getNodeByRangeIndex(tokenAfterOpening.range[0]).type;
        const openingCurlyBraceMustBeSpaced = options.arraysInObjectsException && [import_types.AST_NODE_TYPES.TSMappedType, import_types.AST_NODE_TYPES.TSIndexSignature].includes(secondType) ? !spaced2 : spaced2;
        if (openingCurlyBraceMustBeSpaced && !firstSpaced) reportRequiredBeginningSpace(node, openingToken);
        if (!openingCurlyBraceMustBeSpaced && firstSpaced && !((0, ast_exports.isCommentToken)(tokenAfterOpening) && !(0, ast_exports.isTokenOnSameLine)(openingToken, closingToken))) reportNoBeginningSpace(node, openingToken);
      }
      const tokenBeforeClosing = sourceCode.getTokenBefore(closingToken, { includeComments: true });
      if ((0, ast_exports.isTokenOnSameLine)(tokenBeforeClosing, closingToken)) {
        const penultimateType = options.arraysInObjectsException && (0, ast_exports.isClosingBracketToken)(tokenBeforeClosing) || options.objectsInObjectsException && (0, ast_exports.isClosingBraceToken)(tokenBeforeClosing) ? sourceCode.getNodeByRangeIndex(tokenBeforeClosing.range[0]).type : void 0;
        const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && [import_types.AST_NODE_TYPES.ArrayExpression, import_types.AST_NODE_TYPES.TSTupleType].includes(penultimateType) || options.objectsInObjectsException && penultimateType !== void 0 && [
          import_types.AST_NODE_TYPES.ObjectExpression,
          import_types.AST_NODE_TYPES.ObjectPattern,
          import_types.AST_NODE_TYPES.TSMappedType,
          import_types.AST_NODE_TYPES.TSTypeLiteral
        ].includes(penultimateType) ? !spaced2 : spaced2;
        const lastSpaced = sourceCode.isSpaceBetween(tokenBeforeClosing, closingToken);
        if (closingCurlyBraceMustBeSpaced && !lastSpaced) reportRequiredEndingSpace(node, closingToken);
        if (!closingCurlyBraceMustBeSpaced && lastSpaced) reportNoEndingSpace(node, closingToken);
      }
    }
    function checkSpaceInEmptyObjectLike(node, openingToken, closingToken, nodeType = node.type) {
      if (options.emptyObjects === "ignore" || !(0, ast_exports.isTokenOnSameLine)(openingToken, closingToken) || sourceCode.commentsExistBetween(openingToken, closingToken)) return;
      const sourceBetween = sourceCode.getText().slice(openingToken.range[0] + 1, closingToken.range[1] - 1);
      if (sourceBetween.trim() !== "") return;
      if (options.emptyObjects === "always") {
        if (sourceBetween === " ") return;
        context.report({
          node,
          loc: {
            start: openingToken.loc.end,
            end: closingToken.loc.start
          },
          messageId: "requiredSpaceInEmptyObject",
          data: { node: nodeType },
          fix(fixer) {
            return fixer.replaceTextRange([openingToken.range[1], closingToken.range[0]], " ");
          }
        });
      } else if (options.emptyObjects === "never") {
        if (sourceBetween === "") return;
        context.report({
          node,
          loc: {
            start: openingToken.loc.end,
            end: closingToken.loc.start
          },
          messageId: "unexpectedSpaceInEmptyObject",
          data: { node: nodeType },
          fix(fixer) {
            return fixer.removeRange([openingToken.range[1], closingToken.range[0]]);
          }
        });
      }
    }
    function getBraceToken(node, nodeType = node.type) {
      switch (nodeType) {
        case "ImportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration": {
          const attrTokens = sourceCode.getTokens(node);
          return [attrTokens.find((token) => (0, ast_exports.isOpeningBraceToken)(token)), attrTokens.find((token) => (0, ast_exports.isClosingBraceToken)(token))];
        }
        case "ImportAttributes": {
          const attrTokens = sourceCode.getTokens(node);
          const openingAttrToken = attrTokens.findLast((token) => (0, ast_exports.isOpeningBraceToken)(token));
          const closingAttrToken = attrTokens.findLast((token) => (0, ast_exports.isClosingBraceToken)(token));
          if (!openingAttrToken || !closingAttrToken || !node.source || openingAttrToken.range[0] < node.source.range[0]) return [null, null];
          return [openingAttrToken, closingAttrToken];
        }
        case "ObjectPattern":
        case "ObjectExpression":
        case "TSMappedType":
        case "TSTypeLiteral":
        case "TSInterfaceBody":
        case "TSEnumBody": {
          const allTokens = sourceCode.getTokens(node);
          return [allTokens.find((token) => (0, ast_exports.isOpeningBraceToken)(token)), allTokens.findLast((token) => (0, ast_exports.isClosingBraceToken)(token))];
        }
        default:
          throw new Error(`Unsupported node type: ${nodeType}`);
      }
    }
    function checkForObjectLike(node, properties, nodeType = node.type) {
      const [openingToken, closingToken] = getBraceToken(node, nodeType);
      if (!openingToken || !closingToken) return;
      if (properties.length === 0) {
        checkSpaceInEmptyObjectLike(node, openingToken, closingToken, nodeType);
        return;
      }
      validateBraceSpacing(node, openingToken, closingToken, nodeType);
    }
    return {
      ObjectPattern(node) {
        checkForObjectLike(node, node.properties);
      },
      ObjectExpression(node) {
        checkForObjectLike(node, node.properties);
      },
      ImportDeclaration(node) {
        if (node.attributes) checkForObjectLike(node, node.attributes, "ImportAttributes");
        const firstSpecifierIndex = node.specifiers.findIndex((specifier) => specifier.type === "ImportSpecifier");
        if (firstSpecifierIndex === -1) {
          checkForObjectLike(node, []);
          return;
        }
        checkForObjectLike(node, node.specifiers.slice(firstSpecifierIndex));
      },
      ExportNamedDeclaration(node) {
        checkForObjectLike(node, node.specifiers);
        if (node.attributes) checkForObjectLike(node, node.attributes, "ImportAttributes");
      },
      ExportAllDeclaration(node) {
        if (node.attributes) checkForObjectLike(node, node.attributes, "ImportAttributes");
      },
      TSMappedType(node) {
        validateBraceSpacing(node, sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      },
      TSTypeLiteral(node) {
        checkForObjectLike(node, node.members);
      },
      TSInterfaceBody(node) {
        checkForObjectLike(node, node.body);
      },
      TSEnumBody(node) {
        checkForObjectLike(node, node.members);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/object-property-newline.js
var object_property_newline_default = createRule({
  name: "object-property-newline",
  meta: {
    type: "layout",
    docs: { description: "Enforce placing object properties on separate lines" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: { allowAllPropertiesOnSameLine: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: [{ allowAllPropertiesOnSameLine: false }],
    messages: {
      propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
      propertiesOnNewline: "Object properties must go on a new line."
    }
  },
  create(context, [options]) {
    const allowSameLine = options.allowAllPropertiesOnSameLine;
    const messageId = allowSameLine ? "propertiesOnNewlineAll" : "propertiesOnNewline";
    const sourceCode = context.sourceCode;
    function check(node, children) {
      if (allowSameLine) {
        if (children.length > 1) {
          if ((0, ast_exports.isTokenOnSameLine)(sourceCode.getFirstToken(children[0]), sourceCode.getLastToken(children[children.length - 1]))) return;
        }
      }
      for (let i = 1; i < children.length; i++) {
        const lastTokenOfPreviousProperty = sourceCode.getLastToken(children[i - 1]);
        const firstTokenOfCurrentProperty = sourceCode.getFirstToken(children[i]);
        if ((0, ast_exports.isTokenOnSameLine)(lastTokenOfPreviousProperty, firstTokenOfCurrentProperty)) context.report({
          node,
          loc: firstTokenOfCurrentProperty.loc,
          messageId,
          fix(fixer) {
            const rangeAfterComma = [sourceCode.getTokenBefore(firstTokenOfCurrentProperty).range[1], firstTokenOfCurrentProperty.range[0]];
            if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) return null;
            return fixer.replaceTextRange(rangeAfterComma, "\n");
          }
        });
      }
    }
    return {
      ObjectExpression(node) {
        check(node, node.properties);
      },
      TSTypeLiteral(node) {
        check(node, node.members);
      },
      TSInterfaceBody(node) {
        check(node, node.body);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/one-var-declaration-per-line.js
var one_var_declaration_per_line_default = createRule({
  name: "one-var-declaration-per-line",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow newlines around variable declarations" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "initializations"]
    }],
    defaultOptions: ["initializations"],
    messages: { expectVarOnNewline: "Expected variable declaration to be on a new line." }
  },
  create(context, [style]) {
    const { sourceCode } = context;
    const always = style === "always";
    function isForTypeSpecifier(keyword) {
      return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }
    function checkForNewLine(node) {
      if (isForTypeSpecifier(node.parent.type)) return;
      const declarations = node.declarations;
      let prev;
      declarations.forEach((current2) => {
        if (prev && (0, ast_exports.isTokenOnSameLine)(prev, current2)) {
          if (always || prev.init || current2.init) {
            let fix = (fixer) => fixer.insertTextBefore(current2, "\n");
            const tokenBeforeDeclarator = sourceCode.getTokenBefore(current2, { includeComments: false });
            if (tokenBeforeDeclarator) {
              const betweenText = sourceCode.text.slice(tokenBeforeDeclarator.range[1], current2.range[0]);
              fix = (fixer) => fixer.replaceTextRange([tokenBeforeDeclarator.range[1], current2.range[0]], `${betweenText}
`);
            }
            context.report({
              node,
              messageId: "expectVarOnNewline",
              loc: current2.loc,
              fix
            });
          }
        }
        prev = current2;
      });
    }
    return { VariableDeclaration: checkForNewLine };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/operator-linebreak.js
var operator_linebreak_default = createRule({
  name: "operator-linebreak",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent linebreak style for operators" },
    fixable: "code",
    schema: [{ oneOf: [{
      type: "string",
      enum: [
        "after",
        "before",
        "none"
      ]
    }, { type: "null" }] }, {
      type: "object",
      properties: { overrides: {
        type: "object",
        additionalProperties: {
          type: "string",
          enum: [
            "after",
            "before",
            "none",
            "ignore"
          ]
        }
      } },
      additionalProperties: false
    }],
    defaultOptions: [],
    messages: {
      operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
      operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
      badLinebreak: "Bad line breaking before and after '{{operator}}'.",
      noLinebreak: "There should be no line break before or after '{{operator}}'."
    }
  },
  create(context) {
    const usedDefaultGlobal = !context.options[0];
    const globalStyle = context.options[0] || "after";
    const options = context.options[1] || {};
    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
    if (usedDefaultGlobal && !styleOverrides["?"]) styleOverrides["?"] = "before";
    if (usedDefaultGlobal && !styleOverrides[":"]) styleOverrides[":"] = "before";
    const sourceCode = context.sourceCode;
    function getFixer(operatorToken, desiredStyle) {
      return (fixer) => {
        const tokenBefore = sourceCode.getTokenBefore(operatorToken);
        const tokenAfter = sourceCode.getTokenAfter(operatorToken);
        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
        const hasLinebreakBefore = !(0, ast_exports.isTokenOnSameLine)(tokenBefore, operatorToken);
        const hasLinebreakAfter = !(0, ast_exports.isTokenOnSameLine)(operatorToken, tokenAfter);
        let newTextBefore, newTextAfter;
        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
          if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) return null;
          newTextBefore = textAfter;
          newTextAfter = textBefore;
        } else {
          const LINEBREAK_REGEX = createGlobalLinebreakMatcher();
          newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
          newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
          if (newTextBefore === textBefore && newTextAfter === textAfter) return null;
        }
        if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) newTextAfter += " ";
        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
      };
    }
    function validateNode(node, rightSide, operator) {
      const operatorToken = sourceCode.getTokenBefore(rightSide, (token) => token.value === operator);
      const leftToken = sourceCode.getTokenBefore(operatorToken);
      const rightToken = sourceCode.getTokenAfter(operatorToken);
      const operatorStyleOverride = styleOverrides[operator];
      const style = operatorStyleOverride || globalStyle;
      const fix = getFixer(operatorToken, style);
      if ((0, ast_exports.isTokenOnSameLine)(leftToken, operatorToken) && (0, ast_exports.isTokenOnSameLine)(operatorToken, rightToken)) {
      } else if (operatorStyleOverride !== "ignore" && !(0, ast_exports.isTokenOnSameLine)(leftToken, operatorToken) && !(0, ast_exports.isTokenOnSameLine)(operatorToken, rightToken)) context.report({
        node,
        loc: operatorToken.loc,
        messageId: "badLinebreak",
        data: { operator },
        fix
      });
      else if (style === "before" && (0, ast_exports.isTokenOnSameLine)(leftToken, operatorToken)) context.report({
        node,
        loc: operatorToken.loc,
        messageId: "operatorAtBeginning",
        data: { operator },
        fix
      });
      else if (style === "after" && (0, ast_exports.isTokenOnSameLine)(operatorToken, rightToken)) context.report({
        node,
        loc: operatorToken.loc,
        messageId: "operatorAtEnd",
        data: { operator },
        fix
      });
      else if (style === "none") context.report({
        node,
        loc: operatorToken.loc,
        messageId: "noLinebreak",
        data: { operator },
        fix
      });
    }
    function validateBinaryExpression(node) {
      validateNode(node, node.right, node.operator);
    }
    return {
      BinaryExpression: validateBinaryExpression,
      LogicalExpression: validateBinaryExpression,
      AssignmentExpression: validateBinaryExpression,
      VariableDeclarator(node) {
        if (node.init) validateNode(node, node.init, "=");
      },
      PropertyDefinition(node) {
        if (node.value) validateNode(node, node.value, "=");
      },
      AccessorProperty(node) {
        if (node.value) validateNode(node, node.value, "=");
      },
      ConditionalExpression(node) {
        validateNode(node, node.consequent, "?");
        validateNode(node, node.alternate, ":");
      },
      TSImportEqualsDeclaration(node) {
        validateNode(node, node.moduleReference, "=");
      },
      TSTypeAliasDeclaration(node) {
        validateNode(node, node.typeAnnotation, "=");
      },
      TSConditionalType(node) {
        validateNode(node, node.trueType, "?");
        validateNode(node, node.falseType, ":");
      },
      TSIntersectionType(node) {
        const { types: types2 } = node;
        for (let idx = 0; idx < types2.length - 1; idx++) validateNode(types2[idx], types2[idx + 1], "&");
      },
      TSUnionType(node) {
        const { types: types2 } = node;
        for (let idx = 0; idx < types2.length - 1; idx++) validateNode(types2[idx], types2[idx + 1], "|");
      },
      TSTypeParameter(node) {
        if (!node.default) return;
        validateNode(node, node.default, "=");
      },
      TSEnumMember(node) {
        if (!node.initializer) return;
        validateNode(node, node.initializer, "=");
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/padded-blocks.js
var OPTION_ENUMS = [
  "always",
  "never",
  "start",
  "end"
];
var padded_blocks_default = createRule({
  name: "padded-blocks",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow padding within blocks" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: OPTION_ENUMS
    }, {
      type: "object",
      properties: {
        blocks: {
          type: "string",
          enum: OPTION_ENUMS
        },
        switches: {
          type: "string",
          enum: OPTION_ENUMS
        },
        classes: {
          type: "string",
          enum: OPTION_ENUMS
        }
      },
      additionalProperties: false,
      minProperties: 1
    }] }, {
      type: "object",
      properties: { allowSingleLineBlocks: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["always", { allowSingleLineBlocks: false }],
    messages: {
      missingPadBlock: "Block must be padded by blank lines.",
      extraPadBlock: "Block must not be padded by blank lines."
    }
  },
  create(context, [typeOptions, { allowSingleLineBlocks } = {}]) {
    const options = typeof typeOptions === "string" ? {
      blocks: typeOptions,
      switches: typeOptions,
      classes: typeOptions
    } : typeOptions;
    const sourceCode = context.sourceCode;
    function getOpenBrace(node) {
      if (node.type === "SwitchStatement") return sourceCode.getTokenBefore(node.cases[0]);
      if (node.type === "StaticBlock") return sourceCode.getFirstToken(node, { skip: 1 });
      return sourceCode.getFirstToken(node);
    }
    function isComment(node) {
      return node.type === "Line" || node.type === "Block";
    }
    function isPaddingBetweenTokens(first, second) {
      return second.loc.start.line - first.loc.end.line >= 2;
    }
    function getFirstBlockToken(token) {
      let prev;
      let first = token;
      do {
        prev = first;
        first = sourceCode.getTokenAfter(first, { includeComments: true });
      } while (isComment(first) && (0, ast_exports.isTokenOnSameLine)(prev, first));
      return first;
    }
    function getLastBlockToken(token) {
      let last = token;
      let next;
      do {
        next = last;
        last = sourceCode.getTokenBefore(last, { includeComments: true });
      } while (isComment(last) && (0, ast_exports.isTokenOnSameLine)(last, next));
      return last;
    }
    function requirePaddingFor(node) {
      switch (node.type) {
        case "BlockStatement":
        case "StaticBlock":
          return options.blocks;
        case "SwitchStatement":
          return options.switches;
        case "ClassBody":
          return options.classes;
        default:
          throw new Error("unreachable");
      }
    }
    function checkPadding(node) {
      const firstBlockToken = getFirstBlockToken(getOpenBrace(node));
      const tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true });
      const lastBlockToken = getLastBlockToken(sourceCode.getLastToken(node));
      const tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true });
      const blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken);
      const blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);
      if (allowSingleLineBlocks && (0, ast_exports.isTokenOnSameLine)(tokenBeforeFirst, tokenAfterLast)) return;
      const requiredPadding = requirePaddingFor(node);
      if (blockHasTopPadding) {
        if (requiredPadding === "never" || requiredPadding === "end") context.report({
          node,
          loc: {
            start: tokenBeforeFirst.loc.start,
            end: firstBlockToken.loc.start
          },
          fix(fixer) {
            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
          },
          messageId: "extraPadBlock"
        });
      } else if (requiredPadding === "always" || requiredPadding === "start") context.report({
        node,
        loc: {
          start: tokenBeforeFirst.loc.start,
          end: firstBlockToken.loc.start
        },
        fix(fixer) {
          return fixer.insertTextAfter(tokenBeforeFirst, "\n");
        },
        messageId: "missingPadBlock"
      });
      if (blockHasBottomPadding) {
        if (requiredPadding === "never" || requiredPadding === "start") context.report({
          node,
          loc: {
            end: tokenAfterLast.loc.start,
            start: lastBlockToken.loc.end
          },
          messageId: "extraPadBlock",
          fix(fixer) {
            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
          }
        });
      } else if (requiredPadding === "always" || requiredPadding === "end") context.report({
        node,
        loc: {
          end: tokenAfterLast.loc.start,
          start: lastBlockToken.loc.end
        },
        fix(fixer) {
          return fixer.insertTextBefore(tokenAfterLast, "\n");
        },
        messageId: "missingPadBlock"
      });
    }
    const rule = {};
    if (Object.hasOwn(options, "switches")) rule.SwitchStatement = function(node) {
      if (node.cases.length === 0) return;
      checkPadding(node);
    };
    if (Object.hasOwn(options, "blocks")) {
      rule.BlockStatement = function(node) {
        if (node.body.length === 0) return;
        checkPadding(node);
      };
      rule.StaticBlock = rule.BlockStatement;
    }
    if (Object.hasOwn(options, "classes")) rule.ClassBody = function(node) {
      if (node.body.length === 0) return;
      checkPadding(node);
    };
    return rule;
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/padding-line-between-statements.js
var CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
var CJS_IMPORT = /^require\(/u;
var LT = `[${Array.from(LINEBREAKS).join("")}]`;
var PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`, "u");
function newKeywordTester(type, keyword) {
  return { test(node, sourceCode) {
    const isSameKeyword = sourceCode.getFirstToken(node)?.value === keyword;
    const isSameType = Array.isArray(type) ? type.includes(node.type) : type === node.type;
    return isSameKeyword && isSameType;
  } };
}
function newNodeTypeTester(type) {
  return { test: (node) => node.type === type };
}
function isIIFEStatement(node) {
  if (node.type === import_types.AST_NODE_TYPES.ExpressionStatement) {
    let expression = skipChainExpression(node.expression);
    if (expression.type === import_types.AST_NODE_TYPES.UnaryExpression) expression = skipChainExpression(expression.argument);
    if (expression.type === import_types.AST_NODE_TYPES.CallExpression) {
      let node2 = expression.callee;
      while (node2.type === import_types.AST_NODE_TYPES.SequenceExpression) node2 = node2.expressions[node2.expressions.length - 1];
      return (0, ast_exports.isFunction)(node2);
    }
  }
  return false;
}
function isCJSRequire(node) {
  if (node.type === import_types.AST_NODE_TYPES.VariableDeclaration) {
    const declaration = node.declarations[0];
    if (declaration?.init) {
      let call = declaration?.init;
      while (call.type === import_types.AST_NODE_TYPES.MemberExpression) call = call.object;
      if (call.type === import_types.AST_NODE_TYPES.CallExpression && call.callee.type === import_types.AST_NODE_TYPES.Identifier) return call.callee.name === "require";
    }
  }
  return false;
}
function isBlockLikeStatement(node, sourceCode) {
  if (node.type === import_types.AST_NODE_TYPES.DoWhileStatement && node.body.type === import_types.AST_NODE_TYPES.BlockStatement) return true;
  if (isIIFEStatement(node)) return true;
  const lastToken = sourceCode.getLastToken(node, ast_exports.isNotSemicolonToken);
  const belongingNode = lastToken && (0, ast_exports.isClosingBraceToken)(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;
  return !!belongingNode && (belongingNode.type === import_types.AST_NODE_TYPES.BlockStatement || belongingNode.type === import_types.AST_NODE_TYPES.SwitchStatement);
}
function isDirective(node, sourceCode) {
  return isTopLevelExpressionStatement(node) && node.expression.type === import_types.AST_NODE_TYPES.Literal && typeof node.expression.value === "string" && !(0, ast_exports.isParenthesized)(node.expression, sourceCode);
}
function isDirectivePrologue(node, sourceCode) {
  if (isDirective(node, sourceCode) && node.parent && "body" in node.parent && Array.isArray(node.parent.body)) {
    for (const sibling2 of node.parent.body) {
      if (sibling2 === node) break;
      if (!isDirective(sibling2, sourceCode)) return false;
    }
    return true;
  }
  return false;
}
function isCJSExport(node) {
  if (node.type === import_types.AST_NODE_TYPES.ExpressionStatement) {
    const expression = node.expression;
    if (expression.type === import_types.AST_NODE_TYPES.AssignmentExpression) {
      let left = expression.left;
      if (left.type === import_types.AST_NODE_TYPES.MemberExpression) {
        while (left.object.type === import_types.AST_NODE_TYPES.MemberExpression) left = left.object;
        return left.object.type === import_types.AST_NODE_TYPES.Identifier && (left.object.name === "exports" || left.object.name === "module" && left.property.type === import_types.AST_NODE_TYPES.Identifier && left.property.name === "exports");
      }
    }
  }
  return false;
}
function isExpression(node, sourceCode) {
  return node.type === import_types.AST_NODE_TYPES.ExpressionStatement && !isDirectivePrologue(node, sourceCode);
}
function getActualLastToken(node, sourceCode) {
  const semiToken = sourceCode.getLastToken(node);
  const prevToken = sourceCode.getTokenBefore(semiToken);
  const nextToken = sourceCode.getTokenAfter(semiToken);
  return prevToken && nextToken && prevToken.range[0] >= node.range[0] && (0, ast_exports.isSemicolonToken)(semiToken) && !(0, ast_exports.isTokenOnSameLine)(prevToken, semiToken) && (0, ast_exports.isTokenOnSameLine)(semiToken, nextToken) ? prevToken : semiToken;
}
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
  return trailingSpaces + indentSpaces;
}
function getReportLoc(node, sourceCode) {
  if (isSingleLine(node)) return node.loc;
  const line = node.loc.start.line;
  return {
    start: node.loc.start,
    end: {
      line,
      column: sourceCode.lines[line - 1].length
    }
  };
}
function verifyForAny() {
}
function verifyForNever(context, _, nextNode, paddingLines) {
  if (paddingLines.length === 0) return;
  context.report({
    node: nextNode,
    messageId: "unexpectedBlankLine",
    loc: getReportLoc(nextNode, context.sourceCode),
    fix(fixer) {
      if (paddingLines.length >= 2) return null;
      const prevToken = paddingLines[0][0];
      const nextToken = paddingLines[0][1];
      const start = prevToken.range[1];
      const end = nextToken.range[0];
      const text = context.sourceCode.text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
      return fixer.replaceTextRange([start, end], text);
    }
  });
}
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
  if (paddingLines.length > 0) return;
  context.report({
    node: nextNode,
    messageId: "expectedBlankLine",
    loc: getReportLoc(nextNode, context.sourceCode),
    fix(fixer) {
      const sourceCode = context.sourceCode;
      let prevToken = getActualLastToken(prevNode, sourceCode);
      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
        includeComments: true,
        filter(token) {
          if ((0, ast_exports.isTokenOnSameLine)(prevToken, token)) {
            prevToken = token;
            return false;
          }
          return true;
        }
      }) || nextNode;
      const insertText = (0, ast_exports.isTokenOnSameLine)(prevToken, nextToken) ? "\n\n" : "\n";
      return fixer.insertTextAfter(prevToken, insertText);
    }
  });
}
var PaddingTypes = {
  any: { verify: verifyForAny },
  never: { verify: verifyForNever },
  always: { verify: verifyForAlways }
};
var MaybeMultilineStatementType = {
  "block-like": { test: isBlockLikeStatement },
  "expression": { test: isExpression },
  "return": newKeywordTester(import_types.AST_NODE_TYPES.ReturnStatement, "return"),
  "export": newKeywordTester([
    import_types.AST_NODE_TYPES.ExportAllDeclaration,
    import_types.AST_NODE_TYPES.ExportDefaultDeclaration,
    import_types.AST_NODE_TYPES.ExportNamedDeclaration
  ], "export"),
  "var": newKeywordTester(import_types.AST_NODE_TYPES.VariableDeclaration, "var"),
  "let": newKeywordTester(import_types.AST_NODE_TYPES.VariableDeclaration, "let"),
  "const": newKeywordTester(import_types.AST_NODE_TYPES.VariableDeclaration, "const"),
  "using": { test: (node) => node.type === "VariableDeclaration" && (node.kind === "using" || node.kind === "await using") },
  "type": newKeywordTester(import_types.AST_NODE_TYPES.TSTypeAliasDeclaration, "type")
};
var StatementTypes = {
  "*": { test: () => true },
  "exports": { test: isCJSExport },
  "require": { test: isCJSRequire },
  "directive": { test: isDirectivePrologue },
  "iife": { test: isIIFEStatement },
  "block": newNodeTypeTester(import_types.AST_NODE_TYPES.BlockStatement),
  "empty": newNodeTypeTester(import_types.AST_NODE_TYPES.EmptyStatement),
  "function": newNodeTypeTester(import_types.AST_NODE_TYPES.FunctionDeclaration),
  "ts-method": newNodeTypeTester(import_types.AST_NODE_TYPES.TSMethodSignature),
  "break": newKeywordTester(import_types.AST_NODE_TYPES.BreakStatement, "break"),
  "case": newKeywordTester(import_types.AST_NODE_TYPES.SwitchCase, "case"),
  "class": newKeywordTester(import_types.AST_NODE_TYPES.ClassDeclaration, "class"),
  "continue": newKeywordTester(import_types.AST_NODE_TYPES.ContinueStatement, "continue"),
  "debugger": newKeywordTester(import_types.AST_NODE_TYPES.DebuggerStatement, "debugger"),
  "default": newKeywordTester([import_types.AST_NODE_TYPES.SwitchCase, import_types.AST_NODE_TYPES.ExportDefaultDeclaration], "default"),
  "do": newKeywordTester(import_types.AST_NODE_TYPES.DoWhileStatement, "do"),
  "for": newKeywordTester([
    import_types.AST_NODE_TYPES.ForStatement,
    import_types.AST_NODE_TYPES.ForInStatement,
    import_types.AST_NODE_TYPES.ForOfStatement
  ], "for"),
  "if": newKeywordTester(import_types.AST_NODE_TYPES.IfStatement, "if"),
  "import": newKeywordTester(import_types.AST_NODE_TYPES.ImportDeclaration, "import"),
  "switch": newKeywordTester(import_types.AST_NODE_TYPES.SwitchStatement, "switch"),
  "throw": newKeywordTester(import_types.AST_NODE_TYPES.ThrowStatement, "throw"),
  "try": newKeywordTester(import_types.AST_NODE_TYPES.TryStatement, "try"),
  "while": newKeywordTester([import_types.AST_NODE_TYPES.WhileStatement, import_types.AST_NODE_TYPES.DoWhileStatement], "while"),
  "with": newKeywordTester(import_types.AST_NODE_TYPES.WithStatement, "with"),
  "cjs-export": { test: (node, sourceCode) => node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left)) },
  "cjs-import": { test: (node, sourceCode) => node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init)) },
  "enum": newKeywordTester(import_types.AST_NODE_TYPES.TSEnumDeclaration, "enum"),
  "interface": newKeywordTester(import_types.AST_NODE_TYPES.TSInterfaceDeclaration, "interface"),
  "function-overload": newNodeTypeTester(import_types.AST_NODE_TYPES.TSDeclareFunction),
  ...Object.fromEntries(Object.entries(MaybeMultilineStatementType).flatMap(([key, value]) => [
    [key, value],
    [`singleline-${key}`, {
      ...value,
      test: (node, sourceCode) => value.test(node, sourceCode) && isSingleLine(node)
    }],
    [`multiline-${key}`, {
      ...value,
      test: (node, sourceCode) => value.test(node, sourceCode) && !isSingleLine(node)
    }]
  ]))
};
var padding_line_between_statements_default = createRule({
  name: "padding-line-between-statements",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow padding lines between statements" },
    fixable: "whitespace",
    hasSuggestions: false,
    schema: {
      $defs: {
        paddingType: {
          type: "string",
          enum: Object.keys(PaddingTypes)
        },
        statementType: {
          type: "string",
          enum: Object.keys(StatementTypes)
        },
        statementOption: { anyOf: [{ $ref: "#/$defs/statementType" }, {
          type: "array",
          items: { $ref: "#/$defs/statementType" },
          minItems: 1,
          uniqueItems: true,
          additionalItems: false
        }] }
      },
      type: "array",
      additionalItems: false,
      items: {
        type: "object",
        properties: {
          blankLine: { $ref: "#/$defs/paddingType" },
          prev: { $ref: "#/$defs/statementOption" },
          next: { $ref: "#/$defs/statementOption" }
        },
        additionalProperties: false,
        required: [
          "blankLine",
          "prev",
          "next"
        ]
      }
    },
    defaultOptions: [],
    messages: {
      unexpectedBlankLine: "Unexpected blank line before this statement.",
      expectedBlankLine: "Expected blank line before this statement."
    }
  },
  create(context, options) {
    const sourceCode = context.sourceCode;
    const configureList = options;
    let scopeInfo = null;
    function enterScope() {
      scopeInfo = {
        upper: scopeInfo,
        prevNode: null
      };
    }
    function exitScope() {
      if (scopeInfo) scopeInfo = scopeInfo.upper;
    }
    function match(node, type) {
      let innerStatementNode = node;
      while (innerStatementNode.type === import_types.AST_NODE_TYPES.LabeledStatement) innerStatementNode = innerStatementNode.body;
      if (Array.isArray(type)) return type.some(match.bind(null, innerStatementNode));
      return StatementTypes[type].test(innerStatementNode, sourceCode);
    }
    function getPaddingType(prevNode, nextNode) {
      for (let i = configureList.length - 1; i >= 0; --i) {
        const configure = configureList[i];
        if (match(prevNode, configure.prev) && match(nextNode, configure.next)) return PaddingTypes[configure.blankLine];
      }
      return PaddingTypes.any;
    }
    function getPaddingLineSequences(prevNode, nextNode) {
      const pairs = [];
      let prevToken = getActualLastToken(prevNode, sourceCode);
      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) do {
        const token = sourceCode.getTokenAfter(prevToken, { includeComments: true });
        if (token.loc.start.line - prevToken.loc.end.line >= 2) pairs.push([prevToken, token]);
        prevToken = token;
      } while (prevToken.range[0] < nextNode.range[0]);
      return pairs;
    }
    function verify(node) {
      if (!node.parent || ![
        import_types.AST_NODE_TYPES.BlockStatement,
        import_types.AST_NODE_TYPES.Program,
        import_types.AST_NODE_TYPES.StaticBlock,
        import_types.AST_NODE_TYPES.SwitchCase,
        import_types.AST_NODE_TYPES.SwitchStatement,
        import_types.AST_NODE_TYPES.TSInterfaceBody,
        import_types.AST_NODE_TYPES.TSModuleBlock,
        import_types.AST_NODE_TYPES.TSTypeLiteral
      ].includes(node.parent.type)) return;
      const prevNode = scopeInfo.prevNode;
      if (prevNode) {
        const type = getPaddingType(prevNode, node);
        const paddingLines = getPaddingLineSequences(prevNode, node);
        type.verify(context, prevNode, node, paddingLines);
      }
      scopeInfo.prevNode = node;
    }
    function verifyThenEnterScope(node) {
      verify(node);
      enterScope();
    }
    return {
      "Program": enterScope,
      "Program:exit": exitScope,
      "BlockStatement": enterScope,
      "BlockStatement:exit": exitScope,
      "SwitchStatement": enterScope,
      "SwitchStatement:exit": exitScope,
      "SwitchCase": verifyThenEnterScope,
      "SwitchCase:exit": exitScope,
      "StaticBlock": enterScope,
      "StaticBlock:exit": exitScope,
      "TSInterfaceBody": enterScope,
      "TSInterfaceBody:exit": exitScope,
      "TSModuleBlock": enterScope,
      "TSModuleBlock:exit": exitScope,
      "TSTypeLiteral": enterScope,
      "TSTypeLiteral:exit": exitScope,
      "TSDeclareFunction": verifyThenEnterScope,
      "TSDeclareFunction:exit": exitScope,
      "TSMethodSignature": verifyThenEnterScope,
      "TSMethodSignature:exit": exitScope,
      ":statement": verify
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/quote-props.js
var quote_props_default = createRule({
  name: "quote-props",
  meta: {
    type: "layout",
    docs: { description: "Require quotes around object literal, type literal, interfaces and enums property names" },
    fixable: "code",
    schema: { anyOf: [{
      type: "array",
      items: [{
        type: "string",
        enum: [
          "always",
          "as-needed",
          "consistent",
          "consistent-as-needed"
        ]
      }],
      minItems: 0,
      maxItems: 1
    }, {
      type: "array",
      items: [{
        type: "string",
        enum: [
          "always",
          "as-needed",
          "consistent",
          "consistent-as-needed"
        ]
      }, {
        type: "object",
        properties: {
          keywords: { type: "boolean" },
          unnecessary: { type: "boolean" },
          numbers: { type: "boolean" }
        },
        additionalProperties: false
      }],
      minItems: 0,
      maxItems: 2
    }] },
    defaultOptions: ["always"],
    messages: {
      requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
      inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
      unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
      unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
      unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
      unquotedPropertyFound: "Unquoted property '{{property}}' found.",
      redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
    }
  },
  create(context, [MODE, options = {}]) {
    const { keywords: KEYWORDS2 = false, unnecessary: CHECK_UNNECESSARY = true, numbers: NUMBERS = false } = options;
    const sourceCode = context.sourceCode;
    function isKeyword(tokenStr) {
      return ES3_KEYWORDS.includes(tokenStr);
    }
    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals = false) {
      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([
        "Identifier",
        "Keyword",
        "Null",
        "Boolean"
      ].includes(tokens[0].type) || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
    }
    function getUnquotedKey(key) {
      return key.type === "Identifier" ? key.name : key.value;
    }
    function getQuotedKey(key) {
      if (isStringLiteral(key)) return sourceCode.getText(key);
      return `"${key.type === "Identifier" ? key.name : key.value}"`;
    }
    function checkUnnecessaryQuotes(node) {
      if (node.type === "Property" && (node.method || node.computed || node.shorthand)) return;
      if (node.type !== "ImportAttribute" && node.computed) return;
      const key = node.type === "TSEnumMember" ? node.id : node.key;
      if (key.type === "Literal" && typeof key.value === "string") {
        let tokens;
        try {
          tokens = tokenize(key.value);
        } catch {
          return;
        }
        if (tokens.length !== 1) return;
        if (isKeyword(tokens[0].value) && KEYWORDS2) return;
        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) context.report({
          node,
          messageId: "unnecessarilyQuotedProperty",
          data: { property: key.value },
          fix: (fixer) => fixer.replaceText(key, getUnquotedKey(key))
        });
      } else if (KEYWORDS2 && key.type === "Identifier" && isKeyword(key.name)) context.report({
        node,
        messageId: "unquotedReservedProperty",
        data: { property: key.name },
        fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
      });
      else if (NUMBERS && isNumericLiteral(key)) context.report({
        node,
        messageId: "unquotedNumericProperty",
        data: { property: key.value },
        fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
      });
    }
    function checkOmittedQuotes(node) {
      if (node.type === "Property" && (node.method || node.computed || node.shorthand)) return;
      if (node.type !== "ImportAttribute" && node.computed) return;
      const key = node.type === "TSEnumMember" ? node.id : node.key;
      if (key.type === "Literal" && typeof key.value === "string") return;
      context.report({
        node,
        messageId: "unquotedPropertyFound",
        data: { property: key.name || key.value },
        fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
      });
    }
    function checkConsistencyForObject(properties, checkQuotesRedundancy) {
      checkConsistency(properties.filter((property) => property.type !== "SpreadElement" && property.key && !property.method && !property.computed && !property.shorthand), checkQuotesRedundancy);
    }
    function checkImportAttributes(attributes) {
      if (!attributes) return;
      if (MODE === "consistent") checkConsistency(attributes, false);
      if (MODE === "consistent-as-needed") checkConsistency(attributes, true);
    }
    function checkConsistency(properties, checkQuotesRedundancy) {
      const quotedProps = [];
      const unquotedProps = [];
      let keywordKeyName = null;
      let necessaryQuotes = false;
      properties.forEach((property) => {
        const key = property.key;
        if (key.type === "Literal" && typeof key.value === "string") {
          quotedProps.push(property);
          if (checkQuotesRedundancy) {
            let tokens;
            try {
              tokens = tokenize(key.value);
            } catch {
              necessaryQuotes = true;
              return;
            }
            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS2 && isKeyword(tokens[0].value);
          }
        } else if (KEYWORDS2 && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
          unquotedProps.push(property);
          necessaryQuotes = true;
          keywordKeyName = key.name;
        } else unquotedProps.push(property);
      });
      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) quotedProps.forEach((property) => {
        const key = property.key;
        context.report({
          node: property,
          messageId: "redundantQuoting",
          fix: (fixer) => fixer.replaceText(key, getUnquotedKey(key))
        });
      });
      else if (unquotedProps.length && keywordKeyName) unquotedProps.forEach((property) => {
        context.report({
          node: property,
          messageId: "requireQuotesDueToReservedWord",
          data: { property: keywordKeyName },
          fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
        });
      });
      else if (quotedProps.length && unquotedProps.length) unquotedProps.forEach((property) => {
        context.report({
          node: property,
          messageId: "inconsistentlyQuotedProperty",
          data: { key: property.key.name || property.key.value },
          fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
        });
      });
    }
    return {
      Property(node) {
        if (MODE === "always" || !MODE) checkOmittedQuotes(node);
        if (MODE === "as-needed") checkUnnecessaryQuotes(node);
      },
      ObjectExpression(node) {
        if (MODE === "consistent") checkConsistencyForObject(node.properties, false);
        if (MODE === "consistent-as-needed") checkConsistencyForObject(node.properties, true);
      },
      ImportAttribute(node) {
        if (MODE === "always" || !MODE) checkOmittedQuotes(node);
        if (MODE === "as-needed") checkUnnecessaryQuotes(node);
      },
      ImportDeclaration(node) {
        checkImportAttributes(node.attributes);
      },
      ExportAllDeclaration(node) {
        checkImportAttributes(node.attributes);
      },
      ExportNamedDeclaration(node) {
        checkImportAttributes(node.attributes);
      },
      TSPropertySignature(node) {
        if (MODE === "always" || !MODE) checkOmittedQuotes(node);
        if (MODE === "as-needed") checkUnnecessaryQuotes(node);
      },
      TSEnumMember(node) {
        if (MODE === "always" || !MODE) checkOmittedQuotes(node);
        if (MODE === "as-needed") checkUnnecessaryQuotes(node);
      },
      TSTypeLiteral(node) {
        if (MODE === "consistent") checkConsistencyForObject(node.members, false);
        if (MODE === "consistent-as-needed") checkConsistencyForObject(node.members, true);
      },
      TSInterfaceBody(node) {
        if (MODE === "consistent") checkConsistencyForObject(node.body, false);
        if (MODE === "consistent-as-needed") checkConsistencyForObject(node.body, true);
      },
      TSEnumDeclaration(node) {
        const members = (node.body?.members || node.members).map((member) => ({
          ...member,
          key: member.id
        }));
        if (MODE === "consistent") checkConsistencyForObject(members, false);
        if (MODE === "consistent-as-needed") checkConsistencyForObject(members, true);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/quotes.js
function switchQuote(str) {
  const newQuote = this.quote;
  const oldQuote = str[0];
  if (newQuote === oldQuote) return str;
  return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
    if (escaped === oldQuote || oldQuote === "`" && escaped === "${") return escaped;
    if (match === newQuote || newQuote === "`" && match === "${") return `\\${match}`;
    if (newline && oldQuote === "`") return "\\n";
    return match;
  }) + newQuote;
}
var QUOTE_SETTINGS2 = {
  double: {
    quote: '"',
    alternateQuote: "'",
    description: "doublequote",
    convert: switchQuote
  },
  single: {
    quote: "'",
    alternateQuote: '"',
    description: "singlequote",
    convert: switchQuote
  },
  backtick: {
    quote: "`",
    alternateQuote: '"',
    description: "backtick",
    convert: switchQuote
  }
};
var UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(LINEBREAKS).join("")}]`, "u");
var AVOID_ESCAPE = "avoid-escape";
var quotes_default = createRule({
  name: "quotes",
  meta: {
    type: "layout",
    docs: { description: "Enforce the consistent use of either backticks, double, or single quotes" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: [
        "single",
        "double",
        "backtick"
      ]
    }, { anyOf: [{
      type: "string",
      enum: ["avoid-escape"]
    }, {
      type: "object",
      properties: {
        avoidEscape: { type: "boolean" },
        allowTemplateLiterals: { anyOf: [{ type: "boolean" }, {
          type: "string",
          enum: [
            "never",
            "avoidEscape",
            "always"
          ]
        }] },
        ignoreStringLiterals: { type: "boolean" }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["double", {
      allowTemplateLiterals: "never",
      avoidEscape: false,
      ignoreStringLiterals: false
    }],
    messages: { wrongQuotes: "Strings must use {{description}}." }
  },
  create(context, [quoteOption, options]) {
    const settings = QUOTE_SETTINGS2[quoteOption || "double"];
    const sourceCode = context.sourceCode;
    let avoidEscape = false;
    let ignoreStringLiterals = false;
    let allowTemplateLiteralsAlways = false;
    let allowTemplateLiteralsToAvoidEscape = false;
    if (typeof options === "object") {
      avoidEscape = options.avoidEscape === true;
      ignoreStringLiterals = options.ignoreStringLiterals === true;
      if (typeof options.allowTemplateLiterals === "string") {
        allowTemplateLiteralsAlways = options.allowTemplateLiterals === "always";
        allowTemplateLiteralsToAvoidEscape = allowTemplateLiteralsAlways || options.allowTemplateLiterals === "avoidEscape";
      } else if (typeof options.allowTemplateLiterals === "boolean") {
        warnDeprecation('value(boolean) for "allowTemplateLiterals"', '"always"/"never"', "quotes");
        allowTemplateLiteralsAlways = options.allowTemplateLiterals === true;
        allowTemplateLiteralsToAvoidEscape = options.allowTemplateLiterals === true;
      }
    } else if (options === AVOID_ESCAPE) {
      warnDeprecation(`option("${AVOID_ESCAPE}")`, '"avoidEscape"', "quotes");
      avoidEscape = true;
    }
    function isJSXLiteral(node) {
      if (!node.parent) return false;
      return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
    }
    function isDirective2(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string" && !isParenthesised(sourceCode, node.expression);
    }
    function isExpressionInOrJustAfterDirectivePrologue(node) {
      if (!node.parent) return false;
      if (!isTopLevelExpressionStatement(node.parent)) return false;
      const block = node.parent.parent;
      if (!block || !("body" in block) || !Array.isArray(block.body)) return false;
      for (let i = 0; i < block.body.length; ++i) {
        const statement = block.body[i];
        if (statement === node.parent) return true;
        if (!isDirective2(statement)) break;
      }
      return false;
    }
    function isAllowedAsNonBacktick(node) {
      const parent = node.parent;
      if (!parent) return false;
      switch (parent.type) {
        case import_types.AST_NODE_TYPES.ExpressionStatement:
          return !isParenthesised(sourceCode, node) && isExpressionInOrJustAfterDirectivePrologue(node);
        case import_types.AST_NODE_TYPES.Property:
        case import_types.AST_NODE_TYPES.MethodDefinition:
          return parent.key === node && !parent.computed;
        case import_types.AST_NODE_TYPES.ImportDeclaration:
        case import_types.AST_NODE_TYPES.ExportNamedDeclaration:
          return parent.source === node;
        case import_types.AST_NODE_TYPES.ExportAllDeclaration:
          return parent.exported === node || parent.source === node;
        case import_types.AST_NODE_TYPES.ImportSpecifier:
          return parent.imported === node;
        case import_types.AST_NODE_TYPES.ExportSpecifier:
          return parent.local === node || parent.exported === node;
        case import_types.AST_NODE_TYPES.ImportAttribute:
          return parent.value === node;
        case import_types.AST_NODE_TYPES.TSImportType:
        case import_types.AST_NODE_TYPES.TSAbstractMethodDefinition:
        case import_types.AST_NODE_TYPES.TSMethodSignature:
        case import_types.AST_NODE_TYPES.TSPropertySignature:
        case import_types.AST_NODE_TYPES.TSModuleDeclaration:
        case import_types.AST_NODE_TYPES.TSExternalModuleReference:
          return true;
        case import_types.AST_NODE_TYPES.TSEnumMember:
          return node === parent.id;
        case import_types.AST_NODE_TYPES.TSAbstractPropertyDefinition:
        case import_types.AST_NODE_TYPES.PropertyDefinition:
        case import_types.AST_NODE_TYPES.AccessorProperty:
          return parent.key === node && !parent.computed;
        case import_types.AST_NODE_TYPES.TSLiteralType:
          return parent.parent?.type === import_types.AST_NODE_TYPES.TSImportType;
        default:
          return false;
      }
    }
    function isUsingFeatureOfTemplateLiteral(node) {
      if (node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi) return true;
      if (node.expressions.length > 0) return true;
      if (node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw)) return true;
      return false;
    }
    return {
      Literal(node) {
        if (ignoreStringLiterals) return;
        const val = node.value;
        const rawVal = node.raw;
        if (settings && typeof val === "string") {
          let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || isSurroundedBy(rawVal, settings.quote);
          if (!isValid && avoidEscape) isValid = isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.includes(settings.quote);
          if (!isValid) context.report({
            node,
            messageId: "wrongQuotes",
            data: { description: settings.description },
            fix(fixer) {
              if (quoteOption === "backtick" && hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) return null;
              return fixer.replaceText(node, settings.convert(node.raw));
            }
          });
        }
      },
      TemplateLiteral(node) {
        if (allowTemplateLiteralsAlways || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node)) return;
        if (allowTemplateLiteralsToAvoidEscape && avoidEscape && sourceCode.getText(node).includes(settings.quote)) return;
        context.report({
          node,
          messageId: "wrongQuotes",
          data: { description: settings.description },
          fix(fixer) {
            if (isTopLevelExpressionStatement(node.parent) && !isParenthesised(sourceCode, node)) return null;
            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
          }
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/rest-spread-spacing.js
var rest_spread_spacing_default = createRule({
  name: "rest-spread-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce spacing between rest and spread operators and their expressions" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["never"],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
      expectedWhitespace: "Expected whitespace after {{type}} operator."
    }
  },
  create(context, [style]) {
    const sourceCode = context.sourceCode;
    const alwaysSpace = style === "always";
    function checkWhiteSpace(node) {
      const operator = sourceCode.getFirstToken(node);
      const nextToken = sourceCode.getTokenAfter(operator);
      const hasWhitespace = sourceCode.isSpaceBetween(operator, nextToken);
      let type;
      switch (node.type) {
        case "SpreadElement":
          type = "spread";
          if (node.parent.type === "ObjectExpression") type += " property";
          break;
        case "RestElement":
          type = "rest";
          if (node.parent.type === "ObjectPattern") type += " property";
          break;
        default:
          return;
      }
      if (alwaysSpace && !hasWhitespace) context.report({
        node,
        loc: operator.loc,
        messageId: "expectedWhitespace",
        data: { type },
        fix(fixer) {
          return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
        }
      });
      else if (!alwaysSpace && hasWhitespace) context.report({
        node,
        loc: {
          start: operator.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedWhitespace",
        data: { type },
        fix(fixer) {
          return fixer.removeRange([operator.range[1], nextToken.range[0]]);
        }
      });
    }
    return {
      SpreadElement: checkWhiteSpace,
      RestElement: checkWhiteSpace
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/semi-spacing.js
var semi_spacing_default = createRule({
  name: "semi-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before and after semicolons" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      before: false,
      after: true
    }],
    messages: {
      unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
      unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
      missingWhitespaceBefore: "Missing whitespace before semicolon.",
      missingWhitespaceAfter: "Missing whitespace after semicolon."
    }
  },
  create(context, [config]) {
    const { before: requireSpaceBefore, after: requireSpaceAfter } = config;
    const sourceCode = context.sourceCode;
    function hasLeadingSpace(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return tokenBefore && (0, ast_exports.isTokenOnSameLine)(tokenBefore, token) && sourceCode.isSpaceBetween(tokenBefore, token);
    }
    function hasTrailingSpace(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return tokenAfter && (0, ast_exports.isTokenOnSameLine)(token, tokenAfter) && sourceCode.isSpaceBetween(token, tokenAfter);
    }
    function isLastTokenInCurrentLine(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return !(tokenAfter && (0, ast_exports.isTokenOnSameLine)(token, tokenAfter));
    }
    function isFirstTokenInCurrentLine(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return !(tokenBefore && (0, ast_exports.isTokenOnSameLine)(token, tokenBefore));
    }
    function isBeforeClosingParen(token) {
      const nextToken = sourceCode.getTokenAfter(token);
      return nextToken && (0, ast_exports.isClosingBraceToken)(nextToken) || (0, ast_exports.isClosingParenToken)(nextToken);
    }
    function checkSemicolonSpacing(token, node) {
      if ((0, ast_exports.isSemicolonToken)(token)) {
        if (hasLeadingSpace(token)) {
          if (!requireSpaceBefore) {
            const tokenBefore = sourceCode.getTokenBefore(token);
            const loc = {
              start: tokenBefore.loc.end,
              end: token.loc.start
            };
            context.report({
              node,
              loc,
              messageId: "unexpectedWhitespaceBefore",
              fix(fixer) {
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
              }
            });
          }
        } else if (requireSpaceBefore) {
          const loc = token.loc;
          context.report({
            node,
            loc,
            messageId: "missingWhitespaceBefore",
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
          if (hasTrailingSpace(token)) {
            if (!requireSpaceAfter) {
              const tokenAfter = sourceCode.getTokenAfter(token);
              const loc = {
                start: token.loc.end,
                end: tokenAfter.loc.start
              };
              context.report({
                node,
                loc,
                messageId: "unexpectedWhitespaceAfter",
                fix(fixer) {
                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                }
              });
            }
          } else if (requireSpaceAfter) {
            const loc = token.loc;
            context.report({
              node,
              loc,
              messageId: "missingWhitespaceAfter",
              fix(fixer) {
                return fixer.insertTextAfter(token, " ");
              }
            });
          }
        }
      }
    }
    function checkNode(node) {
      checkSemicolonSpacing(sourceCode.getLastToken(node), node);
    }
    return {
      VariableDeclaration: checkNode,
      ExpressionStatement: checkNode,
      BreakStatement: checkNode,
      ContinueStatement: checkNode,
      DebuggerStatement: checkNode,
      DoWhileStatement: checkNode,
      ReturnStatement: checkNode,
      ThrowStatement: checkNode,
      ImportDeclaration: checkNode,
      ExportNamedDeclaration: checkNode,
      ExportAllDeclaration: checkNode,
      ExportDefaultDeclaration: checkNode,
      ForStatement(node) {
        if (node.init) checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
        if (node.test) checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
      },
      PropertyDefinition: checkNode,
      AccessorProperty: checkNode,
      TSDeclareFunction: checkNode,
      TSTypeAliasDeclaration: checkNode,
      TSTypeAnnotation(node) {
        const excludeNodeTypes = /* @__PURE__ */ new Set([import_types.AST_NODE_TYPES.TSDeclareFunction]);
        if (node.parent && !excludeNodeTypes.has(node.parent.type)) checkNode(node.parent);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/semi-style.js
var SELECTOR = [
  "BreakStatement",
  "ContinueStatement",
  "DebuggerStatement",
  "DoWhileStatement",
  "ExportAllDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ExpressionStatement",
  "ImportDeclaration",
  "ReturnStatement",
  "ThrowStatement",
  "VariableDeclaration",
  "PropertyDefinition",
  "AccessorProperty"
].join(",");
function getChildren(node) {
  const t = node.type;
  if (t === "BlockStatement" || t === "StaticBlock" || t === "Program" || t === "ClassBody") return node.body;
  if (t === "SwitchCase") return node.consequent;
  return null;
}
function isLastChild(node) {
  if (!node.parent) return true;
  const t = node.parent.type;
  if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) return true;
  if (t === "DoWhileStatement") return true;
  const nodeList = getChildren(node.parent);
  return nodeList !== null && nodeList[nodeList.length - 1] === node;
}
var semi_style_default = createRule({
  name: "semi-style",
  meta: {
    type: "layout",
    docs: { description: "Enforce location of semicolons" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["last", "first"]
    }],
    defaultOptions: ["last"],
    messages: { expectedSemiColon: "Expected this semicolon to be at {{pos}}." }
  },
  create(context, [option]) {
    const sourceCode = context.sourceCode;
    function check(semiToken, expected) {
      const prevToken = sourceCode.getTokenBefore(semiToken);
      const nextToken = sourceCode.getTokenAfter(semiToken);
      const prevIsSameLine = !prevToken || (0, ast_exports.isTokenOnSameLine)(prevToken, semiToken);
      const nextIsSameLine = !nextToken || (0, ast_exports.isTokenOnSameLine)(semiToken, nextToken);
      if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) context.report({
        loc: semiToken.loc,
        messageId: "expectedSemiColon",
        data: { pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line" },
        fix(fixer) {
          if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) return null;
          const start = prevToken ? prevToken.range[1] : semiToken.range[0];
          const end = nextToken ? nextToken.range[0] : semiToken.range[1];
          const text = expected === "last" ? ";\n" : "\n;";
          return fixer.replaceTextRange([start, end], text);
        }
      });
    }
    return {
      [SELECTOR](node) {
        if (option === "first" && isLastChild(node)) return;
        const lastToken = sourceCode.getLastToken(node);
        if ((0, ast_exports.isSemicolonToken)(lastToken)) check(lastToken, option);
      },
      ForStatement(node) {
        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, ast_exports.isSemicolonToken);
        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, ast_exports.isSemicolonToken);
        if (firstSemi) check(firstSemi, "last");
        if (secondSemi) check(secondSemi, "last");
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/semi.js
var semi_default = createRule({
  name: "semi",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow semicolons instead of ASI" },
    fixable: "code",
    schema: { anyOf: [{
      type: "array",
      items: [{
        type: "string",
        enum: ["never"]
      }, {
        type: "object",
        properties: { beforeStatementContinuationChars: {
          type: "string",
          enum: [
            "always",
            "any",
            "never"
          ]
        } },
        additionalProperties: false
      }],
      minItems: 0,
      maxItems: 2
    }, {
      type: "array",
      items: [{
        type: "string",
        enum: ["always"]
      }, {
        type: "object",
        properties: {
          omitLastInOneLineBlock: { type: "boolean" },
          omitLastInOneLineClassBody: { type: "boolean" }
        },
        additionalProperties: false
      }],
      minItems: 0,
      maxItems: 2
    }] },
    defaultOptions: ["always"],
    messages: {
      missingSemi: "Missing semicolon.",
      extraSemi: "Extra semicolon."
    }
  },
  create(context, [mode, options]) {
    const OPT_OUT_PATTERN = /^[-[(/+`]/u;
    const unsafeClassFieldNames = /* @__PURE__ */ new Set([
      "get",
      "set",
      "static"
    ]);
    const unsafeClassFieldFollowers = /* @__PURE__ */ new Set([
      "*",
      "in",
      "instanceof"
    ]);
    const never = mode === "never";
    const exceptOneLine = Boolean(options && "omitLastInOneLineBlock" in options && options.omitLastInOneLineBlock);
    const exceptOneLineClassBody = Boolean(options && "omitLastInOneLineClassBody" in options && options.omitLastInOneLineClassBody);
    const beforeStatementContinuationChars = options && "beforeStatementContinuationChars" in options && options.beforeStatementContinuationChars || "any";
    const sourceCode = context.sourceCode;
    function report(node, missing = false) {
      const lastToken = sourceCode.getLastToken(node);
      let messageId = "missingSemi";
      let fix, loc;
      if (!missing) {
        loc = {
          start: lastToken.loc.end,
          end: getNextLocation(sourceCode, lastToken.loc.end)
        };
        fix = function(fixer) {
          return fixer.insertTextAfter(lastToken, ";");
        };
      } else {
        messageId = "extraSemi";
        loc = lastToken.loc;
        fix = function(fixer) {
          return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
        };
      }
      context.report({
        node,
        loc,
        messageId,
        fix
      });
    }
    function isRedundantSemi(semiToken) {
      const nextToken = sourceCode.getTokenAfter(semiToken);
      return !nextToken || (0, ast_exports.isClosingBraceToken)(nextToken) || (0, ast_exports.isSemicolonToken)(nextToken);
    }
    function isEndOfArrowBlock(lastToken) {
      if (!(0, ast_exports.isClosingBraceToken)(lastToken)) return false;
      const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);
      return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
    }
    function maybeClassFieldAsiHazard(node) {
      if (node.type !== "PropertyDefinition") return false;
      if (!node.computed && node.key.type === "Identifier" && "name" in node.key && unsafeClassFieldNames.has(node.key.name)) {
        if (!(node.static && node.key.name === "static") && !node.value) return true;
      }
      const followingToken = sourceCode.getTokenAfter(node);
      return unsafeClassFieldFollowers.has(followingToken.value);
    }
    function isOnSameLineWithNextToken(node) {
      const prevToken = sourceCode.getLastToken(node, 1);
      const nextToken = sourceCode.getTokenAfter(node);
      return !!nextToken && (0, ast_exports.isTokenOnSameLine)(prevToken, nextToken);
    }
    function maybeAsiHazardAfter(node) {
      const t = node.type;
      if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") return false;
      if (t === "ReturnStatement") return Boolean(node.argument);
      if (t === "ExportNamedDeclaration") return Boolean(node.declaration);
      if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) return false;
      return true;
    }
    function maybeAsiHazardBefore(token) {
      return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
    }
    function canRemoveSemicolon(node) {
      if (isRedundantSemi(sourceCode.getLastToken(node))) return true;
      if (maybeClassFieldAsiHazard(node)) return false;
      if (isOnSameLineWithNextToken(node)) return false;
      if (node.type !== "PropertyDefinition" && beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) return true;
      if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) return true;
      return false;
    }
    function isLastInOneLinerBlock(node) {
      const parent = node.parent;
      const nextToken = sourceCode.getTokenAfter(node);
      if (!nextToken || nextToken.value !== "}") return false;
      if (parent.type === "BlockStatement") return isSingleLine(parent);
      if (parent.type === "StaticBlock") return (0, ast_exports.isTokenOnSameLine)(parent, sourceCode.getFirstToken(parent, { skip: 1 }));
      return false;
    }
    function isLastInOneLinerClassBody(node) {
      const parent = node.parent;
      const nextToken = sourceCode.getTokenAfter(node);
      if (!nextToken || nextToken.value !== "}") return false;
      if (parent.type === "ClassBody") return isSingleLine(parent);
      return false;
    }
    function checkForSemicolon(node) {
      const isSemi = (0, ast_exports.isSemicolonToken)(sourceCode.getLastToken(node));
      if (never) {
        const nextToken = sourceCode.getTokenAfter(node);
        if (isSemi && canRemoveSemicolon(node)) report(node, true);
        else if (!isSemi && beforeStatementContinuationChars === "always" && node.type !== "PropertyDefinition" && maybeAsiHazardBefore(nextToken)) report(node);
      } else {
        const oneLinerBlock = exceptOneLine && isLastInOneLinerBlock(node);
        const oneLinerClassBody = exceptOneLineClassBody && isLastInOneLinerClassBody(node);
        const oneLinerBlockOrClassBody = oneLinerBlock || oneLinerClassBody;
        if (isSemi && oneLinerBlockOrClassBody) report(node, true);
        else if (!isSemi && !oneLinerBlockOrClassBody) report(node);
      }
    }
    return {
      VariableDeclaration(node) {
        const parent = node.parent;
        if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) checkForSemicolon(node);
      },
      ExpressionStatement: checkForSemicolon,
      ReturnStatement: checkForSemicolon,
      ThrowStatement: checkForSemicolon,
      DoWhileStatement: checkForSemicolon,
      DebuggerStatement: checkForSemicolon,
      BreakStatement: checkForSemicolon,
      ContinueStatement: checkForSemicolon,
      ImportDeclaration: checkForSemicolon,
      ExportAllDeclaration: checkForSemicolon,
      ExportNamedDeclaration(node) {
        if (!node.declaration) checkForSemicolon(node);
      },
      ExportDefaultDeclaration(node) {
        if (node.declaration.type === import_types.AST_NODE_TYPES.TSInterfaceDeclaration) return;
        if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) checkForSemicolon(node);
      },
      PropertyDefinition: checkForSemicolon,
      AccessorProperty: checkForSemicolon,
      TSAbstractPropertyDefinition: checkForSemicolon,
      TSDeclareFunction: checkForSemicolon,
      TSExportAssignment: checkForSemicolon,
      TSImportEqualsDeclaration: checkForSemicolon,
      TSTypeAliasDeclaration: checkForSemicolon,
      TSEmptyBodyFunctionExpression: checkForSemicolon
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/space-before-blocks.js
var space_before_blocks_default = createRule({
  name: "space-before-blocks",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before blocks" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        keywords: {
          type: "string",
          enum: [
            "always",
            "never",
            "off"
          ]
        },
        functions: {
          type: "string",
          enum: [
            "always",
            "never",
            "off"
          ]
        },
        classes: {
          type: "string",
          enum: [
            "always",
            "never",
            "off"
          ]
        },
        modules: {
          type: "string",
          enum: [
            "always",
            "never",
            "off"
          ]
        }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["always"],
    messages: {
      unexpectedSpace: "Unexpected space before opening brace.",
      missingSpace: "Missing space before opening brace."
    }
  },
  create(context, [config]) {
    const sourceCode = context.sourceCode;
    let alwaysFunctions = true;
    let alwaysKeywords = true;
    let alwaysClasses = true;
    let alwaysModules = true;
    let neverFunctions = false;
    let neverKeywords = false;
    let neverClasses = false;
    let neverModules = false;
    if (typeof config === "object") {
      alwaysFunctions = config.functions === "always";
      alwaysKeywords = config.keywords === "always";
      alwaysClasses = config.classes === "always";
      alwaysModules = config.modules === "always";
      neverFunctions = config.functions === "never";
      neverKeywords = config.keywords === "never";
      neverClasses = config.classes === "never";
      neverModules = config.modules === "never";
    } else if (config === "never") {
      alwaysFunctions = false;
      alwaysKeywords = false;
      alwaysClasses = false;
      alwaysModules = false;
      neverFunctions = true;
      neverKeywords = true;
      neverClasses = true;
      neverModules = true;
    }
    function isFunctionBody(node) {
      if (!("parent" in node)) return false;
      const parent = node.parent;
      return node.type === "BlockStatement" && (0, ast_exports.isFunction)(parent) && parent.body === node;
    }
    function isConflicted(precedingToken, node) {
      return (0, ast_exports.isArrowToken)(precedingToken) || isKeywordToken(precedingToken) && !isFunctionBody(node) || (0, ast_exports.isColonToken)(precedingToken) && "parent" in node && node.parent && node.parent.type === "SwitchCase" && precedingToken === getSwitchCaseColonToken(node.parent, sourceCode);
    }
    function checkPrecedingSpace(node) {
      const precedingToken = sourceCode.getTokenBefore(node);
      if (precedingToken && !isConflicted(precedingToken, node) && (0, ast_exports.isTokenOnSameLine)(precedingToken, node)) {
        const hasSpace = sourceCode.isSpaceBetween(precedingToken, node);
        let requireSpace;
        let requireNoSpace;
        if (isFunctionBody(node)) {
          requireSpace = alwaysFunctions;
          requireNoSpace = neverFunctions;
        } else if (node.type === "ClassBody" || node.type === "TSEnumBody" || node.type === "TSInterfaceBody") {
          requireSpace = alwaysClasses;
          requireNoSpace = neverClasses;
        } else if (node.type === "TSModuleBlock") {
          requireSpace = alwaysModules;
          requireNoSpace = neverModules;
        } else {
          requireSpace = alwaysKeywords;
          requireNoSpace = neverKeywords;
        }
        if (requireSpace && !hasSpace) context.report({
          node,
          messageId: "missingSpace",
          fix(fixer) {
            return fixer.insertTextBefore(node, " ");
          }
        });
        else if (requireNoSpace && hasSpace) context.report({
          node,
          messageId: "unexpectedSpace",
          fix(fixer) {
            return fixer.removeRange([precedingToken.range[1], node.range[0]]);
          }
        });
      }
    }
    return {
      BlockStatement: checkPrecedingSpace,
      ClassBody: checkPrecedingSpace,
      SwitchStatement(node) {
        const cases = node.cases;
        let openingBrace;
        if (cases.length > 0) openingBrace = sourceCode.getTokenBefore(cases[0]);
        else openingBrace = sourceCode.getLastToken(node, 1);
        checkPrecedingSpace(openingBrace);
      },
      TSEnumBody: checkPrecedingSpace,
      TSInterfaceBody: checkPrecedingSpace,
      TSModuleBlock: checkPrecedingSpace
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/space-before-function-paren.js
var space_before_function_paren_default = createRule({
  name: "space-before-function-paren",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before function parenthesis" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        anonymous: {
          type: "string",
          enum: [
            "always",
            "never",
            "ignore"
          ]
        },
        named: {
          type: "string",
          enum: [
            "always",
            "never",
            "ignore"
          ]
        },
        asyncArrow: {
          type: "string",
          enum: [
            "always",
            "never",
            "ignore"
          ]
        },
        catch: {
          type: "string",
          enum: [
            "always",
            "never",
            "ignore"
          ]
        }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["always"],
    messages: {
      unexpectedSpace: "Unexpected space before function parentheses.",
      missingSpace: "Missing space before function parentheses."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const { asyncArrow = "always", anonymous = "always", named = "always", catch: catchOption = "always" } = typeof options === "string" ? {
      asyncArrow: options,
      anonymous: options,
      named: options,
      catch: options
    } : options;
    function isNamedFunction(node) {
      if (node.id != null) return true;
      const parent = node.parent;
      return parent.type === import_types.AST_NODE_TYPES.MethodDefinition || parent.type === import_types.AST_NODE_TYPES.TSAbstractMethodDefinition || parent.type === import_types.AST_NODE_TYPES.Property && (parent.kind === "get" || parent.kind === "set" || parent.method);
    }
    function getConfigForFunction(node) {
      if (node.type === import_types.AST_NODE_TYPES.ArrowFunctionExpression) {
        if (node.async && (0, ast_exports.isOpeningParenToken)(sourceCode.getFirstToken(node, { skip: 1 }))) return asyncArrow;
      } else if (isNamedFunction(node)) return named;
      else if (!node.generator) return anonymous;
      return "ignore";
    }
    function checkFunction(node) {
      const functionConfig = getConfigForFunction(node);
      if (functionConfig === "ignore") return;
      if (functionConfig === "always" && node.typeParameters && !node.id) return;
      let leftToken;
      let rightToken;
      if (node.typeParameters) {
        leftToken = sourceCode.getLastToken(node.typeParameters);
        rightToken = sourceCode.getTokenAfter(leftToken);
      } else {
        rightToken = sourceCode.getFirstToken(node, ast_exports.isOpeningParenToken);
        leftToken = sourceCode.getTokenBefore(rightToken);
      }
      checkSpace(node, leftToken, rightToken, functionConfig);
    }
    function checkSpace(node, leftToken, rightToken, option) {
      const hasSpacing = sourceCode.isSpaceBetween(leftToken, rightToken);
      if (hasSpacing && option === "never") context.report({
        node,
        loc: {
          start: leftToken.loc.end,
          end: rightToken.loc.start
        },
        messageId: "unexpectedSpace",
        fix: (fixer) => {
          const comments = sourceCode.getCommentsBefore(rightToken);
          if (comments.some((comment) => comment.type === "Line")) return null;
          return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
        }
      });
      else if (!hasSpacing && option === "always") context.report({
        node,
        loc: rightToken.loc,
        messageId: "missingSpace",
        fix: (fixer) => fixer.insertTextAfter(leftToken, " ")
      });
    }
    return {
      ArrowFunctionExpression: checkFunction,
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction,
      TSEmptyBodyFunctionExpression: checkFunction,
      TSDeclareFunction: checkFunction,
      CatchClause(node) {
        if (!node.param) return;
        const option = catchOption;
        if (catchOption === "ignore") return;
        const rightToken = sourceCode.getFirstToken(node, ast_exports.isOpeningParenToken);
        checkSpace(node, sourceCode.getTokenBefore(rightToken), rightToken, option);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/space-in-parens.js
var space_in_parens_default = createRule({
  name: "space-in-parens",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing inside parentheses" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: { exceptions: {
        type: "array",
        items: {
          type: "string",
          enum: [
            "{}",
            "[]",
            "()",
            "empty"
          ]
        },
        uniqueItems: true
      } },
      additionalProperties: false
    }],
    defaultOptions: ["never"],
    messages: {
      missingOpeningSpace: "There must be a space after this paren.",
      missingClosingSpace: "There must be a space before this paren.",
      rejectedOpeningSpace: "There should be no space after this paren.",
      rejectedClosingSpace: "There should be no space before this paren."
    }
  },
  create(context, [style, { exceptions: exceptionsArrayOptions = [] } = {}]) {
    const ALWAYS = style === "always";
    const options = {
      braceException: false,
      bracketException: false,
      parenException: false,
      empty: false
    };
    let exceptions = {
      openers: [],
      closers: []
    };
    if (exceptionsArrayOptions.length) {
      options.braceException = exceptionsArrayOptions.includes("{}");
      options.bracketException = exceptionsArrayOptions.includes("[]");
      options.parenException = exceptionsArrayOptions.includes("()");
      options.empty = exceptionsArrayOptions.includes("empty");
    }
    function getExceptions() {
      const openers = [];
      const closers = [];
      if (options.braceException) {
        openers.push("{");
        closers.push("}");
      }
      if (options.bracketException) {
        openers.push("[");
        closers.push("]");
      }
      if (options.parenException) {
        openers.push("(");
        closers.push(")");
      }
      if (options.empty) {
        openers.push(")");
        closers.push("(");
      }
      return {
        openers,
        closers
      };
    }
    const sourceCode = context.sourceCode;
    function isOpenerException(token) {
      return exceptions.openers.includes(token.value);
    }
    function isCloserException(token) {
      return exceptions.closers.includes(token.value);
    }
    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {
      if (sourceCode.isSpaceBetween(openingParenToken, tokenAfterOpeningParen)) return false;
      if (!options.empty && (0, ast_exports.isClosingParenToken)(tokenAfterOpeningParen)) return false;
      if (ALWAYS) return !isOpenerException(tokenAfterOpeningParen);
      return isOpenerException(tokenAfterOpeningParen);
    }
    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {
      if (!(0, ast_exports.isTokenOnSameLine)(openingParenToken, tokenAfterOpeningParen)) return false;
      if (tokenAfterOpeningParen.type === "Line") return false;
      if (!sourceCode.isSpaceBetween(openingParenToken, tokenAfterOpeningParen)) return false;
      if (ALWAYS) return isOpenerException(tokenAfterOpeningParen);
      return !isOpenerException(tokenAfterOpeningParen);
    }
    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {
      if (sourceCode.isSpaceBetween(tokenBeforeClosingParen, closingParenToken)) return false;
      if (!options.empty && (0, ast_exports.isOpeningParenToken)(tokenBeforeClosingParen)) return false;
      if (ALWAYS) return !isCloserException(tokenBeforeClosingParen);
      return isCloserException(tokenBeforeClosingParen);
    }
    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {
      if (!(0, ast_exports.isTokenOnSameLine)(tokenBeforeClosingParen, closingParenToken)) return false;
      if (!sourceCode.isSpaceBetween(tokenBeforeClosingParen, closingParenToken)) return false;
      if (ALWAYS) return isCloserException(tokenBeforeClosingParen);
      return !isCloserException(tokenBeforeClosingParen);
    }
    return { Program: function checkParenSpaces(node) {
      exceptions = getExceptions();
      const tokens = sourceCode.tokensAndComments;
      tokens.forEach((token, i) => {
        const prevToken = tokens[i - 1];
        const nextToken = tokens[i + 1];
        if (!(0, ast_exports.isOpeningParenToken)(token) && !(0, ast_exports.isClosingParenToken)(token)) return;
        if (token.value === "(" && openerMissingSpace(token, nextToken)) context.report({
          node,
          loc: token.loc,
          messageId: "missingOpeningSpace",
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
        if (token.value === "(" && openerRejectsSpace(token, nextToken)) context.report({
          node,
          loc: {
            start: token.loc.end,
            end: nextToken.loc.start
          },
          messageId: "rejectedOpeningSpace",
          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
        if (token.value === ")" && closerMissingSpace(prevToken, token)) context.report({
          node,
          loc: token.loc,
          messageId: "missingClosingSpace",
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
        if (token.value === ")" && closerRejectsSpace(prevToken, token)) context.report({
          node,
          loc: {
            start: prevToken.loc.end,
            end: token.loc.start
          },
          messageId: "rejectedClosingSpace",
          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], token.range[0]]);
          }
        });
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/space-infix-ops.js
var UNIONS = ["|", "&"];
var space_infix_ops_default = createRule({
  name: "space-infix-ops",
  meta: {
    type: "layout",
    docs: { description: "Require spacing around infix operators" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        int32Hint: { type: "boolean" },
        ignoreTypes: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      int32Hint: false,
      ignoreTypes: false
    }],
    messages: { missingSpace: "Operator '{{operator}}' must be spaced." }
  },
  create(context, [options]) {
    const { int32Hint, ignoreTypes } = options;
    const sourceCode = context.sourceCode;
    function report(node, operator) {
      context.report({
        node,
        loc: operator.loc,
        messageId: "missingSpace",
        data: { operator: operator.value },
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(operator);
          const afterToken = sourceCode.getTokenAfter(operator);
          let fixString = "";
          if (operator.range[0] - previousToken.range[1] === 0) fixString = " ";
          fixString += operator.value;
          if (afterToken.range[0] - operator.range[1] === 0) fixString += " ";
          return fixer.replaceText(operator, fixString);
        }
      });
    }
    function getFirstNonSpacedToken(left, right, op) {
      const operator = sourceCode.getFirstTokenBetween(left, right, (token) => token.value === op);
      const prev = sourceCode.getTokenBefore(operator);
      const next = sourceCode.getTokenAfter(operator);
      if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) return operator;
      return null;
    }
    function checkBinary(node) {
      const leftNode = "typeAnnotation" in node.left && node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
      const rightNode = node.right;
      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, "operator" in node && node.operator ? node.operator : "=");
      if (nonSpacedNode) {
        if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) report(node, nonSpacedNode);
      }
    }
    function isSpaceChar(token) {
      return token.type === import_types.AST_TOKEN_TYPES.Punctuator && /^[=?:]$/.test(token.value);
    }
    function checkAndReportAssignmentSpace(node, leftNode, rightNode) {
      if (!rightNode || !leftNode) return;
      const operator = sourceCode.getFirstTokenBetween(leftNode, rightNode, isSpaceChar);
      const prev = sourceCode.getTokenBefore(operator);
      const next = sourceCode.getTokenAfter(operator);
      if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) report(node, operator);
    }
    function checkPropertyAssignment(node) {
      checkAndReportAssignmentSpace(node, node.optional && !node.typeAnnotation ? sourceCode.getTokenAfter(node.key) : node.typeAnnotation ?? node.key, node.value);
    }
    function checkTSBinary(typeAnnotation) {
      typeAnnotation.types.forEach((type) => {
        const skipFunctionParenthesis = type.type === import_types.AST_NODE_TYPES.TSFunctionType ? ast_exports.isNotOpeningParenToken : 0;
        const operator = sourceCode.getTokenBefore(type, skipFunctionParenthesis);
        if (!ignoreTypes && operator != null && UNIONS.includes(operator.value)) {
          const prev = sourceCode.getTokenBefore(operator);
          const next = sourceCode.getTokenAfter(operator);
          if (!sourceCode.isSpaceBetween(prev, operator) || !sourceCode.isSpaceBetween(operator, next)) report(typeAnnotation, operator);
        }
      });
    }
    return {
      AssignmentExpression: checkBinary,
      AssignmentPattern: checkBinary,
      BinaryExpression: checkBinary,
      LogicalExpression: checkBinary,
      ConditionalExpression(node) {
        checkAndReportAssignmentSpace(node, node.test, node.consequent);
        checkAndReportAssignmentSpace(node, node.consequent, node.alternate);
      },
      VariableDeclarator(node) {
        checkAndReportAssignmentSpace(node, node.id.typeAnnotation ?? node.id, node.init);
      },
      PropertyDefinition: checkPropertyAssignment,
      AccessorProperty: checkPropertyAssignment,
      TSEnumMember(node) {
        checkAndReportAssignmentSpace(node, node.id, node.initializer);
      },
      TSTypeAliasDeclaration(node) {
        checkAndReportAssignmentSpace(node, node.typeParameters ?? node.id, node.typeAnnotation);
      },
      TSUnionType: checkTSBinary,
      TSIntersectionType: checkTSBinary,
      TSConditionalType(node) {
        checkAndReportAssignmentSpace(node, node.extendsType, node.trueType);
        checkAndReportAssignmentSpace(node, node.trueType, node.falseType);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/space-unary-ops.js
var space_unary_ops_default = createRule({
  name: "space-unary-ops",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing before or after unary operators" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        words: { type: "boolean" },
        nonwords: { type: "boolean" },
        overrides: {
          type: "object",
          additionalProperties: { type: "boolean" }
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      words: true,
      nonwords: false
    }],
    messages: {
      unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
      unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
      unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
      requireAfterWord: "Unary word operator '{{word}}' must be followed by whitespace.",
      requireAfter: "Unary operator '{{operator}}' must be followed by whitespace.",
      requireBefore: "Space is required before unary operator '{{operator}}'."
    }
  },
  create(context, [options]) {
    const { words, nonwords, overrides = {} } = options;
    const sourceCode = context.sourceCode;
    function isFirstBangInBangBangExpression(node) {
      return node && node.type === "UnaryExpression" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }
    function verifyWordHasSpaces(node, firstToken, secondToken, word) {
      if (secondToken.range[0] === firstToken.range[1]) context.report({
        node,
        messageId: "requireAfterWord",
        data: { word },
        fix(fixer) {
          return fixer.insertTextAfter(firstToken, " ");
        }
      });
    }
    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
      if (canTokensBeAdjacent(firstToken, secondToken)) {
        if (secondToken.range[0] > firstToken.range[1]) context.report({
          node,
          messageId: "unexpectedAfterWord",
          data: { word },
          fix(fixer) {
            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
          }
        });
      }
    }
    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
      if (overrides[word] ?? words) verifyWordHasSpaces(node, firstToken, secondToken, word);
      else verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
    }
    function checkForSpacesAroundNonNull(node) {
      const operator = "!";
      const operatorToken = sourceCode.getLastToken(node, (token) => token.value === operator);
      const prefixToken = sourceCode.getTokenBefore(operatorToken);
      if (overrides[operator] ?? nonwords) verifyNonWordsHaveSpaces(node, prefixToken, operatorToken);
      else verifyNonWordsDontHaveSpaces(node, prefixToken, operatorToken);
    }
    function checkForSpacesAfterYield(node) {
      const tokens = sourceCode.getFirstTokens(node, 3);
      const word = "yield";
      if (!node.argument || node.delegate) return;
      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
    }
    function checkForSpacesAfterAwait(node) {
      const tokens = sourceCode.getFirstTokens(node, 3);
      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
    }
    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
      if ("prefix" in node && node.prefix) {
        if (isFirstBangInBangBangExpression(node)) return;
        if (firstToken.range[1] === secondToken.range[0]) context.report({
          node,
          messageId: "requireAfter",
          data: { operator: firstToken.value },
          fix(fixer) {
            return fixer.insertTextAfter(firstToken, " ");
          }
        });
      } else if (firstToken.range[1] === secondToken.range[0]) context.report({
        node,
        messageId: "requireBefore",
        data: { operator: secondToken.value },
        fix(fixer) {
          return fixer.insertTextBefore(secondToken, " ");
        }
      });
    }
    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
      if ("prefix" in node && node.prefix) {
        if (secondToken.range[0] > firstToken.range[1]) context.report({
          node,
          messageId: "unexpectedAfter",
          data: { operator: firstToken.value },
          fix(fixer) {
            if (canTokensBeAdjacent(firstToken, secondToken)) return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            return null;
          }
        });
      } else if (secondToken.range[0] > firstToken.range[1]) context.report({
        node,
        messageId: "unexpectedBefore",
        data: { operator: secondToken.value },
        fix(fixer) {
          return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
        }
      });
    }
    function checkForSpaces(node) {
      const tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
      const firstToken = tokens[0];
      const secondToken = tokens[1];
      if ((node.type === "NewExpression" || node.prefix) && isKeywordToken(firstToken)) {
        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
        return;
      }
      if (overrides["prefix" in node && node.prefix ? tokens[0].value : tokens[1].value] ?? nonwords) verifyNonWordsHaveSpaces(node, firstToken, secondToken);
      else verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
    }
    return {
      UnaryExpression: checkForSpaces,
      UpdateExpression: checkForSpaces,
      NewExpression: checkForSpaces,
      YieldExpression: checkForSpacesAfterYield,
      AwaitExpression: checkForSpacesAfterAwait,
      TSNonNullExpression: checkForSpacesAroundNonNull
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/spaced-comment.js
function escape(s) {
  return `(?:${escapeStringRegexp(s)})`;
}
function escapeAndRepeat(s) {
  return `${escape(s)}+`;
}
function parseMarkersOption(markers) {
  if (!markers.includes("*")) return markers.concat("*");
  return markers;
}
function createExceptionsPattern(exceptions) {
  let pattern = "";
  if (exceptions.length === 0) pattern += "\\s";
  else {
    pattern += "(?:\\s|";
    if (exceptions.length === 1) pattern += escapeAndRepeat(exceptions[0]);
    else {
      pattern += "(?:";
      pattern += exceptions.map(escapeAndRepeat).join("|");
      pattern += ")";
    }
    pattern += `(?:$|[${Array.from(LINEBREAKS).join("")}]))`;
  }
  return pattern;
}
function createAlwaysStylePattern(markers, exceptions) {
  let pattern = "^";
  if (markers.length === 1) pattern += escape(markers[0]);
  else {
    pattern += "(?:";
    pattern += markers.map(escape).join("|");
    pattern += ")";
  }
  pattern += "?";
  pattern += createExceptionsPattern(exceptions);
  return new RegExp(pattern, "u");
}
function createNeverStylePattern(markers) {
  const pattern = `^(${markers.map(escape).join("|")})?[ 	]+`;
  return new RegExp(pattern, "u");
}
var spaced_comment_default = createRule({
  name: "spaced-comment",
  meta: {
    type: "layout",
    docs: { description: "Enforce consistent spacing after the `//` or `/*` in a comment" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: { type: "string" }
        },
        markers: {
          type: "array",
          items: { type: "string" }
        },
        line: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" }
            },
            markers: {
              type: "array",
              items: { type: "string" }
            }
          },
          additionalProperties: false
        },
        block: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" }
            },
            markers: {
              type: "array",
              items: { type: "string" }
            },
            balanced: { type: "boolean" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    defaultOptions: ["always"],
    messages: {
      unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
      expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
      unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
      unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
      expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
      expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
    }
  },
  create(context, [style, config = {}]) {
    const sourceCode = context.sourceCode;
    const requireSpace = style !== "never";
    const balanced = config.block && config.block.balanced;
    const styleRules = ["block", "line"].reduce((rule, type) => {
      const nodeType = type;
      const markers = parseMarkersOption(config[nodeType] && config[nodeType]?.markers || config.markers || []);
      const exceptions = config[nodeType] && config[nodeType]?.exceptions || config.exceptions || [];
      rule[nodeType] = {
        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, "u") : /* @__PURE__ */ new RegExp("[ 	]+$", "u"),
        hasExceptions: exceptions.length > 0,
        captureMarker: new RegExp(`^(${markers.map(escape).join("|")})`, "u"),
        markers: new Set(markers)
      };
      return rule;
    }, {});
    function reportBegin(node, messageId, match, refChar) {
      const commentIdentifier = node.type.toLowerCase() === "block" ? "/*" : "//";
      context.report({
        node,
        fix(fixer) {
          const start = node.range[0];
          let end = start + 2;
          if (requireSpace) {
            if (match) end += match[0].length;
            return fixer.insertTextAfterRange([start, end], " ");
          }
          if (match) end += match[0].length;
          return fixer.replaceTextRange([start, end], commentIdentifier + (match && match[1] ? match[1] : ""));
        },
        messageId,
        data: { refChar }
      });
    }
    function reportEnd(node, messageId, match) {
      context.report({
        node,
        fix(fixer) {
          if (requireSpace) return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
          const end = node.range[1] - 2;
          let start = end;
          if (match) start -= match[0].length;
          return fixer.replaceTextRange([start, end], "");
        },
        messageId
      });
    }
    function checkCommentForSpace(node) {
      const type = node.type.toLowerCase();
      const rule = styleRules[type];
      const commentIdentifier = type === "block" ? "/*" : "//";
      if (node.value.length === 0 || rule.markers.has(node.value)) return;
      if (type === "line" && (node.value.startsWith("/ <reference") || node.value.startsWith("/ <amd"))) return;
      const beginMatch = rule.beginRegex.exec(node.value);
      const endMatch = rule.endRegex.exec(node.value);
      if (requireSpace) {
        if (!beginMatch) {
          const hasMarker = rule.captureMarker.exec(node.value);
          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
          if (rule.hasExceptions) reportBegin(node, "expectedExceptionAfter", hasMarker, marker);
          else reportBegin(node, "expectedSpaceAfter", hasMarker, marker);
        }
        if (balanced && type === "block" && !endMatch) reportEnd(node, "expectedSpaceBefore", null);
      } else {
        if (beginMatch) if (!beginMatch[1]) reportBegin(node, "unexpectedSpaceAfter", beginMatch, commentIdentifier);
        else reportBegin(node, "unexpectedSpaceAfterMarker", beginMatch, beginMatch[1]);
        if (balanced && type === "block" && endMatch) reportEnd(node, "unexpectedSpaceBefore", endMatch);
      }
    }
    return { Program() {
      sourceCode.getAllComments().forEach((comment) => {
        if (!isHashbangComment(comment)) checkCommentForSpace(comment);
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/switch-colon-spacing.js
var switch_colon_spacing_default = createRule({
  name: "switch-colon-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforce spacing around colons of switch statements" },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" }
      },
      additionalProperties: false
    }],
    defaultOptions: [{
      before: false,
      after: true
    }],
    messages: {
      expectedBefore: "Expected space(s) before this colon.",
      expectedAfter: "Expected space(s) after this colon.",
      unexpectedBefore: "Unexpected space(s) before this colon.",
      unexpectedAfter: "Unexpected space(s) after this colon."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const beforeSpacing = options.before === true;
    const afterSpacing = options.after !== false;
    function isValidSpacing(left, right, expected) {
      return (0, ast_exports.isClosingBraceToken)(right) || !(0, ast_exports.isTokenOnSameLine)(left, right) || sourceCode.isSpaceBetween(left, right) === expected;
    }
    function fix(fixer, left, right, spacing) {
      if (sourceCode.commentsExistBetween(left, right)) return null;
      if (spacing) return fixer.insertTextAfter(left, " ");
      return fixer.removeRange([left.range[1], right.range[0]]);
    }
    return { SwitchCase(node) {
      const colonToken = getSwitchCaseColonToken(node, sourceCode);
      const beforeToken = sourceCode.getTokenBefore(colonToken);
      const afterToken = sourceCode.getTokenAfter(colonToken);
      if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) context.report({
        node,
        loc: colonToken.loc,
        messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
        fix: (fixer) => fix(fixer, beforeToken, colonToken, beforeSpacing)
      });
      if (!isValidSpacing(colonToken, afterToken, afterSpacing)) context.report({
        node,
        loc: colonToken.loc,
        messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
        fix: (fixer) => fix(fixer, colonToken, afterToken, afterSpacing)
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/template-curly-spacing.js
var template_curly_spacing_default = createRule({
  name: "template-curly-spacing",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow spacing around embedded expressions of template strings" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["never"],
    messages: {
      expectedBefore: "Expected space(s) before '}'.",
      expectedAfter: "Expected space(s) after '${'.",
      unexpectedBefore: "Unexpected space(s) before '}'.",
      unexpectedAfter: "Unexpected space(s) after '${'."
    }
  },
  create(context, [style]) {
    const sourceCode = context.sourceCode;
    const always = style === "always";
    function checkSpacingBefore(token) {
      if (!token.value.startsWith("}")) return;
      const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });
      const hasSpace = sourceCode.isSpaceBetween(prevToken, token);
      if (!(0, ast_exports.isTokenOnSameLine)(prevToken, token)) return;
      if (always && !hasSpace) context.report({
        loc: {
          start: token.loc.start,
          end: {
            line: token.loc.start.line,
            column: token.loc.start.column + 1
          }
        },
        messageId: "expectedBefore",
        fix: (fixer) => fixer.insertTextBefore(token, " ")
      });
      if (!always && hasSpace) context.report({
        loc: {
          start: prevToken.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedBefore",
        fix: (fixer) => fixer.removeRange([prevToken.range[1], token.range[0]])
      });
    }
    function checkSpacingAfter(token) {
      if (!token.value.endsWith("${")) return;
      const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
      const hasSpace = sourceCode.isSpaceBetween(token, nextToken);
      if (!(0, ast_exports.isTokenOnSameLine)(token, nextToken)) return;
      if (always && !hasSpace) context.report({
        loc: {
          start: {
            line: token.loc.end.line,
            column: token.loc.end.column - 2
          },
          end: token.loc.end
        },
        messageId: "expectedAfter",
        fix: (fixer) => fixer.insertTextAfter(token, " ")
      });
      if (!always && hasSpace) context.report({
        loc: {
          start: token.loc.end,
          end: nextToken.loc.start
        },
        messageId: "unexpectedAfter",
        fix: (fixer) => fixer.removeRange([token.range[1], nextToken.range[0]])
      });
    }
    return { TemplateElement(node) {
      const token = sourceCode.getFirstToken(node);
      checkSpacingBefore(token);
      checkSpacingAfter(token);
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/template-tag-spacing.js
var template_tag_spacing_default = createRule({
  name: "template-tag-spacing",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow spacing between template tags and their literals" },
    fixable: "whitespace",
    schema: [{
      type: "string",
      enum: ["always", "never"]
    }],
    defaultOptions: ["never"],
    messages: {
      unexpected: "Unexpected space between template tag and template literal.",
      missing: "Missing space between template tag and template literal."
    }
  },
  create(context, [style]) {
    const never = style !== "always";
    const sourceCode = context.sourceCode;
    function checkSpacing(node) {
      const tagToken = sourceCode.getTokenBefore(node.quasi);
      const literalToken = sourceCode.getFirstToken(node.quasi);
      const hasWhitespace = sourceCode.isSpaceBetween(tagToken, literalToken);
      if (never && hasWhitespace) context.report({
        node,
        loc: {
          start: tagToken.loc.end,
          end: literalToken.loc.start
        },
        messageId: "unexpected",
        fix(fixer) {
          const comments = sourceCode.getCommentsBefore(node.quasi);
          if (comments.some((comment) => comment.type === "Line")) return null;
          return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
        }
      });
      else if (!never && !hasWhitespace) context.report({
        node,
        loc: {
          start: node.loc.start,
          end: literalToken.loc.start
        },
        messageId: "missing",
        fix(fixer) {
          return fixer.insertTextAfter(tagToken, " ");
        }
      });
    }
    return { TaggedTemplateExpression: checkSpacing };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/type-annotation-spacing.js
function createRules(options) {
  const globals = {
    ...options?.before !== void 0 ? { before: options.before } : {},
    ...options?.after !== void 0 ? { after: options.after } : {}
  };
  const override = options?.overrides ?? {};
  const colon = {
    before: false,
    after: true,
    ...globals,
    ...override?.colon
  };
  const arrow = typeof override.arrow === "string" ? override.arrow : {
    before: true,
    after: true,
    ...globals,
    ...override?.arrow
  };
  if (Object.hasOwn(override, "arrow") && override.arrow !== "ignore") warnDeprecation('options("overrides.arrow")', '"arrow-spacing"', "type-annotation-spacing");
  return {
    colon,
    arrow,
    variable: {
      ...colon,
      ...override?.variable
    },
    property: {
      ...colon,
      ...override?.property
    },
    parameter: {
      ...colon,
      ...override?.parameter
    },
    returnType: {
      ...colon,
      ...override?.returnType
    }
  };
}
function getIdentifierRules(rules, node) {
  const scope = node?.parent;
  if ((0, ast_exports.isVariableDeclarator)(scope)) return rules.variable;
  else if ((0, ast_exports.isFunctionOrFunctionType)(scope)) return rules.parameter;
  return rules.colon;
}
function getRules(rules, node) {
  const scope = node?.parent?.parent;
  if ((0, ast_exports.isTSFunctionType)(scope) || (0, ast_exports.isTSConstructorType)(scope)) return rules.arrow;
  else if ((0, ast_exports.isIdentifier)(scope)) return getIdentifierRules(rules, scope);
  else if ((0, ast_exports.isClassOrTypeElement)(scope)) return rules.property;
  else if ((0, ast_exports.isFunction)(scope)) return rules.returnType;
  return rules.colon;
}
var type_annotation_spacing_default = createRule({
  name: "type-annotation-spacing",
  meta: {
    type: "layout",
    docs: { description: "Require consistent spacing around type annotations" },
    fixable: "whitespace",
    schema: [{
      $defs: { spacingConfig: {
        type: "object",
        properties: {
          before: { type: "boolean" },
          after: { type: "boolean" }
        },
        additionalProperties: false
      } },
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" },
        overrides: {
          type: "object",
          properties: {
            colon: { $ref: "#/items/0/$defs/spacingConfig" },
            arrow: { oneOf: [{
              type: "string",
              enum: ["ignore"]
            }, { $ref: "#/items/0/$defs/spacingConfig" }] },
            variable: { $ref: "#/items/0/$defs/spacingConfig" },
            parameter: { $ref: "#/items/0/$defs/spacingConfig" },
            property: { $ref: "#/items/0/$defs/spacingConfig" },
            returnType: { $ref: "#/items/0/$defs/spacingConfig" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    defaultOptions: [{}],
    messages: {
      expectedSpaceAfter: "Expected a space after the '{{type}}'.",
      expectedSpaceBefore: "Expected a space before the '{{type}}'.",
      unexpectedSpaceAfter: "Unexpected space after the '{{type}}'.",
      unexpectedSpaceBefore: "Unexpected space before the '{{type}}'.",
      unexpectedSpaceBetween: "Unexpected space between the '{{previousToken}}' and the '{{type}}'."
    }
  },
  create(context, [options]) {
    const punctuators = [":", "=>"];
    const sourceCode = context.sourceCode;
    const ruleSet = createRules(options);
    function checkTypeAnnotationSpacing(typeAnnotation) {
      const punctuatorTokenEnd = sourceCode.getTokenBefore(typeAnnotation, ast_exports.isNotOpeningParenToken);
      let punctuatorTokenStart = punctuatorTokenEnd;
      let previousToken = sourceCode.getTokenBefore(punctuatorTokenEnd);
      let type = punctuatorTokenEnd.value;
      if (!punctuators.includes(type)) return;
      const config = getRules(ruleSet, typeAnnotation);
      if (config === "ignore") return;
      const { before, after } = config;
      if (type === ":" && previousToken.value === "?") {
        if (sourceCode.isSpaceBetween(previousToken, punctuatorTokenStart)) context.report({
          node: punctuatorTokenStart,
          messageId: "unexpectedSpaceBetween",
          data: {
            type,
            previousToken: previousToken.value
          },
          fix(fixer) {
            return fixer.removeRange([previousToken.range[1], punctuatorTokenStart.range[0]]);
          }
        });
        type = "?:";
        punctuatorTokenStart = previousToken;
        previousToken = sourceCode.getTokenBefore(previousToken);
        if (previousToken.value === "+" || previousToken.value === "-") {
          type = `${previousToken.value}?:`;
          punctuatorTokenStart = previousToken;
          previousToken = sourceCode.getTokenBefore(previousToken);
        }
      }
      const hasNextSpace = sourceCode.isSpaceBetween(punctuatorTokenEnd, typeAnnotation);
      if (after && !hasNextSpace) context.report({
        node: punctuatorTokenEnd,
        messageId: "expectedSpaceAfter",
        data: { type },
        fix(fixer) {
          return fixer.insertTextAfter(punctuatorTokenEnd, " ");
        }
      });
      else if (!after && hasNextSpace) context.report({
        node: punctuatorTokenEnd,
        messageId: "unexpectedSpaceAfter",
        data: { type },
        fix(fixer) {
          return fixer.removeRange([punctuatorTokenEnd.range[1], typeAnnotation.range[0]]);
        }
      });
      const hasPrevSpace = sourceCode.isSpaceBetween(previousToken, punctuatorTokenStart);
      if (before && !hasPrevSpace) context.report({
        node: punctuatorTokenStart,
        messageId: "expectedSpaceBefore",
        data: { type },
        fix(fixer) {
          return fixer.insertTextAfter(previousToken, " ");
        }
      });
      else if (!before && hasPrevSpace) context.report({
        node: punctuatorTokenStart,
        messageId: "unexpectedSpaceBefore",
        data: { type },
        fix(fixer) {
          return fixer.removeRange([previousToken.range[1], punctuatorTokenStart.range[0]]);
        }
      });
    }
    return {
      TSMappedType(node) {
        if (node.typeAnnotation) checkTypeAnnotationSpacing(node.typeAnnotation);
      },
      TSTypeAnnotation(node) {
        checkTypeAnnotationSpacing(node.typeAnnotation);
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/type-generic-spacing.js
var PRESERVE_PREFIX_SPACE_BEFORE_GENERIC = /* @__PURE__ */ new Set([
  "TSCallSignatureDeclaration",
  "ArrowFunctionExpression",
  "TSFunctionType",
  "TSConstructorType",
  "FunctionExpression",
  "ClassExpression"
]);
var type_generic_spacing_default = createRule({
  name: "type-generic-spacing",
  meta: {
    type: "layout",
    docs: { description: "Enforces consistent spacing inside TypeScript type generics" },
    fixable: "whitespace",
    schema: [],
    messages: { genericSpacingMismatch: "Generic spaces mismatch" }
  },
  create: (context) => {
    const sourceCode = context.sourceCode;
    function removeSpaceBetween(left, right) {
      const textBetween = sourceCode.text.slice(left.range[1], right.range[0]);
      if (/\s/.test(textBetween) && !/^[\r\n]/.test(textBetween)) context.report({
        loc: {
          start: left.loc.end,
          end: right.loc.start
        },
        messageId: "genericSpacingMismatch",
        *fix(fixer) {
          yield fixer.replaceTextRange([left.range[1], right.range[0]], "");
        }
      });
    }
    function checkBracketSpacing(openToken, closeToken) {
      if (openToken) {
        const firstToken = sourceCode.getTokenAfter(openToken);
        if (firstToken) removeSpaceBetween(openToken, firstToken);
      }
      if (closeToken) {
        const lastToken = sourceCode.getTokenBefore(closeToken);
        if (lastToken) removeSpaceBetween(lastToken, closeToken);
      }
    }
    return {
      TSTypeParameterInstantiation: (node) => {
        const params = node.params;
        if (params.length === 0) return;
        checkBracketSpacing(sourceCode.getTokenBefore(params[0]), sourceCode.getTokenAfter(params[params.length - 1]));
      },
      TSTypeParameterDeclaration: (node) => {
        if (!PRESERVE_PREFIX_SPACE_BEFORE_GENERIC.has(node.parent.type)) {
          const preSpace = sourceCode.text.slice(0, node.range[0]).match(/(\s+)$/)?.[0];
          if (preSpace && preSpace.length) context.report({
            node,
            messageId: "genericSpacingMismatch",
            *fix(fixer) {
              yield fixer.replaceTextRange([node.range[0] - preSpace.length, node.range[0]], "");
            }
          });
        }
        const params = node.params;
        if (params.length === 0) return;
        checkBracketSpacing(sourceCode.getTokenBefore(params[0]), sourceCode.getTokenAfter(params[params.length - 1]));
      },
      TSTypeParameter: (node) => {
        if (!node.default) return;
        const endNode = node.constraint || node.name;
        const from = endNode.range[1];
        const to = node.default.range[0];
        const span = sourceCode.text.slice(from, to);
        if (!span.match(/(?:^|[^ ]) = (?:$|[^ ])/)) context.report({
          *fix(fixer) {
            yield fixer.replaceTextRange([from, to], span.replace(/\s*=\s*/, " = "));
          },
          loc: {
            start: endNode.loc.end,
            end: node.default.loc.start
          },
          messageId: "genericSpacingMismatch",
          node
        });
      }
    };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/type-named-tuple-spacing.js
var tupleRe = /^([\w$]+)(\s*)(\?\s*)?:(\s*)(.*)$/;
var type_named_tuple_spacing_default = createRule({
  name: "type-named-tuple-spacing",
  meta: {
    type: "layout",
    docs: { description: "Expect space before the type declaration in the named tuple" },
    fixable: "whitespace",
    schema: [],
    messages: {
      expectedSpaceAfter: "Expected a space after the ':'.",
      unexpectedSpaceBetween: "Unexpected space between '?' and the ':'.",
      unexpectedSpaceBefore: "Unexpected space before the ':'."
    }
  },
  create: (context) => {
    const sourceCode = context.sourceCode;
    return { TSNamedTupleMember(node) {
      const code = sourceCode.text.slice(node.range[0], node.range[1]);
      const match = code.match(tupleRe);
      if (!match) return;
      const labelName = node.label.name;
      const spaceBeforeColon = match[2];
      const optionalMark = match[3];
      const spacesAfterColon = match[4];
      const elementType = match[5];
      function getReplaceValue() {
        let ret = labelName;
        if (node.optional) ret += "?";
        ret += ": ";
        ret += elementType;
        return ret;
      }
      if (optionalMark?.length > 1) context.report({
        node,
        messageId: "unexpectedSpaceBetween",
        *fix(fixer) {
          yield fixer.replaceTextRange(node.range, code.replace(tupleRe, getReplaceValue()));
        }
      });
      if (spaceBeforeColon?.length) context.report({
        node,
        messageId: "unexpectedSpaceBefore",
        *fix(fixer) {
          yield fixer.replaceTextRange(node.range, code.replace(tupleRe, getReplaceValue()));
        }
      });
      if (spacesAfterColon != null && spacesAfterColon.length !== 1) context.report({
        node,
        messageId: "expectedSpaceAfter",
        *fix(fixer) {
          yield fixer.replaceTextRange(node.range, code.replace(tupleRe, getReplaceValue()));
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/wrap-iife.js
function isCalleeOfNewExpression(node) {
  const maybeCallee = node.parent?.type === "ChainExpression" ? node.parent : node;
  return maybeCallee.parent?.type === "NewExpression" && maybeCallee.parent.callee === maybeCallee;
}
var wrap_iife_default = createRule({
  name: "wrap-iife",
  meta: {
    type: "layout",
    docs: { description: "Require parentheses around immediate `function` invocations" },
    fixable: "code",
    schema: [{
      type: "string",
      enum: [
        "outside",
        "inside",
        "any"
      ]
    }, {
      type: "object",
      properties: { functionPrototypeMethods: { type: "boolean" } },
      additionalProperties: false
    }],
    defaultOptions: ["outside", { functionPrototypeMethods: false }],
    messages: {
      wrapInvocation: "Wrap an immediate function invocation in parentheses.",
      wrapExpression: "Wrap only the function expression in parens.",
      moveInvocation: "Move the invocation into the parens that contain the function."
    }
  },
  create(context, [style, options]) {
    const includeFunctionPrototypeMethods = options.functionPrototypeMethods;
    const sourceCode = context.sourceCode;
    function isWrappedInAnyParens(node) {
      return isParenthesised(sourceCode, node);
    }
    function isWrappedInGroupingParens(node) {
      return (0, ast_exports.isParenthesized)(node, sourceCode);
    }
    function getFunctionNodeFromIIFE(node) {
      const callee = skipChainExpression(node.callee);
      if (callee.type === "FunctionExpression") return callee;
      if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (getStaticPropertyName(callee) === "call" || getStaticPropertyName(callee) === "apply")) return callee.object;
      return null;
    }
    return { CallExpression(node) {
      const innerNode = getFunctionNodeFromIIFE(node);
      if (!innerNode) return;
      const isCallExpressionWrapped = isWrappedInAnyParens(node);
      const isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);
      if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) context.report({
        node,
        messageId: "wrapInvocation",
        fix(fixer) {
          const nodeToSurround = style === "inside" ? innerNode : node;
          return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
        }
      });
      else if (style === "inside" && !isFunctionExpressionWrapped) context.report({
        node,
        messageId: "wrapExpression",
        fix(fixer) {
          if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {
            const parenAfter = sourceCode.getTokenAfter(node);
            return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);
          }
          return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);
        }
      });
      else if (style === "outside" && !isCallExpressionWrapped) context.report({
        node,
        messageId: "moveInvocation",
        fix(fixer) {
          const parenAfter = sourceCode.getTokenAfter(innerNode);
          return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);
        }
      });
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/wrap-regex.js
var wrap_regex_default = createRule({
  name: "wrap-regex",
  meta: {
    type: "layout",
    docs: { description: "Require parenthesis around regex literals" },
    fixable: "code",
    schema: [],
    messages: { requireParens: "Wrap the regexp literal in parens to disambiguate the slash." }
  },
  create(context) {
    const sourceCode = context.sourceCode;
    return { Literal(node) {
      if (sourceCode.getFirstToken(node).type === "RegularExpression") {
        const beforeToken = sourceCode.getTokenBefore(node);
        const afterToken = sourceCode.getTokenAfter(node);
        const { parent } = node;
        if (parent.type === "MemberExpression" && parent.object === node && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) context.report({
          node,
          messageId: "requireParens",
          fix: (fixer) => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
        });
      }
    } };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/rules/yield-star-spacing.js
var yield_star_spacing_default = createRule({
  name: "yield-star-spacing",
  meta: {
    type: "layout",
    docs: { description: "Require or disallow spacing around the `*` in `yield*` expressions" },
    fixable: "whitespace",
    schema: [{ oneOf: [{
      type: "string",
      enum: [
        "before",
        "after",
        "both",
        "neither"
      ]
    }, {
      type: "object",
      properties: {
        before: { type: "boolean" },
        after: { type: "boolean" }
      },
      additionalProperties: false
    }] }],
    defaultOptions: ["after"],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(context, [options]) {
    const sourceCode = context.sourceCode;
    const mode = (() => {
      if (typeof options === "string") return {
        before: {
          before: true,
          after: false
        },
        after: {
          before: false,
          after: true
        },
        both: {
          before: true,
          after: true
        },
        neither: {
          before: false,
          after: false
        }
      }[options];
      return options;
    })();
    function checkSpacing(side, leftToken, rightToken) {
      if (sourceCode.isSpaceBetween(leftToken, rightToken) !== mode[side]) {
        const after = leftToken.value === "*";
        const spaceRequired = mode[side];
        const node = after ? leftToken : rightToken;
        const messageId = spaceRequired ? side === "before" ? "missingBefore" : "missingAfter" : side === "before" ? "unexpectedBefore" : "unexpectedAfter";
        context.report({
          node,
          messageId,
          fix(fixer) {
            if (spaceRequired) {
              if (after) return fixer.insertTextAfter(node, " ");
              return fixer.insertTextBefore(node, " ");
            }
            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }
        });
      }
    }
    function checkExpression(node) {
      if (!("delegate" in node && node.delegate)) return;
      const tokens = sourceCode.getFirstTokens(node, 3);
      const yieldToken = tokens[0];
      const starToken = tokens[1];
      const nextToken = tokens[2];
      checkSpacing("before", yieldToken, starToken);
      checkSpacing("after", starToken, nextToken);
    }
    return { YieldExpression: checkExpression };
  }
});

// node_modules/@stylistic/eslint-plugin/dist/configs.js
var plugin_default = {
  meta: {
    name: "@stylistic/eslint-plugin",
    version: "5.7.1",
    namespace: "@stylistic"
  },
  rules: {
    "array-bracket-newline": array_bracket_newline_default,
    "array-bracket-spacing": array_bracket_spacing_default,
    "array-element-newline": array_element_newline_default,
    "arrow-parens": arrow_parens_default,
    "arrow-spacing": arrow_spacing_default,
    "block-spacing": block_spacing_default,
    "brace-style": brace_style_default,
    "comma-dangle": comma_dangle_default,
    "comma-spacing": comma_spacing_default,
    "comma-style": comma_style_default,
    "computed-property-spacing": computed_property_spacing_default,
    "curly-newline": curly_newline_default,
    "dot-location": dot_location_default,
    "eol-last": eol_last_default,
    "function-call-argument-newline": function_call_argument_newline_default,
    "function-call-spacing": function_call_spacing_default,
    "function-paren-newline": function_paren_newline_default,
    "generator-star-spacing": generator_star_spacing_default,
    "implicit-arrow-linebreak": implicit_arrow_linebreak_default,
    "indent": indent_default,
    "indent-binary-ops": indent_binary_ops_default,
    "jsx-child-element-spacing": jsx_child_element_spacing_default,
    "jsx-closing-bracket-location": jsx_closing_bracket_location_default,
    "jsx-closing-tag-location": jsx_closing_tag_location_default,
    "jsx-curly-brace-presence": jsx_curly_brace_presence_default,
    "jsx-curly-newline": jsx_curly_newline_default,
    "jsx-curly-spacing": jsx_curly_spacing_default,
    "jsx-equals-spacing": jsx_equals_spacing_default,
    "jsx-first-prop-new-line": jsx_first_prop_new_line_default,
    "jsx-function-call-newline": jsx_function_call_newline_default,
    "jsx-indent": jsx_indent_default,
    "jsx-indent-props": jsx_indent_props_default,
    "jsx-max-props-per-line": jsx_max_props_per_line_default,
    "jsx-newline": jsx_newline_default,
    "jsx-one-expression-per-line": jsx_one_expression_per_line_default,
    "jsx-pascal-case": jsx_pascal_case_default,
    "jsx-props-no-multi-spaces": jsx_props_no_multi_spaces_default,
    "jsx-quotes": jsx_quotes_default,
    "jsx-self-closing-comp": jsx_self_closing_comp_default,
    "jsx-sort-props": jsx_sort_props_default,
    "jsx-tag-spacing": jsx_tag_spacing_default,
    "jsx-wrap-multilines": jsx_wrap_multilines_default,
    "key-spacing": key_spacing_default,
    "keyword-spacing": keyword_spacing_default,
    "line-comment-position": line_comment_position_default,
    "linebreak-style": linebreak_style_default,
    "lines-around-comment": lines_around_comment_default,
    "lines-between-class-members": lines_between_class_members_default,
    "exp-list-style": list_style_default,
    "max-len": max_len_default,
    "max-statements-per-line": max_statements_per_line_default,
    "member-delimiter-style": member_delimiter_style_default,
    "multiline-comment-style": multiline_comment_style_default,
    "multiline-ternary": multiline_ternary_default,
    "new-parens": new_parens_default,
    "newline-per-chained-call": newline_per_chained_call_default,
    "no-confusing-arrow": no_confusing_arrow_default,
    "no-extra-parens": no_extra_parens_default,
    "no-extra-semi": no_extra_semi_default,
    "no-floating-decimal": no_floating_decimal_default,
    "no-mixed-operators": no_mixed_operators_default,
    "no-mixed-spaces-and-tabs": no_mixed_spaces_and_tabs_default,
    "no-multi-spaces": no_multi_spaces_default,
    "no-multiple-empty-lines": no_multiple_empty_lines_default,
    "no-tabs": no_tabs_default,
    "no-trailing-spaces": no_trailing_spaces_default,
    "no-whitespace-before-property": no_whitespace_before_property_default,
    "nonblock-statement-body-position": nonblock_statement_body_position_default,
    "object-curly-newline": object_curly_newline_default,
    "object-curly-spacing": object_curly_spacing_default,
    "object-property-newline": object_property_newline_default,
    "one-var-declaration-per-line": one_var_declaration_per_line_default,
    "operator-linebreak": operator_linebreak_default,
    "padded-blocks": padded_blocks_default,
    "padding-line-between-statements": padding_line_between_statements_default,
    "quote-props": quote_props_default,
    "quotes": quotes_default,
    "rest-spread-spacing": rest_spread_spacing_default,
    "semi": semi_default,
    "semi-spacing": semi_spacing_default,
    "semi-style": semi_style_default,
    "space-before-blocks": space_before_blocks_default,
    "space-before-function-paren": space_before_function_paren_default,
    "space-in-parens": space_in_parens_default,
    "space-infix-ops": space_infix_ops_default,
    "space-unary-ops": space_unary_ops_default,
    "spaced-comment": spaced_comment_default,
    "switch-colon-spacing": switch_colon_spacing_default,
    "template-curly-spacing": template_curly_spacing_default,
    "template-tag-spacing": template_tag_spacing_default,
    "type-annotation-spacing": type_annotation_spacing_default,
    "type-generic-spacing": type_generic_spacing_default,
    "type-named-tuple-spacing": type_named_tuple_spacing_default,
    "wrap-iife": wrap_iife_default,
    "wrap-regex": wrap_regex_default,
    "yield-star-spacing": yield_star_spacing_default
  }
};
function customize(options = {}) {
  const defaultPluginName = plugin_default.meta.namespace;
  const { arrowParens = false, blockSpacing = true, braceStyle = "stroustrup", commaDangle = "always-multiline", experimental: enableExperimentalRules = false, indent = 2, jsx: jsx2 = true, pluginName = defaultPluginName, quoteProps = "consistent-as-needed", quotes = "single", semi = false, severity = "error" } = options;
  const [indentLevel = 2, indentOptions = {
    ArrayExpression: 1,
    CallExpression: { arguments: 1 },
    flatTernaryExpressions: false,
    FunctionDeclaration: {
      body: 1,
      parameters: 1,
      returnType: 1
    },
    FunctionExpression: {
      body: 1,
      parameters: 1,
      returnType: 1
    },
    ignoreComments: false,
    ignoredNodes: ["TSUnionType", "TSIntersectionType"],
    ImportDeclaration: 1,
    MemberExpression: 1,
    ObjectExpression: 1,
    offsetTernaryExpressions: true,
    outerIIFEBody: 1,
    SwitchCase: 1,
    tabLength: indentLevel === "tab" ? 4 : indentLevel,
    VariableDeclarator: 1
  }] = Array.isArray(indent) ? indent : [indent];
  let rules = {
    "@stylistic/array-bracket-spacing": [severity, "never"],
    "@stylistic/arrow-parens": [
      severity,
      arrowParens ? "always" : "as-needed",
      { requireForBlockBody: true }
    ],
    "@stylistic/arrow-spacing": [severity, {
      after: true,
      before: true
    }],
    "@stylistic/block-spacing": [severity, blockSpacing ? "always" : "never"],
    "@stylistic/brace-style": [
      severity,
      braceStyle,
      { allowSingleLine: true }
    ],
    "@stylistic/comma-dangle": [severity, commaDangle],
    "@stylistic/comma-spacing": [severity, {
      after: true,
      before: false
    }],
    "@stylistic/comma-style": [severity, "last"],
    "@stylistic/computed-property-spacing": [
      severity,
      "never",
      { enforceForClassMembers: true }
    ],
    "@stylistic/dot-location": [severity, "property"],
    "@stylistic/eol-last": severity,
    "@stylistic/generator-star-spacing": [severity, {
      after: true,
      before: false
    }],
    "@stylistic/indent": [
      severity,
      indentLevel,
      indentOptions
    ],
    "@stylistic/indent-binary-ops": [severity, indentLevel],
    "@stylistic/key-spacing": [severity, {
      afterColon: true,
      beforeColon: false
    }],
    "@stylistic/keyword-spacing": [severity, {
      after: true,
      before: true
    }],
    "@stylistic/lines-between-class-members": [
      severity,
      "always",
      { exceptAfterSingleLine: true }
    ],
    "@stylistic/max-statements-per-line": [severity, { max: 1 }],
    "@stylistic/member-delimiter-style": [severity, {
      multiline: {
        delimiter: semi ? "semi" : "none",
        requireLast: semi
      },
      multilineDetection: "brackets",
      overrides: { interface: { multiline: {
        delimiter: semi ? "semi" : "none",
        requireLast: semi
      } } },
      singleline: { delimiter: semi ? "semi" : "comma" }
    }],
    "@stylistic/multiline-ternary": [severity, "always-multiline"],
    "@stylistic/new-parens": severity,
    "@stylistic/no-extra-parens": [severity, "functions"],
    "@stylistic/no-floating-decimal": severity,
    "@stylistic/no-mixed-operators": [severity, {
      allowSamePrecedence: true,
      groups: [
        [
          "==",
          "!=",
          "===",
          "!==",
          ">",
          ">=",
          "<",
          "<="
        ],
        ["&&", "||"],
        ["in", "instanceof"]
      ]
    }],
    "@stylistic/no-mixed-spaces-and-tabs": severity,
    "@stylistic/no-multi-spaces": severity,
    "@stylistic/no-multiple-empty-lines": [severity, {
      max: 1,
      maxBOF: 0,
      maxEOF: 0
    }],
    "@stylistic/no-tabs": indentLevel === "tab" ? "off" : severity,
    "@stylistic/no-trailing-spaces": severity,
    "@stylistic/no-whitespace-before-property": severity,
    "@stylistic/object-curly-spacing": [severity, "always"],
    "@stylistic/operator-linebreak": [severity, "before"],
    "@stylistic/padded-blocks": [severity, {
      blocks: "never",
      classes: "never",
      switches: "never"
    }],
    "@stylistic/quote-props": [severity, quoteProps],
    "@stylistic/quotes": [
      severity,
      quotes,
      {
        allowTemplateLiterals: "always",
        avoidEscape: false
      }
    ],
    "@stylistic/rest-spread-spacing": [severity, "never"],
    "@stylistic/semi": [severity, semi ? "always" : "never"],
    "@stylistic/semi-spacing": [severity, {
      after: true,
      before: false
    }],
    "@stylistic/space-before-blocks": [severity, "always"],
    "@stylistic/space-before-function-paren": [severity, {
      anonymous: "always",
      asyncArrow: "always",
      named: "never"
    }],
    "@stylistic/space-in-parens": [severity, "never"],
    "@stylistic/space-infix-ops": severity,
    "@stylistic/space-unary-ops": [severity, {
      nonwords: false,
      words: true
    }],
    "@stylistic/spaced-comment": [
      severity,
      "always",
      {
        block: {
          balanced: true,
          exceptions: ["*"],
          markers: ["!"]
        },
        line: {
          exceptions: ["/", "#"],
          markers: ["/"]
        }
      }
    ],
    "@stylistic/template-curly-spacing": severity,
    "@stylistic/template-tag-spacing": [severity, "never"],
    "@stylistic/type-annotation-spacing": [severity, {}],
    "@stylistic/type-generic-spacing": severity,
    "@stylistic/type-named-tuple-spacing": severity,
    "@stylistic/wrap-iife": [
      severity,
      "any",
      { functionPrototypeMethods: true }
    ],
    "@stylistic/yield-star-spacing": [severity, {
      after: true,
      before: false
    }],
    ...jsx2 ? {
      "@stylistic/jsx-closing-bracket-location": severity,
      "@stylistic/jsx-closing-tag-location": severity,
      "@stylistic/jsx-curly-brace-presence": [severity, { propElementValues: "always" }],
      "@stylistic/jsx-curly-newline": severity,
      "@stylistic/jsx-curly-spacing": [severity, "never"],
      "@stylistic/jsx-equals-spacing": severity,
      "@stylistic/jsx-first-prop-new-line": severity,
      "@stylistic/jsx-function-call-newline": [severity, "multiline"],
      "@stylistic/jsx-indent-props": [severity, indentLevel],
      "@stylistic/jsx-max-props-per-line": [severity, {
        maximum: 1,
        when: "multiline"
      }],
      "@stylistic/jsx-one-expression-per-line": [severity, { allow: "single-child" }],
      "@stylistic/jsx-quotes": severity,
      "@stylistic/jsx-tag-spacing": [severity, {
        afterOpening: "never",
        beforeClosing: "never",
        beforeSelfClosing: "always",
        closingSlash: "never"
      }],
      "@stylistic/jsx-wrap-multilines": [severity, {
        arrow: "parens-new-line",
        assignment: "parens-new-line",
        condition: "parens-new-line",
        declaration: "parens-new-line",
        logical: "parens-new-line",
        prop: "parens-new-line",
        propertyValue: "parens-new-line",
        return: "parens-new-line"
      }]
    } : {}
  };
  if (enableExperimentalRules) rules = {
    ...rules,
    "@stylistic/array-bracket-newline": "off",
    "@stylistic/array-bracket-spacing": "off",
    "@stylistic/array-element-newline": "off",
    "@stylistic/exp-list-style": "error",
    "@stylistic/function-call-argument-newline": "off",
    "@stylistic/function-paren-newline": "off",
    "@stylistic/jsx-function-call-newline": "off",
    "@stylistic/object-curly-newline": "off",
    "@stylistic/object-curly-spacing": "off",
    "@stylistic/object-property-newline": "off"
  };
  if (pluginName !== defaultPluginName) {
    const regex = new RegExp(`^${defaultPluginName}/`);
    rules = Object.fromEntries(Object.entries(rules).map(([ruleName, ruleConfig]) => [ruleName.replace(regex, `${pluginName}/`), ruleConfig]));
  }
  return {
    plugins: { [pluginName]: plugin_default },
    rules
  };
}
var disable_legacy_default = { rules: {
  "array-bracket-newline": 0,
  "array-bracket-spacing": 0,
  "array-element-newline": 0,
  "arrow-parens": 0,
  "arrow-spacing": 0,
  "block-spacing": 0,
  "brace-style": 0,
  "comma-dangle": 0,
  "comma-spacing": 0,
  "comma-style": 0,
  "computed-property-spacing": 0,
  "dot-location": 0,
  "eol-last": 0,
  "func-call-spacing": 0,
  "function-call-argument-newline": 0,
  "function-paren-newline": 0,
  "generator-star-spacing": 0,
  "implicit-arrow-linebreak": 0,
  "indent": 0,
  "jsx-quotes": 0,
  "key-spacing": 0,
  "keyword-spacing": 0,
  "linebreak-style": 0,
  "lines-around-comment": 0,
  "lines-between-class-members": 0,
  "max-len": 0,
  "max-statements-per-line": 0,
  "multiline-ternary": 0,
  "multiline-comment-style": 0,
  "new-parens": 0,
  "newline-per-chained-call": 0,
  "no-confusing-arrow": 0,
  "no-extra-parens": 0,
  "no-extra-semi": 0,
  "no-floating-decimal": 0,
  "no-mixed-operators": 0,
  "no-mixed-spaces-and-tabs": 0,
  "no-multi-spaces": 0,
  "no-multiple-empty-lines": 0,
  "no-tabs": 0,
  "no-trailing-spaces": 0,
  "no-whitespace-before-property": 0,
  "nonblock-statement-body-position": 0,
  "object-curly-newline": 0,
  "object-curly-spacing": 0,
  "object-property-newline": 0,
  "one-var-declaration-per-line": 0,
  "operator-linebreak": 0,
  "padded-blocks": 0,
  "padding-line-between-statements": 0,
  "quote-props": 0,
  "quotes": 0,
  "rest-spread-spacing": 0,
  "semi": 0,
  "semi-spacing": 0,
  "semi-style": 0,
  "space-before-blocks": 0,
  "space-before-function-paren": 0,
  "space-in-parens": 0,
  "space-infix-ops": 0,
  "space-unary-ops": 0,
  "spaced-comment": 0,
  "switch-colon-spacing": 0,
  "template-curly-spacing": 0,
  "template-tag-spacing": 0,
  "wrap-iife": 0,
  "wrap-regex": 0,
  "yield-star-spacing": 0,
  "@typescript-eslint/block-spacing": 0,
  "@typescript-eslint/brace-style": 0,
  "@typescript-eslint/comma-dangle": 0,
  "@typescript-eslint/comma-spacing": 0,
  "@typescript-eslint/func-call-spacing": 0,
  "@typescript-eslint/indent": 0,
  "@typescript-eslint/key-spacing": 0,
  "@typescript-eslint/keyword-spacing": 0,
  "@typescript-eslint/lines-around-comment": 0,
  "@typescript-eslint/lines-between-class-members": 0,
  "@typescript-eslint/member-delimiter-style": 0,
  "@typescript-eslint/no-extra-parens": 0,
  "@typescript-eslint/no-extra-semi": 0,
  "@typescript-eslint/object-curly-spacing": 0,
  "@typescript-eslint/padding-line-between-statements": 0,
  "@typescript-eslint/quotes": 0,
  "@typescript-eslint/semi": 0,
  "@typescript-eslint/space-before-blocks": 0,
  "@typescript-eslint/space-before-function-paren": 0,
  "@typescript-eslint/space-infix-ops": 0,
  "@typescript-eslint/type-annotation-spacing": 0,
  "react/jsx-child-element-spacing": 0,
  "react/jsx-closing-bracket-location": 0,
  "react/jsx-closing-tag-location": 0,
  "react/jsx-curly-brace-presence": 0,
  "react/jsx-curly-newline": 0,
  "react/jsx-curly-spacing": 0,
  "react/jsx-equals-spacing": 0,
  "react/jsx-first-prop-new-line": 0,
  "react/jsx-indent": 0,
  "react/jsx-indent-props": 0,
  "react/jsx-max-props-per-line": 0,
  "react/jsx-newline": 0,
  "react/jsx-one-expression-per-line": 0,
  "react/jsx-pascal-case": 0,
  "react/jsx-props-no-multi-spaces": 0,
  "react/self-closing-comp": 0,
  "react/jsx-sort-props": 0,
  "react/jsx-tag-spacing": 0,
  "react/jsx-wrap-multilines": 0
} };
var allConfigsIgnore = [/^jsx-/, /^curly-newline$/];
var all = /* @__PURE__ */ createAllConfigs(plugin_default, "@stylistic", (name) => !allConfigsIgnore.some((re) => re.test(name)));
var recommended = /* @__PURE__ */ customize();
var configs = new Proxy({
  "disable-legacy": disable_legacy_default,
  "customize": customize,
  "recommended": recommended,
  "recommended-flat": recommended,
  "all": all,
  "all-flat": all
}, { get(target, p, receiver) {
  const prop = p.toString();
  if (prop.endsWith("-flat")) warnDeprecation(`config("${prop}")`, `"${prop.replace("-flat", "")}"`);
  return Reflect.get(target, p, receiver);
} });

// node_modules/@stylistic/eslint-plugin/dist/index.js
var index = Object.assign(plugin_default, { configs });
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  "module.exports": null
});
